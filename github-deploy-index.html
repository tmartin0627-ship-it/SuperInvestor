<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <title>BULL RUN - A Wall Street Adventure</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      height: 100dvh;
      font-family: sans-serif;
      -webkit-user-select: none;
      user-select: none;
    }
    canvas {
      display: block;
      touch-action: none;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
// Math.clamp polyfill
Math.clamp = Math.clamp || function(val, min, max) {
  return Math.max(min, Math.min(max, val));
};

const GameState = {
  TITLE: 'title',
  CHARACTER_SELECT: 'characterSelect',
  PLAYING: 'playing',
  GAME_OVER: 'gameOver',
  LEVEL_COMPLETE: 'levelComplete'
};

// Supabase config — fill in with your project credentials
const SUPABASE_URL = 'https://ldvqqitugklrutkooofg.supabase.co';
const SUPABASE_ANON_KEY = 'sb_publishable_0ELBZFneSvZPgjy314KWVQ_XbgU4x-A';

const CONFIG = {
  // Display
  VIRTUAL_WIDTH: 960,
  VIRTUAL_HEIGHT: 540,
  TILE_SIZE: 48,

  // Physics
  GRAVITY: 1800,
  MAX_FALL_SPEED: 900,
  GROUND_FRICTION: 0.85,

  // Player
  PLAYER_WIDTH: 36,
  PLAYER_HEIGHT: 54,
  PLAYER_RUN_SPEED: 280,
  PLAYER_ACCELERATION: 1400,
  PLAYER_JUMP_VELOCITY: -580,
  PLAYER_SUPER_JUMP_VELOCITY: -750,  // Crouch-jump: ~170px height vs ~93px normal
  PLAYER_CROUCH_TIME: 0.25,          // Seconds to hold crouch before super jump is ready
  PLAYER_CROUCH_HEIGHT: 34,          // Crouched height (shorter)
  PLAYER_STOMP_BOUNCE: -350,
  PLAYER_MAX_LIVES: 3,
  PLAYER_INVINCIBILITY_TIME: 2.0,
  PLAYER_POWERED_WIDTH: 42,
  PLAYER_POWERED_HEIGHT: 66,
  PLAYER_POWERED_CROUCH_HEIGHT: 42,  // Crouched height when powered

  // Enemies
  BABY_BEAR_SPEED: 80,
  BABY_BEAR_WIDTH: 36,
  BABY_BEAR_HEIGHT: 36,
  GRIZZLY_SPEED: 120,
  GRIZZLY_CHARGE_SPEED: 250,
  GRIZZLY_WIDTH: 54,
  GRIZZLY_HEIGHT: 54,
  GRIZZLY_DETECT_RANGE: 250,
  GRIZZLY_HP: 2,

  // Flash Trader
  FLASH_TRADER_SPEED: 150,
  FLASH_TRADER_WIDTH: 30,
  FLASH_TRADER_HEIGHT: 30,
  FLASH_TRADER_DASH_INTERVAL: 2.5,
  FLASH_TRADER_DASH_DISTANCE: 100,

  // Short Seller
  SHORT_SELLER_SPEED: 60,
  SHORT_SELLER_WIDTH: 40,
  SHORT_SELLER_HEIGHT: 36,

  // Collectibles
  BULL_WIDTH: 30,
  BULL_HEIGHT: 26,
  BULL_BOB_SPEED: 3,
  BULL_BOB_AMPLITUDE: 6,
  BULL_SCORE: 100,
  BULLS_FOR_DIAMOND_HANDS: 100,
  DIAMOND_HANDS_DURATION: 10.0,
  DIVIDEND_SCORE: 500,

  // Question Block
  BLOCK_SIZE: 48,
  BLOCK_BUMP_HEIGHT: 12,
  BLOCK_BUMP_DURATION: 0.2,

  // Camera
  CAMERA_LOOKAHEAD: 100,
  CAMERA_SMOOTHING: 0.08,
  CAMERA_DEAD_ZONE_X: 50,

  // Parallax
  BG_LAYER_SPEEDS: [0.1, 0.3, 0.6],

  // Colors
  COLORS: {
    SKY_TOP: '#0a0a2e',
    SKY_MID: '#1a1a3e',
    SKY_BOTTOM: '#2a2a4e',
    GROUND: '#2d2d4e',
    GROUND_TOP: '#3d3d5e',
    PLATFORM_DESK: '#8B6914',
    PLATFORM_DESK_TOP: '#A07818',
    PLATFORM_LEDGE: '#5a5a7a',
    PLATFORM_TAXI: '#f0c040',
    PLATFORM_TAXI_DARK: '#c09a30',
    QUESTION_BLOCK: '#FFD700',
    QUESTION_BLOCK_BORDER: '#B8860B',
    QUESTION_BLOCK_USED: '#8B7355',
    PLAYER_SUIT: '#1a1a40',
    PLAYER_SHIRT: '#FFFFFF',
    PLAYER_TIE: '#cc0000',
    PLAYER_SKIN: '#f5d0a0',
    PLAYER_HAIR_MALE: '#2a2a2a',
    PLAYER_HAIR_FEMALE: '#8B4513',
    PLAYER_BLAZER: '#2a2a5a',
    PLAYER_BLAZER_LIGHT: '#3a3a6a',
    BEAR_BROWN: '#8B4513',
    BEAR_DARK: '#5C3317',
    BEAR_BELLY: '#D2B48C',
    BULL_GOLD: '#FFD700',
    BULL_BODY: '#DAA520',
    BULL_DARK: '#B8860B',
    GREEN_CANDLE: '#00CC66',
    GREEN_CANDLE_DARK: '#009944',
    CHARGING_BULL: '#FFD700',
    BUILDING_1: '#1a1a3a',
    BUILDING_2: '#252545',
    BUILDING_3: '#2a2a4a',
    BUILDING_4: '#1f1f3f',
    WINDOW_LIT: '#FFE4B5',
    WINDOW_LIT_2: '#87CEEB',
    WINDOW_DARK: '#0e0e1e',
    HUD_BG: 'rgba(0,0,0,0.7)',
    TICKER_BG: 'rgba(0,0,0,0.85)',
    TICKER_GREEN: '#00FF88',
    TICKER_RED: '#FF4444',
    PIT_VOID: '#0a0a1a',
    PARTICLE_RED: '#FF3333',
    PARTICLE_BEAR: '#8B4513',
    GOLDEN: '#FFD700',
    WHITE: '#FFFFFF',
    BLACK: '#000000',
  }
};
  </script>
  <script>
class InputHandler {
  constructor() {
    this.keys = {};
    this.justPressed = {};

    // Touch state (set by TouchControls)
    this.touchState = { left: false, right: false, down: false };
    this.touchJustPressed = {};

    window.addEventListener('keydown', (e) => {
      if (!this.keys[e.code]) {
        this.justPressed[e.code] = true;
      }
      this.keys[e.code] = true;
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
        e.preventDefault();
      }
    });

    window.addEventListener('keyup', (e) => {
      this.keys[e.code] = false;
    });

    // Reset keys when window loses focus
    window.addEventListener('blur', () => {
      this.keys = {};
      this.justPressed = {};
      this.touchState = { left: false, right: false, down: false };
      this.touchJustPressed = {};
    });
  }

  isHeld(code) { return !!this.keys[code]; }
  wasPressed(code) { return !!this.justPressed[code] || !!this.touchJustPressed[code]; }

  // Called by TouchControls for continuous hold actions (movement, crouch)
  setTouch(action, pressed) {
    this.touchState[action] = pressed;
  }

  // Called by TouchControls for one-frame actions (jump, enter)
  triggerTouch(action) {
    this.touchJustPressed[action] = true;
  }

  clearFrameState() {
    this.justPressed = {};
    this.touchJustPressed = {};
  }

  get left() { return this.isHeld('ArrowLeft') || this.isHeld('KeyA') || this.touchState.left; }
  get right() { return this.isHeld('ArrowRight') || this.isHeld('KeyD') || this.touchState.right; }
  get down() { return this.isHeld('ArrowDown') || this.isHeld('KeyS') || this.touchState.down; }
  get jump() { return this.wasPressed('Space') || this.wasPressed('ArrowUp') || this.wasPressed('KeyW'); }
  get enter() { return this.wasPressed('Enter') || this.wasPressed('Space'); }
}
  </script>
  <script>
// ==========================================
//  Touch Controls for Mobile Browser Play
// ==========================================
// Left half: movement (left/right based on touch position)
// Right half: tap = jump, hold = crouch, release after hold = super jump

class TouchControls {
  constructor(canvas, input) {
    this.canvas = canvas;
    this.input = input;
    this.active = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

    if (!this.active) return;

    // Track active touches by identifier
    this.touches = {};  // id -> { x, y, startX, startY, startTime, zone: 'left'|'right' }

    // State
    this.rightHoldStart = 0;   // timestamp when right zone touch began
    this.rightTouchId = null;  // active right-zone touch id
    this.leftTouchId = null;   // active left-zone touch id
    this.rightCrouchActivated = false;  // true once hold exceeds 150ms
    this.currentGameState = GameState.TITLE;

    // Visual hint fade
    this.hintAlpha = 1.0;
    this.gameplayTime = 0;
    this.hintFadeDuration = 6; // seconds until hints fully fade
    this.showingHints = true;

    // Glow feedback
    this.leftGlow = 0;
    this.rightGlow = 0;

    // Bind events
    const opts = { passive: false };
    canvas.addEventListener('touchstart', (e) => this._onTouchStart(e), opts);
    canvas.addEventListener('touchmove', (e) => this._onTouchMove(e), opts);
    canvas.addEventListener('touchend', (e) => this._onTouchEnd(e), opts);
    canvas.addEventListener('touchcancel', (e) => this._onTouchEnd(e), opts);
  }

  _getZone(x) {
    return x < this.canvas.width * 0.5 ? 'left' : 'right';
  }

  _onTouchStart(e) {
    e.preventDefault();

    // On menu screens, any tap = Enter
    if (this.currentGameState !== GameState.PLAYING) {
      // For character select, tap left/right half to pick character
      if (this.currentGameState === GameState.TITLE) {
        const touch = e.changedTouches[0];
        const zone = this._getZone(touch.clientX);
        if (zone === 'left') {
          this.input.triggerTouch('ArrowLeft');
        } else {
          this.input.triggerTouch('ArrowRight');
        }
      }
      this.input.triggerTouch('Enter');
      this.input.triggerTouch('Space');
      return;
    }

    for (const touch of e.changedTouches) {
      const zone = this._getZone(touch.clientX);
      this.touches[touch.identifier] = {
        x: touch.clientX,
        y: touch.clientY,
        startX: touch.clientX,
        startY: touch.clientY,
        startTime: performance.now(),
        zone: zone
      };

      if (zone === 'left') {
        this.leftTouchId = touch.identifier;
        this._updateMovement(touch.clientX);
        this.leftGlow = 0.5;
      } else {
        this.rightTouchId = touch.identifier;
        this.rightHoldStart = performance.now();
        this.rightCrouchActivated = false;
        // Don't crouch immediately — wait a bit so quick taps feel like pure jumps
        // Crouch activates after 150ms (see update method)
        this.rightGlow = 0.5;
      }
    }
  }

  _onTouchMove(e) {
    e.preventDefault();

    for (const touch of e.changedTouches) {
      const t = this.touches[touch.identifier];
      if (!t) continue;

      t.x = touch.clientX;
      t.y = touch.clientY;

      // Only update movement for left-zone touches
      if (t.zone === 'left' && touch.identifier === this.leftTouchId) {
        this._updateMovement(touch.clientX);
      }
    }
  }

  _onTouchEnd(e) {
    e.preventDefault();

    for (const touch of e.changedTouches) {
      const t = this.touches[touch.identifier];
      if (!t) continue;

      if (t.zone === 'left' && touch.identifier === this.leftTouchId) {
        this.input.setTouch('left', false);
        this.input.setTouch('right', false);
        this.leftTouchId = null;
      } else if (t.zone === 'right' && touch.identifier === this.rightTouchId) {
        const holdDuration = performance.now() - this.rightHoldStart;

        // Release crouch if it was activated
        if (this.rightCrouchActivated) {
          this.input.setTouch('down', false);
        }

        // Always trigger jump on release — the game decides normal vs super
        // Quick tap (< 150ms) = never crouched, so normal jump
        // Long hold = was crouching, superJumpReady may be set, so super jump
        this.input.triggerTouch('Space');

        this.rightTouchId = null;
        this.rightCrouchActivated = false;
      }

      delete this.touches[touch.identifier];
    }
  }

  _updateMovement(touchX) {
    const screenWidth = this.canvas.width;
    // Left half is the movement zone (0 to 50%)
    // Within that: left quarter (0-25%) = move left, right quarter (25-50%) = move right
    const midpoint = screenWidth * 0.25;

    if (touchX < midpoint) {
      this.input.setTouch('left', true);
      this.input.setTouch('right', false);
    } else {
      this.input.setTouch('left', false);
      this.input.setTouch('right', true);
    }
  }

  update(dt, gameState) {
    if (!this.active) return;
    this.currentGameState = gameState;

    // Track gameplay time for hint fading
    if (gameState === GameState.PLAYING) {
      this.gameplayTime += dt;
      if (this.gameplayTime > this.hintFadeDuration) {
        this.hintAlpha = Math.max(0, 1.0 - (this.gameplayTime - this.hintFadeDuration) / 2);
      }
    } else {
      // Reset hints when not playing (so they show again on new game)
      this.gameplayTime = 0;
      this.hintAlpha = 1.0;
    }

    // Activate crouch after 150ms of holding right side (so quick taps don't crouch)
    if (this.rightTouchId !== null && !this.rightCrouchActivated) {
      const holdTime = performance.now() - this.rightHoldStart;
      if (holdTime >= 150) {
        this.rightCrouchActivated = true;
        this.input.setTouch('down', true);
      }
    }

    // Fade glow
    this.leftGlow = Math.max(0, this.leftGlow - dt * 2);
    this.rightGlow = Math.max(0, this.rightGlow - dt * 2);
  }

  render(ctx, screenW, screenH, gameState) {
    if (!this.active) return;

    // Always show hints on menus, fade during gameplay
    const alpha = gameState === GameState.PLAYING ? this.hintAlpha : 0.7;
    if (alpha <= 0.01) return; // fully faded, skip rendering

    ctx.save();

    // Zone divider line
    ctx.strokeStyle = 'rgba(255, 255, 255, ' + (alpha * 0.15) + ')';
    ctx.lineWidth = 1;
    ctx.setLineDash([10, 10]);
    ctx.beginPath();
    ctx.moveTo(screenW * 0.5, screenH * 0.3);
    ctx.lineTo(screenW * 0.5, screenH);
    ctx.stroke();
    ctx.setLineDash([]);

    // Active zone glow
    if (this.leftGlow > 0) {
      ctx.fillStyle = 'rgba(255, 255, 255, ' + (this.leftGlow * 0.08) + ')';
      ctx.fillRect(0, 0, screenW * 0.5, screenH);
    }
    if (this.rightGlow > 0) {
      ctx.fillStyle = 'rgba(255, 215, 0, ' + (this.rightGlow * 0.08) + ')';
      ctx.fillRect(screenW * 0.5, 0, screenW * 0.5, screenH);
    }

    // Hint text and arrows
    const fontSize = Math.max(12, Math.min(16, screenW * 0.025));
    ctx.font = fontSize + 'px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Left side hints
    const leftCenterX = screenW * 0.25;
    const hintY = screenH * 0.85;

    // Left arrow
    ctx.fillStyle = 'rgba(255, 255, 255, ' + (alpha * 0.4) + ')';
    const arrowSize = Math.max(20, screenW * 0.035);
    this._drawArrow(ctx, screenW * 0.12, hintY, arrowSize, 'left', alpha * 0.4);

    // Right arrow
    this._drawArrow(ctx, screenW * 0.38, hintY, arrowSize, 'right', alpha * 0.4);

    // "MOVE" label
    ctx.fillStyle = 'rgba(255, 255, 255, ' + (alpha * 0.3) + ')';
    ctx.fillText('MOVE', leftCenterX, hintY + arrowSize + 8);

    // Right side hints
    const rightCenterX = screenW * 0.75;

    // Jump icon (up arrow)
    this._drawArrow(ctx, rightCenterX - arrowSize * 1.2, hintY, arrowSize, 'up', alpha * 0.4);

    // Crouch icon (down arrow)
    this._drawArrow(ctx, rightCenterX + arrowSize * 1.2, hintY, arrowSize * 0.8, 'down', alpha * 0.3);

    // Labels
    ctx.fillStyle = 'rgba(255, 255, 255, ' + (alpha * 0.3) + ')';
    ctx.fillText('TAP = JUMP', rightCenterX, hintY + arrowSize + 8);

    const smallFont = Math.max(10, fontSize * 0.8);
    ctx.font = smallFont + 'px sans-serif';
    ctx.fillStyle = 'rgba(255, 215, 0, ' + (alpha * 0.3) + ')';
    ctx.fillText('HOLD = CROUCH + SUPER JUMP', rightCenterX, hintY + arrowSize + 8 + smallFont + 4);

    // Show active touch indicators
    if (this.leftTouchId !== null && this.touches[this.leftTouchId]) {
      const t = this.touches[this.leftTouchId];
      ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
      ctx.beginPath();
      ctx.arc(t.x, t.y, 40, 0, Math.PI * 2);
      ctx.fill();
    }
    if (this.rightTouchId !== null && this.touches[this.rightTouchId]) {
      const t = this.touches[this.rightTouchId];
      const holdTime = performance.now() - this.rightHoldStart;
      const color = holdTime > 250 ? 'rgba(255, 215, 0, 0.2)' : 'rgba(255, 255, 255, 0.15)';
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(t.x, t.y, 40, 0, Math.PI * 2);
      ctx.fill();

      // Charging indicator ring
      if (holdTime > 100) {
        const charge = Math.min(1, holdTime / 250);
        ctx.strokeStyle = 'rgba(255, 215, 0, ' + (charge * 0.5) + ')';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(t.x, t.y, 45, -Math.PI / 2, -Math.PI / 2 + charge * Math.PI * 2);
        ctx.stroke();
      }
    }

    ctx.restore();
  }

  _drawArrow(ctx, x, y, size, direction, alpha) {
    ctx.fillStyle = 'rgba(255, 255, 255, ' + alpha + ')';
    ctx.beginPath();
    const hs = size / 2;
    switch (direction) {
      case 'left':
        ctx.moveTo(x - hs, y);
        ctx.lineTo(x + hs, y - hs);
        ctx.lineTo(x + hs, y + hs);
        break;
      case 'right':
        ctx.moveTo(x + hs, y);
        ctx.lineTo(x - hs, y - hs);
        ctx.lineTo(x - hs, y + hs);
        break;
      case 'up':
        ctx.moveTo(x, y - hs);
        ctx.lineTo(x - hs, y + hs);
        ctx.lineTo(x + hs, y + hs);
        break;
      case 'down':
        ctx.moveTo(x, y + hs);
        ctx.lineTo(x - hs, y - hs);
        ctx.lineTo(x + hs, y - hs);
        break;
    }
    ctx.closePath();
    ctx.fill();
  }
}
  </script>
  <script>
class Camera {
  constructor(viewportWidth, viewportHeight) {
    this.x = 0;
    this.y = 0;
    this.viewportWidth = viewportWidth;
    this.viewportHeight = viewportHeight;
    this.levelWidth = 0;
    this.levelHeight = 0;
  }

  follow(target, dt) {
    const lookahead = target.facingRight ? CONFIG.CAMERA_LOOKAHEAD : -CONFIG.CAMERA_LOOKAHEAD;
    const targetX = target.x + target.width / 2 - this.viewportWidth / 2 + lookahead;

    const dx = targetX - this.x;
    if (Math.abs(dx) > CONFIG.CAMERA_DEAD_ZONE_X) {
      this.x += dx * CONFIG.CAMERA_SMOOTHING;
    }

    const targetY = target.y + target.height / 2 - this.viewportHeight * 0.6;
    this.y += (targetY - this.y) * 0.12;

    // Clamp to level bounds
    this.x = Math.max(0, Math.min(this.x, this.levelWidth - this.viewportWidth));
    this.y = Math.max(0, Math.min(this.y, this.levelHeight - this.viewportHeight));
  }
}
  </script>
  <script>
function aabbOverlap(a, b) {
  return a.x < b.x + b.width &&
         a.x + a.width > b.x &&
         a.y < b.y + b.height &&
         a.y + a.height > b.y;
}

function getOverlap(a, b) {
  const overlapX = Math.min(a.x + a.width, b.x + b.width) - Math.max(a.x, b.x);
  const overlapY = Math.min(a.y + a.height, b.y + b.height) - Math.max(a.y, b.y);
  if (overlapX <= 0 || overlapY <= 0) return null;
  return { x: overlapX, y: overlapY };
}

function applyGravity(entity, dt) {
  entity.vy += CONFIG.GRAVITY * dt;
  if (entity.vy > CONFIG.MAX_FALL_SPEED) {
    entity.vy = CONFIG.MAX_FALL_SPEED;
  }
}

// Proper two-pass collision for the player:
// Move on X axis, resolve X collisions, then move on Y axis, resolve Y collisions.
// This prevents the ambiguity that causes "sticking" to walls.
function moveAndCollide(entity, solids, dt) {
  // 1. Move horizontally only
  entity.x += entity.vx * dt;

  // 2. Resolve horizontal collisions (skip semi-solid platforms — no side blocking)
  for (const solid of solids) {
    if (solid.semiSolid) continue;
    if (!aabbOverlap(entity, solid)) continue;
    if (entity.vx > 0) {
      entity.x = solid.x - entity.width;
    } else if (entity.vx < 0) {
      entity.x = solid.x + solid.width;
    } else {
      // Zero velocity overlap — push out by nearest side
      const moverCenter = entity.x + entity.width / 2;
      const solidCenter = solid.x + solid.width / 2;
      if (moverCenter < solidCenter) {
        entity.x = solid.x - entity.width;
      } else {
        entity.x = solid.x + solid.width;
      }
    }
    entity.vx = 0;
  }

  // 3. Remember feet position before vertical move (for semi-solid landing check)
  const feetBeforeMove = entity.y + entity.height;

  // 4. Move vertically only
  entity.y += entity.vy * dt;

  // 5. Resolve vertical collisions
  entity.onGround = false;
  for (const solid of solids) {
    if (!aabbOverlap(entity, solid)) continue;

    // Semi-solid platforms: only land on top when falling, and only if
    // the entity's feet were at or above the platform top before the move
    if (solid.semiSolid) {
      if (entity.vy >= 0 && feetBeforeMove <= solid.y + 2) {
        entity.y = solid.y - entity.height;
        entity.vy = 0;
        entity.onGround = true;
      }
      // Otherwise pass right through (jumping up or overlapping from sides)
      continue;
    }

    if (entity.vy >= 0) {
      // Falling or stationary — land on top
      entity.y = solid.y - entity.height;
      entity.vy = 0;
      entity.onGround = true;
    } else {
      // Moving up — hit bottom of block
      entity.y = solid.y + solid.height;
      entity.vy = 0;
      if (solid.onHitFromBelow) {
        solid.onHitFromBelow();
      }
    }
  }
}

// For enemies: they move themselves, then we resolve overlaps
function resolveEntityCollisions(entity, solids) {
  // Horizontal resolution (skip semi-solid platforms)
  for (const solid of solids) {
    if (solid.semiSolid) continue;
    if (!aabbOverlap(entity, solid)) continue;
    const overlap = getOverlap(entity, solid);
    if (!overlap) continue;
    if (overlap.x < overlap.y) {
      // Horizontal collision is smaller — resolve horizontally
      const moverCenter = entity.x + entity.width / 2;
      const solidCenter = solid.x + solid.width / 2;
      if (moverCenter < solidCenter) {
        entity.x = solid.x - entity.width;
      } else {
        entity.x = solid.x + solid.width;
      }
      entity.vx = -entity.vx; // Enemies reverse direction on wall
    }
  }

  // Vertical resolution
  entity.onGround = false;
  for (const solid of solids) {
    if (!aabbOverlap(entity, solid)) continue;
    const overlap = getOverlap(entity, solid);
    if (!overlap) continue;

    // Semi-solid: enemies can only land on top, not get pushed from below
    if (solid.semiSolid) {
      const moverCenter = entity.y + entity.height / 2;
      if (moverCenter < solid.y && entity.vy >= 0) {
        entity.y = solid.y - entity.height;
        entity.vy = 0;
        entity.onGround = true;
      }
      continue;
    }

    if (overlap.y <= overlap.x) {
      const moverCenter = entity.y + entity.height / 2;
      const solidCenter = solid.y + solid.height / 2;
      if (moverCenter < solidCenter) {
        entity.y = solid.y - entity.height;
        if (entity.vy > 0) entity.vy = 0;
        entity.onGround = true;
      } else {
        entity.y = solid.y + solid.height;
        if (entity.vy < 0) entity.vy = 0;
      }
    }
  }
}
  </script>
  <script>
class Particle {
  constructor() {
    this.active = false;
  }

  init(x, y, vx, vy, color, life, size) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.color = color;
    this.life = life;
    this.maxLife = life;
    this.size = size;
    this.active = true;
  }

  update(dt) {
    if (!this.active) return;
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    this.vy += 400 * dt;
    this.life -= dt;
    if (this.life <= 0) this.active = false;
  }

  render(ctx, camera) {
    if (!this.active) return;
    const alpha = this.life / this.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = this.color;
    const sx = this.x - camera.x;
    const sy = this.y - camera.y;
    ctx.fillRect(sx - this.size / 2, sy - this.size / 2, this.size, this.size);
    ctx.globalAlpha = 1;
  }
}

class ParticleSystem {
  constructor(poolSize) {
    poolSize = poolSize || 300;
    this.particles = [];
    for (let i = 0; i < poolSize; i++) {
      this.particles.push(new Particle());
    }
  }

  emit(x, y, count, config) {
    let emitted = 0;
    for (const p of this.particles) {
      if (!p.active && emitted < count) {
        const angle = Math.random() * Math.PI * 2;
        const speed = config.speed * (0.5 + Math.random() * 0.5);
        const upBias = config.upwardBias || 0;
        p.init(
          x + (Math.random() - 0.5) * 10,
          y + (Math.random() - 0.5) * 10,
          Math.cos(angle) * speed,
          Math.sin(angle) * speed - upBias,
          config.colors[Math.floor(Math.random() * config.colors.length)],
          config.life * (0.7 + Math.random() * 0.3),
          config.size * (0.5 + Math.random() * 0.5)
        );
        emitted++;
      }
    }
  }

  bearDeath(x, y) {
    this.emit(x, y, 18, {
      speed: 220,
      upwardBias: 180,
      colors: [CONFIG.COLORS.PARTICLE_RED, '#FF6633', '#CC0000', CONFIG.COLORS.PARTICLE_BEAR],
      life: 0.7,
      size: 8
    });
  }

  bullCollect(x, y) {
    this.emit(x, y, 10, {
      speed: 140,
      upwardBias: 120,
      colors: [CONFIG.COLORS.BULL_GOLD, '#FFF', '#FFE4B5', '#FFAA00'],
      life: 0.5,
      size: 5
    });
  }

  powerUp(x, y, color) {
    this.emit(x, y, 20, {
      speed: 180,
      upwardBias: 150,
      colors: [color, '#FFF', '#FFE4B5'],
      life: 0.8,
      size: 6
    });
  }

  update(dt) {
    for (const p of this.particles) {
      if (p.active) p.update(dt);
    }
  }

  render(ctx, camera) {
    for (const p of this.particles) {
      if (p.active) p.render(ctx, camera);
    }
  }
}

class FloatingText {
  constructor() {
    this.texts = [];
  }

  spawn(x, y, text, color, size, duration) {
    size = size || 20;
    duration = duration || 1.0;
    this.texts.push({
      x: x, y: y, text: text, color: color,
      size: size, duration: duration, maxDuration: duration,
      vy: -80, scale: 1.5
    });
  }

  update(dt) {
    for (const t of this.texts) {
      t.y += t.vy * dt;
      t.duration -= dt;
      t.scale = Math.max(1.0, t.scale - dt * 2);
    }
    this.texts = this.texts.filter(t => t.duration > 0);
  }

  render(ctx, camera) {
    for (const t of this.texts) {
      const alpha = Math.min(1, t.duration / (t.maxDuration * 0.3));
      ctx.globalAlpha = alpha;
      ctx.fillStyle = t.color;
      ctx.font = 'bold ' + Math.round(t.size * t.scale) + 'px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillText(t.text, t.x - camera.x + 2, t.y - camera.y + 2);

      ctx.fillStyle = t.color;
      ctx.fillText(t.text, t.x - camera.x, t.y - camera.y);
    }
    ctx.globalAlpha = 1;
  }
}
  </script>
  <script>
class Platform {
  constructor(x, y, width, height, type) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.type = type; // 'desk', 'ledge', 'taxi', 'ground'
    this.semiSolid = (type === 'desk'); // Desk platforms can be jumped through from below
  }

  render(ctx, camera) {
    const sx = this.x - camera.x;
    const sy = this.y - camera.y;

    // Skip if off screen
    if (sx + this.width < -50 || sx > CONFIG.VIRTUAL_WIDTH + 50) return;
    if (sy + this.height < -50 || sy > CONFIG.VIRTUAL_HEIGHT + 50) return;

    switch (this.type) {
      case 'desk':
        // Wooden desk surface
        ctx.fillStyle = CONFIG.COLORS.PLATFORM_DESK_TOP;
        ctx.fillRect(sx, sy, this.width, 6);
        ctx.fillStyle = CONFIG.COLORS.PLATFORM_DESK;
        ctx.fillRect(sx, sy + 6, this.width, this.height - 6);
        // Desk legs
        ctx.fillStyle = '#6B4914';
        ctx.fillRect(sx + 4, sy + this.height, 6, 14);
        ctx.fillRect(sx + this.width - 10, sy + this.height, 6, 14);
        break;

      case 'ledge':
        // Building ledge
        ctx.fillStyle = CONFIG.COLORS.PLATFORM_LEDGE;
        ctx.fillRect(sx, sy, this.width, this.height);
        // Ledge lip at top
        ctx.fillStyle = '#6a6a8a';
        ctx.fillRect(sx - 2, sy, this.width + 4, 4);
        break;

      case 'taxi':
        // Yellow taxi cab roof
        ctx.fillStyle = CONFIG.COLORS.PLATFORM_TAXI;
        ctx.fillRect(sx, sy, this.width, this.height);
        ctx.fillStyle = CONFIG.COLORS.PLATFORM_TAXI_DARK;
        ctx.fillRect(sx, sy + this.height - 4, this.width, 4);
        // Taxi light
        ctx.fillStyle = '#FFF';
        ctx.fillRect(sx + this.width / 2 - 8, sy - 8, 16, 8);
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(sx + this.width / 2 - 6, sy - 6, 12, 4);
        break;

      case 'ground':
        // Sidewalk/ground
        ctx.fillStyle = CONFIG.COLORS.GROUND_TOP;
        ctx.fillRect(sx, sy, this.width, 4);
        ctx.fillStyle = CONFIG.COLORS.GROUND;
        ctx.fillRect(sx, sy + 4, this.width, this.height - 4);
        // Sidewalk cracks
        ctx.strokeStyle = '#3d3d5e';
        ctx.lineWidth = 1;
        for (let i = CONFIG.TILE_SIZE; i < this.width; i += CONFIG.TILE_SIZE) {
          ctx.beginPath();
          ctx.moveTo(sx + i, sy);
          ctx.lineTo(sx + i, sy + this.height);
          ctx.stroke();
        }
        break;

      case 'terminal':
        // Trading terminal desk
        ctx.fillStyle = '#4a3a2a';
        ctx.fillRect(sx, sy, this.width, this.height);
        ctx.fillStyle = '#5a4a3a';
        ctx.fillRect(sx, sy, this.width, 5);
        // Screen
        ctx.fillStyle = '#0a2a0a';
        ctx.fillRect(sx + 6, sy - 20, this.width - 12, 18);
        ctx.fillStyle = '#00FF88';
        ctx.font = '8px monospace';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText('$$$', sx + 10, sy - 12);
        break;

      case 'column':
        // Stone column top
        ctx.fillStyle = '#8a8a9a';
        ctx.fillRect(sx, sy, this.width, this.height);
        ctx.fillStyle = '#9a9aaa';
        ctx.fillRect(sx - 4, sy, this.width + 8, 5);
        ctx.fillStyle = '#7a7a8a';
        ctx.fillRect(sx + 4, sy + this.height, this.width - 8, 40);
        break;

      case 'server':
        // Server rack top
        ctx.fillStyle = '#1a1a2a';
        ctx.fillRect(sx, sy, this.width, this.height);
        ctx.fillStyle = '#2a2a3a';
        ctx.fillRect(sx, sy, this.width, 4);
        // LED lights
        for (let i = 0; i < this.width - 10; i += 12) {
          // Use deterministic pattern based on position instead of random
          ctx.fillStyle = ((Math.floor(this.x + i) * 7) % 13 > 4) ? '#00FFCC' : '#FF00FF';
          ctx.fillRect(sx + 6 + i, sy + 7, 3, 3);
        }
        break;

      case 'crystal':
        // Glowing crystal platform
        ctx.fillStyle = '#6a00cc';
        ctx.fillRect(sx, sy, this.width, this.height);
        ctx.fillStyle = '#8a20ee';
        ctx.fillRect(sx, sy, this.width, 4);
        // Glow
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#cc44ff';
        ctx.fillRect(sx - 2, sy - 2, this.width + 4, this.height + 4);
        ctx.globalAlpha = 1;
        break;
    }
  }
}

class MovingPlatform {
  constructor(x, y, width, height, type, waypoints, speed) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.type = type || 'ledge';
    this.semiSolid = (this.type === 'desk'); // Match Platform behavior — desk can be jumped through from below
    this.waypoints = waypoints; // [{x, y}, {x, y}] — absolute positions
    this.speed = speed || 60;
    this.currentWP = 0;
    this.vx = 0;
    this.vy = 0;
    this._platform = new Platform(x, y, width, height, type);
  }

  update(dt) {
    const target = this.waypoints[this.currentWP];
    const dx = target.x - this.x;
    const dy = target.y - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < 2) {
      // Reached waypoint, move to next
      this.x = target.x;
      this.y = target.y;
      this.currentWP = (this.currentWP + 1) % this.waypoints.length;
      this.vx = 0;
      this.vy = 0;
    } else {
      this.vx = (dx / dist) * this.speed;
      this.vy = (dy / dist) * this.speed;
      this.x += this.vx * dt;
      this.y += this.vy * dt;
    }

    this._platform.x = this.x;
    this._platform.y = this.y;
  }

  render(ctx, camera) {
    this._platform.render(ctx, camera);
  }
}

class QuestionBlock {
  constructor(x, y, contents) {
    this.x = x;
    this.y = y;
    this.width = CONFIG.BLOCK_SIZE;
    this.height = CONFIG.BLOCK_SIZE;
    this.contents = contents; // 'bull', 'greenCandle', 'chargingBull'
    this.used = false;
    this.bumpOffset = 0;
    this.bumpTimer = 0;
    this.animTime = Math.random() * Math.PI * 2;
    this._hitCallback = null;
  }

  setHitCallback(cb) {
    this._hitCallback = cb;
  }

  onHitFromBelow() {
    if (this.used) return;
    this.used = true;
    this.bumpTimer = CONFIG.BLOCK_BUMP_DURATION;
    if (this._hitCallback) {
      this._hitCallback(this.contents, this.x + this.width / 2 - 15, this.y - 36);
    }
  }

  update(dt) {
    this.animTime += dt;
    if (this.bumpTimer > 0) {
      this.bumpTimer -= dt;
      const t = 1 - (this.bumpTimer / CONFIG.BLOCK_BUMP_DURATION);
      this.bumpOffset = -CONFIG.BLOCK_BUMP_HEIGHT * Math.sin(t * Math.PI);
    } else {
      this.bumpOffset = 0;
    }
  }

  render(ctx, camera) {
    const sx = this.x - camera.x;
    const sy = this.y - camera.y + this.bumpOffset;
    const s = CONFIG.BLOCK_SIZE;

    if (sx + s < -10 || sx > CONFIG.VIRTUAL_WIDTH + 10) return;

    if (this.used) {
      ctx.fillStyle = CONFIG.COLORS.QUESTION_BLOCK_USED;
      ctx.fillRect(sx, sy, s, s);
      ctx.strokeStyle = '#6B5B3A';
      ctx.lineWidth = 2;
      ctx.strokeRect(sx + 2, sy + 2, s - 4, s - 4);
    } else {
      // Golden block
      ctx.fillStyle = CONFIG.COLORS.QUESTION_BLOCK;
      ctx.fillRect(sx, sy, s, s);

      // Border
      ctx.strokeStyle = CONFIG.COLORS.QUESTION_BLOCK_BORDER;
      ctx.lineWidth = 3;
      ctx.strokeRect(sx + 3, sy + 3, s - 6, s - 6);

      // Inner border highlight
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.lineWidth = 1;
      ctx.strokeRect(sx + 6, sy + 6, s - 12, s - 12);

      // Question mark
      ctx.fillStyle = CONFIG.COLORS.QUESTION_BLOCK_BORDER;
      ctx.font = 'bold 26px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const qBounce = Math.sin(this.animTime * 4) * 2;
      ctx.fillText('?', sx + s / 2, sy + s / 2 + qBounce);

      // Shimmer highlight
      ctx.fillStyle = 'rgba(255,255,255,0.25)';
      ctx.fillRect(sx + 5, sy + 5, s * 0.35, s * 0.25);
    }
  }
}

class ShortSqueezePad {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.width = 48;
    this.height = 16;
    this.animTime = 0;
    this.cooldown = 0;
    this.activated = false;
    this.activateTimer = 0;
  }

  update(dt) {
    this.animTime += dt;
    if (this.cooldown > 0) this.cooldown -= dt;
    if (this.activateTimer > 0) {
      this.activateTimer -= dt;
      if (this.activateTimer <= 0) this.activated = false;
    }
  }

  tryLaunch(player) {
    if (this.cooldown > 0) return false;
    if (player.onGround &&
        player.x + player.width > this.x &&
        player.x < this.x + this.width &&
        Math.abs((player.y + player.height) - this.y) < 8) {
      player.vy = CONFIG.PLAYER_SUPER_JUMP_VELOCITY * 1.3;
      player.onGround = false;
      this.cooldown = 0.5;
      this.activated = true;
      this.activateTimer = 0.4;
      return true;
    }
    return false;
  }

  render(ctx, camera) {
    const sx = this.x - camera.x;
    const sy = this.y - camera.y;
    if (sx + this.width < -10 || sx > CONFIG.VIRTUAL_WIDTH + 10) return;

    const w = this.width;
    const h = this.height;

    // Pad base
    const glow = this.activated ? 1 : 0.6 + Math.sin(this.animTime * 4) * 0.2;
    ctx.globalAlpha = glow;
    ctx.fillStyle = '#00CC66';
    ctx.fillRect(sx, sy, w, h);

    // Border
    ctx.strokeStyle = '#009944';
    ctx.lineWidth = 2;
    ctx.strokeRect(sx + 1, sy + 1, w - 2, h - 2);

    // Up arrow
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath();
    ctx.moveTo(sx + w / 2, sy + 2);
    ctx.lineTo(sx + w / 2 + 8, sy + h - 2);
    ctx.lineTo(sx + w / 2 - 8, sy + h - 2);
    ctx.closePath();
    ctx.fill();
    ctx.globalAlpha = 1;

    // Activation burst
    if (this.activated) {
      ctx.globalAlpha = this.activateTimer;
      ctx.fillStyle = '#00FF88';
      for (let i = 0; i < 3; i++) {
        const by = sy - 10 - i * 12 - (0.4 - this.activateTimer) * 60;
        ctx.fillRect(sx + w / 2 - 2 + (i - 1) * 8, by, 4, 8);
      }
      ctx.globalAlpha = 1;
    }
  }
}
  </script>
  <script>
class GoldBull {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.baseY = y;
    this.width = CONFIG.BULL_WIDTH;
    this.height = CONFIG.BULL_HEIGHT;
    this.collected = false;
    this.animTime = Math.random() * Math.PI * 2;
    this.type = 'bull';
    this.fromBlock = false;
    this.vy = 0;
    this.settled = false;
  }

  update(dt, solids) {
    if (this.collected) return;
    if (this.fromBlock && !this.settled) {
      this.vy += CONFIG.GRAVITY * dt;
      if (this.vy > CONFIG.MAX_FALL_SPEED) this.vy = CONFIG.MAX_FALL_SPEED;
      this.y += this.vy * dt;
      // Check landing on any solid (platforms + ground)
      if (solids && this.vy > 0) {
        for (const solid of solids) {
          if (aabbOverlap(this, solid)) {
            this.y = solid.y - this.height;
            this.vy = 0;
            this.settled = true;
            this.baseY = this.y;
            break;
          }
        }
      }
      // Fallback ground check
      if (!this.settled && this.y >= 432 - this.height) {
        this.y = 432 - this.height;
        this.vy = 0;
        this.settled = true;
        this.baseY = this.y;
      }
      return;
    }
    this.animTime += dt;
    this.y = this.baseY + Math.sin(this.animTime * CONFIG.BULL_BOB_SPEED) * CONFIG.BULL_BOB_AMPLITUDE;
  }

  render(ctx, camera) {
    if (this.collected) return;
    const sx = this.x - camera.x;
    const sy = this.y - camera.y;
    if (sx + this.width < -10 || sx > CONFIG.VIRTUAL_WIDTH + 10) return;

    const w = this.width;
    const h = this.height;

    // Glow effect
    ctx.globalAlpha = 0.2 + Math.sin(this.animTime * 5) * 0.1;
    ctx.fillStyle = CONFIG.COLORS.BULL_GOLD;
    ctx.beginPath();
    ctx.arc(sx + w / 2, sy + h / 2, w * 0.6, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Body
    ctx.fillStyle = CONFIG.COLORS.BULL_BODY;
    ctx.beginPath();
    ctx.ellipse(sx + w * 0.4, sy + h * 0.55, w * 0.35, h * 0.3, 0, 0, Math.PI * 2);
    ctx.fill();

    // Head
    ctx.fillStyle = CONFIG.COLORS.BULL_DARK;
    ctx.beginPath();
    ctx.ellipse(sx + w * 0.75, sy + h * 0.45, w * 0.18, h * 0.22, 0, 0, Math.PI * 2);
    ctx.fill();

    // Horns
    ctx.fillStyle = CONFIG.COLORS.BULL_GOLD;
    ctx.beginPath();
    ctx.moveTo(sx + w * 0.68, sy + h * 0.3);
    ctx.lineTo(sx + w * 0.58, sy + h * 0.05);
    ctx.lineTo(sx + w * 0.72, sy + h * 0.25);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(sx + w * 0.82, sy + h * 0.3);
    ctx.lineTo(sx + w * 0.92, sy + h * 0.05);
    ctx.lineTo(sx + w * 0.85, sy + h * 0.25);
    ctx.fill();

    // Legs
    ctx.fillStyle = CONFIG.COLORS.BULL_DARK;
    ctx.fillRect(sx + w * 0.15, sy + h * 0.78, w * 0.1, h * 0.22);
    ctx.fillRect(sx + w * 0.3, sy + h * 0.78, w * 0.1, h * 0.22);
    ctx.fillRect(sx + w * 0.5, sy + h * 0.78, w * 0.1, h * 0.22);
    ctx.fillRect(sx + w * 0.65, sy + h * 0.78, w * 0.1, h * 0.22);

    // Eye
    ctx.fillStyle = CONFIG.COLORS.WHITE;
    ctx.fillRect(sx + w * 0.78, sy + h * 0.38, 3, 3);

    // Tail
    ctx.strokeStyle = CONFIG.COLORS.BULL_DARK;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(sx + w * 0.08, sy + h * 0.5);
    ctx.quadraticCurveTo(sx - 4, sy + h * 0.3, sx + w * 0.05, sy + h * 0.2);
    ctx.stroke();
  }
}

class GreenCandle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.baseY = y;
    this.width = 24;
    this.height = 40;
    this.collected = false;
    this.animTime = Math.random() * Math.PI * 2;
    this.type = 'greenCandle';
    this.fromBlock = false;
    this.vy = 0;
    this.settled = false;
  }

  update(dt, solids) {
    if (this.collected) return;
    if (this.fromBlock && !this.settled) {
      this.vy += CONFIG.GRAVITY * dt;
      if (this.vy > CONFIG.MAX_FALL_SPEED) this.vy = CONFIG.MAX_FALL_SPEED;
      this.y += this.vy * dt;
      if (solids && this.vy > 0) {
        for (const solid of solids) {
          if (aabbOverlap(this, solid)) {
            this.y = solid.y - this.height;
            this.vy = 0;
            this.settled = true;
            this.baseY = this.y;
            break;
          }
        }
      }
      if (!this.settled && this.y >= 432 - this.height) {
        this.y = 432 - this.height;
        this.vy = 0;
        this.settled = true;
        this.baseY = this.y;
      }
      return;
    }
    this.animTime += dt;
    this.y = this.baseY + Math.sin(this.animTime * 2.5) * 4;
  }

  render(ctx, camera) {
    if (this.collected) return;
    const sx = this.x - camera.x;
    const sy = this.y - camera.y;
    if (sx + this.width < -10 || sx > CONFIG.VIRTUAL_WIDTH + 10) return;

    // Glow
    ctx.globalAlpha = 0.2;
    ctx.fillStyle = CONFIG.COLORS.GREEN_CANDLE;
    ctx.beginPath();
    ctx.arc(sx + 12, sy + 20, 20, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Candle body (stock chart candle shape)
    ctx.fillStyle = CONFIG.COLORS.GREEN_CANDLE;
    ctx.fillRect(sx + 4, sy + 10, 16, 24);

    // Upper wick
    ctx.fillStyle = CONFIG.COLORS.GREEN_CANDLE_DARK;
    ctx.fillRect(sx + 10, sy + 2, 4, 10);

    // Lower wick
    ctx.fillRect(sx + 10, sy + 32, 4, 6);

    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillRect(sx + 6, sy + 12, 4, 18);

    // Up arrow indicator
    ctx.fillStyle = CONFIG.COLORS.GREEN_CANDLE;
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'center';
    const bounce = Math.sin(this.animTime * 4) * 3;
    ctx.fillText('\u25B2', sx + 12, sy - 2 + bounce);
  }
}

class HodlItem {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.baseY = y;
    this.width = 28;
    this.height = 24;
    this.collected = false;
    this.animTime = Math.random() * Math.PI * 2;
    this.type = 'hodlItem';
    this.fromBlock = false;
    this.vy = 0;
    this.settled = false;
  }

  update(dt, solids) {
    if (this.collected) return;
    if (this.fromBlock && !this.settled) {
      this.vy += CONFIG.GRAVITY * dt;
      if (this.vy > CONFIG.MAX_FALL_SPEED) this.vy = CONFIG.MAX_FALL_SPEED;
      this.y += this.vy * dt;
      if (solids && this.vy > 0) {
        for (const solid of solids) {
          if (aabbOverlap(this, solid)) {
            this.y = solid.y - this.height;
            this.vy = 0;
            this.settled = true;
            this.baseY = this.y;
            break;
          }
        }
      }
      if (!this.settled && this.y >= 432 - this.height) {
        this.y = 432 - this.height;
        this.vy = 0;
        this.settled = true;
        this.baseY = this.y;
      }
      return;
    }
    this.animTime += dt;
    this.y = this.baseY + Math.sin(this.animTime * 3) * 4;
  }

  render(ctx, camera) {
    if (this.collected) return;
    const sx = this.x - camera.x;
    const sy = this.y - camera.y;
    if (sx + this.width < -10 || sx > CONFIG.VIRTUAL_WIDTH + 10) return;

    const w = this.width;
    const h = this.height;

    // Glow effect
    ctx.globalAlpha = 0.25 + Math.sin(this.animTime * 4) * 0.1;
    ctx.fillStyle = '#FF4444';
    ctx.beginPath();
    ctx.arc(sx + w / 2, sy + h / 2, w * 0.7, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Red headband base
    ctx.fillStyle = '#CC0000';
    ctx.fillRect(sx + 2, sy + h * 0.35, w - 4, h * 0.3);

    // Headband highlight
    ctx.fillStyle = '#FF3333';
    ctx.fillRect(sx + 2, sy + h * 0.35, w - 4, h * 0.12);

    // HODL text on headband
    ctx.fillStyle = '#FFFFFF';
    ctx.font = 'bold 8px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('HODL', sx + w / 2, sy + h * 0.5);

    // Cat ears (RoaringKitty reference)
    ctx.fillStyle = '#CC0000';
    // Left ear
    ctx.beginPath();
    ctx.moveTo(sx + 3, sy + h * 0.38);
    ctx.lineTo(sx + 1, sy + 2);
    ctx.lineTo(sx + 9, sy + h * 0.38);
    ctx.fill();
    // Right ear
    ctx.beginPath();
    ctx.moveTo(sx + w - 3, sy + h * 0.38);
    ctx.lineTo(sx + w - 1, sy + 2);
    ctx.lineTo(sx + w - 9, sy + h * 0.38);
    ctx.fill();

    // Inner ears
    ctx.fillStyle = '#FF8888';
    ctx.beginPath();
    ctx.moveTo(sx + 4, sy + h * 0.38);
    ctx.lineTo(sx + 3, sy + 6);
    ctx.lineTo(sx + 8, sy + h * 0.38);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(sx + w - 4, sy + h * 0.38);
    ctx.lineTo(sx + w - 3, sy + 6);
    ctx.lineTo(sx + w - 8, sy + h * 0.38);
    ctx.fill();

    // Trailing ribbon ends
    ctx.strokeStyle = '#CC0000';
    ctx.lineWidth = 2;
    const wave = Math.sin(this.animTime * 5) * 3;
    ctx.beginPath();
    ctx.moveTo(sx + 2, sy + h * 0.55);
    ctx.quadraticCurveTo(sx - 4, sy + h * 0.7 + wave, sx - 2, sy + h * 0.9);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(sx + 4, sy + h * 0.55);
    ctx.quadraticCurveTo(sx - 2, sy + h * 0.8 - wave, sx, sy + h);
    ctx.stroke();
  }
}

class DividendCoin {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.baseY = y;
    this.width = 24;
    this.height = 24;
    this.collected = false;
    this.animTime = Math.random() * Math.PI * 2;
    this.type = 'dividend';
  }

  update(dt) {
    if (this.collected) return;
    this.animTime += dt;
    this.y = this.baseY + Math.sin(this.animTime * 2.5) * 5;
  }

  render(ctx, camera) {
    if (this.collected) return;
    const sx = this.x - camera.x;
    const sy = this.y - camera.y;
    if (sx + this.width < -10 || sx > CONFIG.VIRTUAL_WIDTH + 10) return;

    const w = this.width;
    const h = this.height;
    const cx = sx + w / 2;
    const cy = sy + h / 2;

    // Bright glow
    ctx.globalAlpha = 0.3 + Math.sin(this.animTime * 6) * 0.15;
    ctx.fillStyle = '#00FF88';
    ctx.beginPath();
    ctx.arc(cx, cy, w * 0.8, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Coin body
    ctx.fillStyle = '#00CC66';
    ctx.beginPath();
    ctx.arc(cx, cy, w * 0.45, 0, Math.PI * 2);
    ctx.fill();

    // Coin border
    ctx.strokeStyle = '#009944';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, w * 0.45, 0, Math.PI * 2);
    ctx.stroke();

    // Dollar sign
    ctx.fillStyle = '#FFFFFF';
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('$', cx, cy + 1);

    // Sparkle
    ctx.fillStyle = '#FFFFFF';
    const sparkle = Math.sin(this.animTime * 8) * 0.5 + 0.5;
    ctx.globalAlpha = sparkle;
    ctx.fillRect(cx + 6, cy - 8, 3, 3);
    ctx.fillRect(cx - 9, cy + 5, 2, 2);
    ctx.globalAlpha = 1;
  }
}

class RedCandle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.baseY = y;
    this.width = 20;
    this.height = 36;
    this.collected = false;
    this.animTime = 0;
    this.type = 'redCandle';
    this.vy = 120; // Falls downward
  }

  update(dt) {
    if (this.collected) return;
    this.animTime += dt;
    this.y += this.vy * dt;
    // Remove if fallen well below ground level (ground at y=432)
    if (this.y > 600) {
      this.collected = true;
    }
  }

  render(ctx, camera) {
    if (this.collected) return;
    const sx = this.x - camera.x;
    const sy = this.y - camera.y;
    if (sx + this.width < -10 || sx > CONFIG.VIRTUAL_WIDTH + 10) return;
    if (sy > CONFIG.VIRTUAL_HEIGHT + 10 || sy + this.height < -50) return;

    // Warning glow
    ctx.globalAlpha = 0.2;
    ctx.fillStyle = '#FF0000';
    ctx.beginPath();
    ctx.arc(sx + 10, sy + 18, 18, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Candle body (red — bearish candle)
    ctx.fillStyle = '#CC0000';
    ctx.fillRect(sx + 3, sy + 8, 14, 22);

    // Upper wick
    ctx.fillStyle = '#990000';
    ctx.fillRect(sx + 8, sy, 4, 10);

    // Lower wick
    ctx.fillRect(sx + 8, sy + 28, 4, 8);

    // Highlight
    ctx.fillStyle = 'rgba(255,100,100,0.3)';
    ctx.fillRect(sx + 5, sy + 10, 4, 16);

    // Down arrow
    ctx.fillStyle = '#FF4444';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('\u25BC', sx + 10, sy + this.height + 10);
  }
}

class RunningDiamond {
  constructor(x, y, direction) {
    this.x = x;
    this.y = y;
    this.width = 22;
    this.height = 22;
    this.collected = false;
    this.animTime = 0;
    this.type = 'runningDiamond';
    this.vx = direction * 160;
    this.vy = -320;
    this.lifetime = 10;
    this.fromBlock = false;
    this.settled = false;
  }

  update(dt, solids) {
    if (this.collected) return;
    this.animTime += dt;
    this.lifetime -= dt;
    if (this.lifetime <= 0) {
      this.collected = true;
      return;
    }

    this.vy += CONFIG.GRAVITY * dt;
    if (this.vy > CONFIG.MAX_FALL_SPEED) this.vy = CONFIG.MAX_FALL_SPEED;

    this.x += this.vx * dt;
    this.y += this.vy * dt;

    // Bounce off ground
    if (this.y >= 432 - this.height) {
      this.y = 432 - this.height;
      this.vy = -380;
    }

    // Bounce off solids
    if (solids && this.vy > 0) {
      for (const solid of solids) {
        if (aabbOverlap(this, solid) && !solid.semiSolid) {
          this.y = solid.y - this.height;
          this.vy = -380;
          break;
        }
      }
    }
  }

  render(ctx, camera) {
    if (this.collected) return;
    const sx = this.x - camera.x;
    const sy = this.y - camera.y;
    if (sx + this.width < -50 || sx > CONFIG.VIRTUAL_WIDTH + 50) return;

    const cx = sx + this.width / 2;
    const cy = sy + this.height / 2;
    const s = this.width * 0.5;

    // Bright glow
    ctx.globalAlpha = 0.35 + Math.sin(this.animTime * 8) * 0.15;
    ctx.fillStyle = '#88DDFF';
    ctx.beginPath();
    ctx.arc(cx, cy, s * 1.6, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Diamond shape
    ctx.fillStyle = '#AAEEFF';
    ctx.beginPath();
    ctx.moveTo(cx, cy - s);
    ctx.lineTo(cx + s, cy);
    ctx.lineTo(cx, cy + s);
    ctx.lineTo(cx - s, cy);
    ctx.closePath();
    ctx.fill();

    // Top facet highlight
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.beginPath();
    ctx.moveTo(cx, cy - s);
    ctx.lineTo(cx + s * 0.3, cy - s * 0.3);
    ctx.lineTo(cx, cy);
    ctx.lineTo(cx - s * 0.3, cy - s * 0.3);
    ctx.closePath();
    ctx.fill();

    // Sparkle particles orbiting
    ctx.fillStyle = '#FFFFFF';
    for (let i = 0; i < 4; i++) {
      const angle = this.animTime * 5 + i * (Math.PI / 2);
      const dist = s * 1.3;
      const px = cx + Math.cos(angle) * dist;
      const py = cy + Math.sin(angle) * dist;
      ctx.globalAlpha = 0.5 + Math.sin(this.animTime * 10 + i) * 0.5;
      ctx.fillRect(px - 1.5, py - 1.5, 3, 3);
    }
    ctx.globalAlpha = 1;
  }
}

class ChargingBull {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.baseY = y;
    this.width = 40;
    this.height = 34;
    this.collected = false;
    this.animTime = Math.random() * Math.PI * 2;
    this.type = 'chargingBull';
  }

  update(dt) {
    if (this.collected) return;
    this.animTime += dt;
    this.y = this.baseY + Math.sin(this.animTime * 3) * 5;
  }

  render(ctx, camera) {
    if (this.collected) return;
    const sx = this.x - camera.x;
    const sy = this.y - camera.y;
    if (sx + this.width < -10 || sx > CONFIG.VIRTUAL_WIDTH + 10) return;

    const w = this.width;
    const h = this.height;

    // Intense glow
    ctx.globalAlpha = 0.3 + Math.sin(this.animTime * 6) * 0.15;
    ctx.fillStyle = CONFIG.COLORS.CHARGING_BULL;
    ctx.beginPath();
    ctx.arc(sx + w / 2, sy + h / 2, w * 0.8, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Body (larger, more muscular bull)
    ctx.fillStyle = CONFIG.COLORS.BULL_GOLD;
    ctx.beginPath();
    ctx.ellipse(sx + w * 0.45, sy + h * 0.55, w * 0.38, h * 0.32, 0, 0, Math.PI * 2);
    ctx.fill();

    // Head
    ctx.fillStyle = CONFIG.COLORS.BULL_BODY;
    ctx.beginPath();
    ctx.ellipse(sx + w * 0.82, sy + h * 0.42, w * 0.18, h * 0.24, -0.2, 0, Math.PI * 2);
    ctx.fill();

    // Horns (bigger)
    ctx.fillStyle = CONFIG.COLORS.WHITE;
    ctx.beginPath();
    ctx.moveTo(sx + w * 0.75, sy + h * 0.25);
    ctx.lineTo(sx + w * 0.6, sy - h * 0.1);
    ctx.lineTo(sx + w * 0.78, sy + h * 0.2);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(sx + w * 0.88, sy + h * 0.25);
    ctx.lineTo(sx + w * 1.05, sy - h * 0.1);
    ctx.lineTo(sx + w * 0.92, sy + h * 0.2);
    ctx.fill();

    // Legs
    ctx.fillStyle = CONFIG.COLORS.BULL_BODY;
    ctx.fillRect(sx + w * 0.15, sy + h * 0.8, w * 0.1, h * 0.2);
    ctx.fillRect(sx + w * 0.32, sy + h * 0.8, w * 0.1, h * 0.2);
    ctx.fillRect(sx + w * 0.55, sy + h * 0.8, w * 0.1, h * 0.2);
    ctx.fillRect(sx + w * 0.72, sy + h * 0.8, w * 0.1, h * 0.2);

    // Motion lines
    ctx.strokeStyle = 'rgba(255,215,0,0.5)';
    ctx.lineWidth = 2;
    for (let i = 0; i < 3; i++) {
      const ly = sy + h * 0.3 + i * 8;
      const lx = sx - 10 - i * 5;
      ctx.beginPath();
      ctx.moveTo(lx, ly);
      ctx.lineTo(lx - 15, ly);
      ctx.stroke();
    }

    // Sparkle stars
    ctx.fillStyle = CONFIG.COLORS.WHITE;
    const sparkleAngle = this.animTime * 3;
    for (let i = 0; i < 3; i++) {
      const angle = sparkleAngle + i * (Math.PI * 2 / 3);
      const dist = w * 0.55;
      const px = sx + w / 2 + Math.cos(angle) * dist;
      const py = sy + h / 2 + Math.sin(angle) * dist * 0.6;
      ctx.globalAlpha = 0.6 + Math.sin(this.animTime * 8 + i) * 0.4;
      ctx.fillRect(px - 2, py - 2, 4, 4);
    }
    ctx.globalAlpha = 1;
  }
}
  </script>
  <script>
class BabyBear {
  constructor(x, y, patrolLeft, patrolRight) {
    this.x = x;
    this.y = y;
    this.width = CONFIG.BABY_BEAR_WIDTH;
    this.height = CONFIG.BABY_BEAR_HEIGHT;
    this.vx = CONFIG.BABY_BEAR_SPEED;
    this.vy = 0;
    this.patrolLeft = patrolLeft;
    this.patrolRight = patrolRight;
    this.alive = true;
    this.hp = 1;
    this.onGround = false;
    this.animTime = 0;
    this.deathTimer = 0;
    this.facingRight = true;
    this.crashSpeedMult = 1.0;
  }

  update(dt, solids) {
    if (!this.alive) {
      this.deathTimer += dt;
      return this.deathTimer < 0.4;
    }

    applyGravity(this, dt);

    this.x += this.vx * this.crashSpeedMult * dt;
    this.y += this.vy * dt;

    // Patrol boundaries
    if (this.x <= this.patrolLeft) {
      this.x = this.patrolLeft;
      this.vx = Math.abs(this.vx);
      this.facingRight = true;
    }
    if (this.x + this.width >= this.patrolRight) {
      this.x = this.patrolRight - this.width;
      this.vx = -Math.abs(this.vx);
      this.facingRight = false;
    }

    // Collision with solids
    resolveEntityCollisions(this, solids);

    this.animTime += dt;
    return true;
  }

  stomp() {
    this.hp--;
    if (this.hp <= 0) {
      this.alive = false;
      return true;
    }
    return false;
  }

  render(ctx, camera) {
    const sx = this.x - camera.x;
    const sy = this.y - camera.y;
    if (sx + this.width < -20 || sx > CONFIG.VIRTUAL_WIDTH + 20) return;

    const w = this.width;
    const h = this.height;

    ctx.save();

    if (!this.alive) {
      // Squish animation
      const squish = Math.max(0.1, 1 - (this.deathTimer / 0.3));
      ctx.translate(sx + w / 2, sy + h);
      ctx.scale(1.3, squish);
      ctx.translate(-w / 2, -h);
      this._drawBody(ctx, w, h);
      ctx.restore();
      return;
    }

    ctx.translate(sx, sy);

    // Flip if facing left
    if (!this.facingRight) {
      ctx.translate(w, 0);
      ctx.scale(-1, 1);
    }

    const legSwing = Math.sin(this.animTime * 8) * 5;
    this._drawBody(ctx, w, h, legSwing);
    ctx.restore();
  }

  _drawBody(ctx, w, h, legSwing) {
    legSwing = legSwing || 0;

    // Legs
    ctx.fillStyle = CONFIG.COLORS.BEAR_DARK;
    ctx.fillRect(w * 0.15, h * 0.72 + legSwing, w * 0.2, h * 0.28 - Math.max(0, legSwing));
    ctx.fillRect(w * 0.65, h * 0.72 - legSwing, w * 0.2, h * 0.28 + Math.max(0, legSwing));

    // Body
    ctx.fillStyle = CONFIG.COLORS.BEAR_BROWN;
    ctx.beginPath();
    ctx.ellipse(w / 2, h * 0.48, w * 0.44, h * 0.38, 0, 0, Math.PI * 2);
    ctx.fill();

    // Belly
    ctx.fillStyle = CONFIG.COLORS.BEAR_BELLY;
    ctx.beginPath();
    ctx.ellipse(w / 2, h * 0.52, w * 0.24, h * 0.22, 0, 0, Math.PI * 2);
    ctx.fill();

    // Ears
    ctx.fillStyle = CONFIG.COLORS.BEAR_BROWN;
    ctx.beginPath();
    ctx.arc(w * 0.22, h * 0.14, w * 0.13, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(w * 0.78, h * 0.14, w * 0.13, 0, Math.PI * 2);
    ctx.fill();

    // Inner ears
    ctx.fillStyle = CONFIG.COLORS.BEAR_BELLY;
    ctx.beginPath();
    ctx.arc(w * 0.22, h * 0.14, w * 0.07, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(w * 0.78, h * 0.14, w * 0.07, 0, Math.PI * 2);
    ctx.fill();

    // Eyes
    ctx.fillStyle = CONFIG.COLORS.BLACK;
    ctx.beginPath();
    ctx.arc(w * 0.35, h * 0.32, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(w * 0.65, h * 0.32, 3, 0, Math.PI * 2);
    ctx.fill();

    // Angry eyebrows
    ctx.strokeStyle = CONFIG.COLORS.BLACK;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(w * 0.22, h * 0.22);
    ctx.lineTo(w * 0.42, h * 0.28);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(w * 0.78, h * 0.22);
    ctx.lineTo(w * 0.58, h * 0.28);
    ctx.stroke();

    // Nose
    ctx.fillStyle = CONFIG.COLORS.BEAR_DARK;
    ctx.beginPath();
    ctx.ellipse(w * 0.5, h * 0.42, 4, 3, 0, 0, Math.PI * 2);
    ctx.fill();

    // Mouth (growl)
    ctx.strokeStyle = CONFIG.COLORS.BEAR_DARK;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(w * 0.5, h * 0.45, 5, 0.2, Math.PI - 0.2);
    ctx.stroke();
  }
}

class GrizzlyBear {
  constructor(x, y, patrolLeft, patrolRight) {
    this.x = x;
    this.y = y;
    this.width = CONFIG.GRIZZLY_WIDTH;
    this.height = CONFIG.GRIZZLY_HEIGHT;
    this.vx = CONFIG.GRIZZLY_SPEED;
    this.vy = 0;
    this.patrolLeft = patrolLeft;
    this.patrolRight = patrolRight;
    this.alive = true;
    this.hp = CONFIG.GRIZZLY_HP;
    this.onGround = false;
    this.charging = false;
    this.animTime = 0;
    this.deathTimer = 0;
    this.stompFlashTimer = 0;
    this.facingRight = true;
    this.stunned = false;
    this.stunnedTimer = 0;
    this.crashSpeedMult = 1.0;
  }

  update(dt, solids, playerX) {
    if (!this.alive) {
      this.deathTimer += dt;
      return this.deathTimer < 0.4;
    }

    // Stunned state: slower movement, no charging
    // Auto-recover from stun after 3 seconds (prevents permanent stun if combo target switches)
    if (this.stunned) {
      this.stunnedTimer += dt;
      if (this.stunnedTimer >= 3.0) {
        this.stunned = false;
        this.stunnedTimer = 0;
        // Don't recover HP - just unstun so player can try again
      }
    }

    // Charge detection (disabled when stunned)
    const dist = Math.abs(playerX - (this.x + this.width / 2));
    if (!this.stunned && dist < CONFIG.GRIZZLY_DETECT_RANGE) {
      this.charging = true;
      const dir = playerX > this.x + this.width / 2 ? 1 : -1;
      this.vx = CONFIG.GRIZZLY_CHARGE_SPEED * dir;
      this.facingRight = dir > 0;
    } else if (this.charging) {
      this.charging = false;
      this.vx = CONFIG.GRIZZLY_SPEED * (this.facingRight ? 1 : -1);
    }

    // Stunned grizzlies move at half speed
    const speedMult = this.stunned ? 0.4 : 1.0;

    applyGravity(this, dt);

    this.x += this.vx * speedMult * this.crashSpeedMult * dt;
    this.y += this.vy * dt;

    // Patrol boundaries
    if (this.x <= this.patrolLeft) {
      this.x = this.patrolLeft;
      this.vx = Math.abs(this.vx);
      this.facingRight = true;
    }
    if (this.x + this.width >= this.patrolRight) {
      this.x = this.patrolRight - this.width;
      this.vx = -Math.abs(this.vx);
      this.facingRight = false;
    }

    resolveEntityCollisions(this, solids);

    if (this.stompFlashTimer > 0) this.stompFlashTimer -= dt;
    this.animTime += dt;
    return true;
  }

  stomp() {
    this.hp--;
    if (this.hp <= 0) {
      this.alive = false;
      return true;
    }
    this.stompFlashTimer = 0.3;
    return false;
  }

  render(ctx, camera) {
    const sx = this.x - camera.x;
    const sy = this.y - camera.y;
    if (sx + this.width < -20 || sx > CONFIG.VIRTUAL_WIDTH + 20) return;

    const w = this.width;
    const h = this.height;

    ctx.save();

    if (!this.alive) {
      const squish = Math.max(0.1, 1 - (this.deathTimer / 0.3));
      ctx.translate(sx + w / 2, sy + h);
      ctx.scale(1.3, squish);
      ctx.translate(-w / 2, -h);
      this._drawBody(ctx, w, h);
      ctx.restore();
      return;
    }

    ctx.translate(sx, sy);

    if (!this.facingRight) {
      ctx.translate(w, 0);
      ctx.scale(-1, 1);
    }

    const legSwing = Math.sin(this.animTime * (this.charging ? 14 : 8)) * (this.charging ? 8 : 5);
    this._drawBody(ctx, w, h, legSwing);

    // Damage flash
    if (this.stompFlashTimer > 0) {
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = '#FF0000';
      ctx.fillRect(0, 0, w, h);
      ctx.globalAlpha = 1;
    }

    // Armor shield indicator — only when at full HP
    if (!this.charging && this.hp >= CONFIG.GRIZZLY_HP) {
      ctx.globalAlpha = 0.3 + Math.sin(this.animTime * 3) * 0.1;
      ctx.strokeStyle = '#88AACC';
      ctx.lineWidth = 2;
      // Shield diamond on chest
      ctx.beginPath();
      ctx.moveTo(w * 0.5, h * 0.3);
      ctx.lineTo(w * 0.65, h * 0.45);
      ctx.lineTo(w * 0.5, h * 0.6);
      ctx.lineTo(w * 0.35, h * 0.45);
      ctx.closePath();
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // Stunned indicator — circling stars when HP < max
    if (this.stunned) {
      ctx.globalAlpha = 0.8;
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'center';
      for (let s = 0; s < 3; s++) {
        const angle = this.stunnedTimer * 4 + s * (Math.PI * 2 / 3);
        const starX = w / 2 + Math.cos(angle) * 16;
        const starY = -6 + Math.sin(angle) * 6;
        ctx.fillStyle = '#FFD700';
        ctx.fillText('\u2605', starX, starY);
      }
      ctx.globalAlpha = 1;
    }

    // Charge indicator
    if (this.charging) {
      ctx.fillStyle = '#FF4444';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('!!!', w / 2, -8);
    }

    ctx.restore();
  }

  _drawBody(ctx, w, h, legSwing) {
    legSwing = legSwing || 0;

    // Arms (behind body)
    ctx.fillStyle = CONFIG.COLORS.BEAR_BROWN;
    ctx.save();
    ctx.translate(w * 0.85, h * 0.35);
    ctx.rotate(0.3 + (this.charging ? 0.4 : 0));
    ctx.fillRect(0, 0, w * 0.12, h * 0.3);
    ctx.restore();

    // Legs
    ctx.fillStyle = CONFIG.COLORS.BEAR_DARK;
    ctx.fillRect(w * 0.15, h * 0.7 + legSwing, w * 0.18, h * 0.3 - Math.max(0, legSwing));
    ctx.fillRect(w * 0.62, h * 0.7 - legSwing, w * 0.18, h * 0.3 + Math.max(0, legSwing));

    // Body (larger)
    ctx.fillStyle = CONFIG.COLORS.BEAR_BROWN;
    ctx.beginPath();
    ctx.ellipse(w / 2, h * 0.45, w * 0.46, h * 0.4, 0, 0, Math.PI * 2);
    ctx.fill();

    // Belly
    ctx.fillStyle = CONFIG.COLORS.BEAR_BELLY;
    ctx.beginPath();
    ctx.ellipse(w * 0.48, h * 0.5, w * 0.22, h * 0.25, 0, 0, Math.PI * 2);
    ctx.fill();

    // Head (slightly forward when charging)
    const headOffset = this.charging ? w * 0.06 : 0;
    ctx.fillStyle = CONFIG.COLORS.BEAR_BROWN;
    ctx.beginPath();
    ctx.ellipse(w * 0.5 + headOffset, h * 0.18, w * 0.28, h * 0.2, 0, 0, Math.PI * 2);
    ctx.fill();

    // Ears
    ctx.beginPath();
    ctx.arc(w * 0.28 + headOffset, h * 0.04, w * 0.1, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(w * 0.72 + headOffset, h * 0.04, w * 0.1, 0, Math.PI * 2);
    ctx.fill();

    // Inner ears
    ctx.fillStyle = CONFIG.COLORS.BEAR_BELLY;
    ctx.beginPath();
    ctx.arc(w * 0.28 + headOffset, h * 0.04, w * 0.05, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(w * 0.72 + headOffset, h * 0.04, w * 0.05, 0, Math.PI * 2);
    ctx.fill();

    // Eyes (angrier for grizzly, red when charging)
    ctx.fillStyle = this.charging ? '#FF0000' : CONFIG.COLORS.BLACK;
    ctx.beginPath();
    ctx.arc(w * 0.38 + headOffset, h * 0.15, 3.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(w * 0.62 + headOffset, h * 0.15, 3.5, 0, Math.PI * 2);
    ctx.fill();

    // Very angry eyebrows
    ctx.strokeStyle = CONFIG.COLORS.BLACK;
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(w * 0.24 + headOffset, h * 0.06);
    ctx.lineTo(w * 0.44 + headOffset, h * 0.12);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(w * 0.76 + headOffset, h * 0.06);
    ctx.lineTo(w * 0.56 + headOffset, h * 0.12);
    ctx.stroke();

    // Snout
    ctx.fillStyle = CONFIG.COLORS.BEAR_BELLY;
    ctx.beginPath();
    ctx.ellipse(w * 0.52 + headOffset, h * 0.24, w * 0.1, h * 0.06, 0, 0, Math.PI * 2);
    ctx.fill();

    // Nose
    ctx.fillStyle = CONFIG.COLORS.BLACK;
    ctx.beginPath();
    ctx.ellipse(w * 0.52 + headOffset, h * 0.22, 4, 3, 0, 0, Math.PI * 2);
    ctx.fill();

    // Open mouth when charging
    if (this.charging) {
      ctx.fillStyle = '#8B0000';
      ctx.beginPath();
      ctx.ellipse(w * 0.52 + headOffset, h * 0.29, 6, 4, 0, 0, Math.PI * 2);
      ctx.fill();
      // Teeth
      ctx.fillStyle = CONFIG.COLORS.WHITE;
      ctx.fillRect(w * 0.47 + headOffset, h * 0.27, 3, 3);
      ctx.fillRect(w * 0.54 + headOffset, h * 0.27, 3, 3);
    }

    // Scar (distinguishing mark for grizzly)
    ctx.strokeStyle = '#6B3310';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(w * 0.3 + headOffset, h * 0.1);
    ctx.lineTo(w * 0.38 + headOffset, h * 0.2);
    ctx.stroke();
  }
}

class WhaleBoss {
  constructor(x, y, arenaLeft, arenaRight) {
    this.x = x;
    this.y = y;
    this.width = 120;
    this.height = 90;
    this.alive = true;
    this.hp = 9;
    this.maxHp = 9;
    this.phase = 1; // 1, 2, 3
    this.arenaLeft = arenaLeft;
    this.arenaRight = arenaRight;
    this.vx = 150; // charge speed
    this.vy = 0;
    this.onGround = true;
    this.facingRight = false;
    this.animTime = 0;
    this.stompFlashTimer = 0;
    this.deathTimer = 0;
    this.crashSpeedMult = 1.0;
    this.stunned = false;
    this.stunTimer = 0;
    this.attackTimer = 0;
    this.jumpTimer = 0;
    this.projectileTimer = 0;
    this.shockwaves = []; // active shockwave objects
    this.projectiles = []; // red candle projectiles in phase 3
    this.activated = false; // only starts when player enters arena
  }

  update(dt, solids, playerX) {
    if (!this.alive) {
      this.deathTimer += dt;
      return this.deathTimer < 1.5;
    }

    this.animTime += dt;

    // Activate when player is near
    if (!this.activated) {
      if (Math.abs(playerX - this.x) < 400) {
        this.activated = true;
      } else {
        return true;
      }
    }

    // Stunned state
    if (this.stunned) {
      this.stunTimer -= dt;
      if (this.stunTimer <= 0) {
        this.stunned = false;
      }
      // Update shockwaves and projectiles even while stunned
      this._updateShockwaves(dt);
      this._updateProjectiles(dt);
      return true;
    }

    // Gravity
    this.vy += CONFIG.GRAVITY * dt;
    if (this.vy > CONFIG.MAX_FALL_SPEED) this.vy = CONFIG.MAX_FALL_SPEED;
    this.y += this.vy * dt;

    // Ground collision
    const groundY = 432;
    if (this.y + this.height >= groundY) {
      // Landing — spawn shockwave in phase 2+
      if (!this.onGround && this.phase >= 2) {
        this.shockwaves.push({
          x: this.x + this.width / 2,
          y: groundY,
          radius: 0,
          maxRadius: 80,
          speed: 200
        });
      }
      this.y = groundY - this.height;
      this.vy = 0;
      this.onGround = true;
    }

    // Charge movement
    const speed = this.vx * this.crashSpeedMult;
    if (this.facingRight) {
      this.x += speed * dt;
    } else {
      this.x -= speed * dt;
    }

    // Bounce off arena walls
    if (this.x <= this.arenaLeft) {
      this.x = this.arenaLeft;
      this.facingRight = true;
    }
    if (this.x + this.width >= this.arenaRight) {
      this.x = this.arenaRight - this.width;
      this.facingRight = false;
    }

    // Phase 2: Periodic jumping
    if (this.phase >= 2) {
      this.jumpTimer += dt;
      if (this.jumpTimer >= 2.5 && this.onGround) {
        this.vy = -600;
        this.onGround = false;
        this.jumpTimer = 0;
      }
    }

    // Phase 3: Periodic red candle projectiles
    if (this.phase >= 3) {
      this.projectileTimer += dt;
      if (this.projectileTimer >= 1.8) {
        this.projectileTimer = 0;
        // Spawn 3 projectiles above the arena
        for (let i = 0; i < 3; i++) {
          const px = this.arenaLeft + 50 + Math.random() * (this.arenaRight - this.arenaLeft - 100);
          this.projectiles.push({
            x: px,
            y: 50 + Math.random() * 50,
            vy: 200,
            width: 16,
            height: 24,
          });
        }
      }
    }

    // Update shockwaves
    this._updateShockwaves(dt);
    // Update projectiles
    this._updateProjectiles(dt);

    if (this.stompFlashTimer > 0) this.stompFlashTimer -= dt;

    return true;
  }

  _updateShockwaves(dt) {
    for (let i = this.shockwaves.length - 1; i >= 0; i--) {
      const sw = this.shockwaves[i];
      sw.radius += sw.speed * dt;
      if (sw.radius > sw.maxRadius) {
        this.shockwaves.splice(i, 1);
      }
    }
  }

  _updateProjectiles(dt) {
    for (let i = this.projectiles.length - 1; i >= 0; i--) {
      const p = this.projectiles[i];
      p.y += p.vy * dt;
      if (p.y > CONFIG.VIRTUAL_HEIGHT + 100) {
        this.projectiles.splice(i, 1);
      }
    }
  }

  stomp() {
    this.hp--;
    this.stunned = true;
    this.stunTimer = 0.5;
    this.stompFlashTimer = 0.3;

    if (this.hp === 6) {
      this.phase = 2;
      this.vx = 180;
    }
    if (this.hp === 3) {
      this.phase = 3;
      this.vx = 200;
    }
    if (this.hp <= 0) {
      this.alive = false;
      return true;
    }
    return false;
  }

  render(ctx, camera) {
    const sx = this.x - camera.x;
    const sy = this.y - camera.y;
    if (sx + this.width < -50 || sx > CONFIG.VIRTUAL_WIDTH + 50) return;

    const w = this.width;
    const h = this.height;

    ctx.save();

    if (!this.alive) {
      // Death animation — flash and shrink
      const deathPulse = Math.sin(this.deathTimer * 20) > 0;
      ctx.globalAlpha = Math.max(0, 1 - this.deathTimer / 1.5);
      const shrink = Math.max(0.1, 1 - this.deathTimer / 1.2);
      ctx.translate(sx + w / 2, sy + h);
      ctx.scale(shrink, shrink);
      ctx.translate(-w / 2, -h);
      if (deathPulse) {
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, w, h);
      } else {
        this._drawWhaleBody(ctx, w, h);
      }
      ctx.restore();
      return;
    }

    ctx.translate(sx, sy);

    // Flip based on direction
    if (!this.facingRight) {
      ctx.translate(w, 0);
      ctx.scale(-1, 1);
    }

    this._drawWhaleBody(ctx, w, h);

    // Stomp flash
    if (this.stompFlashTimer > 0) {
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(0, 0, w, h);
      ctx.globalAlpha = 1;
    }

    // Stunned stars
    if (this.stunned) {
      ctx.globalAlpha = 0.8;
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      for (let s = 0; s < 4; s++) {
        const angle = this.animTime * 5 + s * (Math.PI * 2 / 4);
        const starX = w / 2 + Math.cos(angle) * 30;
        const starY = -10 + Math.sin(angle) * 8;
        ctx.fillStyle = '#FFD700';
        ctx.fillText('\u2605', starX, starY);
      }
      ctx.globalAlpha = 1;
    }

    ctx.restore();

    // Boss name above (screen space, not flipped)
    if (this.alive) {
      ctx.fillStyle = '#FFFFFF';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText('THE WHALE', sx + w / 2, sy - 14);
    }

    // Render shockwaves
    for (const sw of this.shockwaves) {
      const swx = sw.x - camera.x;
      const swy = sw.y - camera.y;
      const opacity = Math.max(0, 1 - sw.radius / sw.maxRadius);
      ctx.globalAlpha = opacity * 0.6;
      ctx.strokeStyle = this.phase === 3 ? '#FF4444' : '#FFAA00';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(swx, swy, sw.radius, Math.PI, 0);
      ctx.stroke();
      // Second ring
      ctx.globalAlpha = opacity * 0.3;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(swx, swy, sw.radius * 0.7, Math.PI, 0);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // Render projectiles
    for (const p of this.projectiles) {
      const px = p.x - camera.x;
      const py = p.y - camera.y;
      // Warning glow
      ctx.globalAlpha = 0.2;
      ctx.fillStyle = '#FF0000';
      ctx.beginPath();
      ctx.arc(px + p.width / 2, py + p.height / 2, 14, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      // Candle body
      ctx.fillStyle = '#CC0000';
      ctx.fillRect(px + 2, py + 6, p.width - 4, p.height - 8);
      // Wick
      ctx.fillStyle = '#990000';
      ctx.fillRect(px + p.width / 2 - 2, py, 4, 8);
      ctx.fillRect(px + p.width / 2 - 2, py + p.height - 4, 4, 6);
      // Down arrow
      ctx.fillStyle = '#FF4444';
      ctx.font = 'bold 10px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('\u25BC', px + p.width / 2, py + p.height + 8);
    }
  }

  _drawWhaleBody(ctx, w, h) {
    // Body color changes by phase
    let bodyColor, bellyColor, eyeColor;
    if (this.phase === 1) {
      bodyColor = '#2a3a5a';
      bellyColor = '#8a9aaa';
      eyeColor = '#FFFFFF';
    } else if (this.phase === 2) {
      bodyColor = '#5a2a2a';
      bellyColor = '#aa7a7a';
      eyeColor = '#FF4444';
    } else {
      bodyColor = '#6a1a1a';
      bellyColor = '#cc6666';
      eyeColor = '#FF0000';
    }

    // Phase 3 particle trail
    if (this.phase === 3) {
      ctx.globalAlpha = 0.3;
      for (let i = 0; i < 5; i++) {
        const trailX = -10 - i * 12 + Math.sin(this.animTime * 8 + i) * 4;
        const trailY = h * 0.5 + Math.cos(this.animTime * 6 + i * 2) * 10;
        ctx.fillStyle = i % 2 === 0 ? '#FF4444' : '#FF8800';
        ctx.beginPath();
        ctx.arc(trailX, trailY, 4 - i * 0.6, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    // Large oval body
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.ellipse(w * 0.5, h * 0.55, w * 0.48, h * 0.42, 0, 0, Math.PI * 2);
    ctx.fill();

    // Light belly
    ctx.fillStyle = bellyColor;
    ctx.beginPath();
    ctx.ellipse(w * 0.48, h * 0.65, w * 0.32, h * 0.25, 0, 0, Math.PI * 2);
    ctx.fill();

    // Flipper-like arms
    ctx.fillStyle = bodyColor;
    // Top flipper
    ctx.beginPath();
    ctx.ellipse(w * 0.3, h * 0.3, w * 0.12, h * 0.2, -0.6, 0, Math.PI * 2);
    ctx.fill();
    // Bottom flipper
    ctx.beginPath();
    ctx.ellipse(w * 0.25, h * 0.7, w * 0.1, h * 0.08, 0.3, 0, Math.PI * 2);
    ctx.fill();

    // Tail fin
    ctx.beginPath();
    ctx.moveTo(w * 0.02, h * 0.45);
    ctx.quadraticCurveTo(-w * 0.08, h * 0.2, -w * 0.04, h * 0.15);
    ctx.quadraticCurveTo(w * 0.02, h * 0.35, w * 0.05, h * 0.45);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(w * 0.02, h * 0.55);
    ctx.quadraticCurveTo(-w * 0.08, h * 0.8, -w * 0.04, h * 0.85);
    ctx.quadraticCurveTo(w * 0.02, h * 0.65, w * 0.05, h * 0.55);
    ctx.fill();

    // Head shape (front of the whale)
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.ellipse(w * 0.78, h * 0.5, w * 0.22, h * 0.35, 0, 0, Math.PI * 2);
    ctx.fill();

    // Eye
    ctx.fillStyle = eyeColor;
    ctx.beginPath();
    ctx.arc(w * 0.82, h * 0.38, 6, 0, Math.PI * 2);
    ctx.fill();
    // Eye pupil
    ctx.fillStyle = '#000000';
    ctx.beginPath();
    ctx.arc(w * 0.83, h * 0.38, 3, 0, Math.PI * 2);
    ctx.fill();
    // Phase 2/3: glowing eye ring
    if (this.phase >= 2) {
      ctx.globalAlpha = 0.5 + Math.sin(this.animTime * 6) * 0.3;
      ctx.strokeStyle = eyeColor;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(w * 0.82, h * 0.38, 8, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // Open mouth when not stunned
    if (!this.stunned) {
      ctx.fillStyle = '#1a0000';
      ctx.beginPath();
      ctx.ellipse(w * 0.92, h * 0.58, w * 0.08, h * 0.1, 0, 0, Math.PI * 2);
      ctx.fill();
      // Teeth
      ctx.fillStyle = '#FFFFFF';
      for (let t = 0; t < 3; t++) {
        ctx.fillRect(w * 0.87 + t * 6, h * 0.52, 3, 5);
        ctx.fillRect(w * 0.87 + t * 6, h * 0.62, 3, 5);
      }
    }

    // Bear-like ears (whale-bear hybrid)
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.arc(w * 0.72, h * 0.18, w * 0.06, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(w * 0.88, h * 0.18, w * 0.06, 0, Math.PI * 2);
    ctx.fill();
    // Inner ears
    ctx.fillStyle = bellyColor;
    ctx.beginPath();
    ctx.arc(w * 0.72, h * 0.18, w * 0.03, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(w * 0.88, h * 0.18, w * 0.03, 0, Math.PI * 2);
    ctx.fill();

    // Angry eyebrows
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(w * 0.74, h * 0.28);
    ctx.lineTo(w * 0.84, h * 0.32);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(w * 0.92, h * 0.28);
    ctx.lineTo(w * 0.85, h * 0.32);
    ctx.stroke();
  }
}

class FlashTrader {
  constructor(x, y, patrolLeft, patrolRight) {
    this.x = x;
    this.y = y;
    this.width = CONFIG.FLASH_TRADER_WIDTH;
    this.height = CONFIG.FLASH_TRADER_HEIGHT;
    this.vx = CONFIG.FLASH_TRADER_SPEED;
    this.vy = 0;
    this.patrolLeft = patrolLeft;
    this.patrolRight = patrolRight;
    this.alive = true;
    this.hp = 1;
    this.onGround = false;
    this.animTime = 0;
    this.deathTimer = 0;
    this.facingRight = true;
    this.crashSpeedMult = 1.0;
    this.dashTimer = 0;
    this.dashInterval = CONFIG.FLASH_TRADER_DASH_INTERVAL;
    this.isCharging = false;
    this.chargeTimer = 0;
  }

  update(dt, solids) {
    if (!this.alive) {
      this.deathTimer += dt;
      return this.deathTimer < 0.5;
    }

    applyGravity(this, dt);

    // Update dash timers
    this.dashTimer += dt;
    if (this.isCharging) {
      this.chargeTimer += dt;
    }

    // Check if it's time to dash
    if (this.dashTimer >= this.dashInterval && !this.isCharging) {
      this.isCharging = true;
      this.chargeTimer = 0;
    }

    // Perform dash after charging
    if (this.isCharging && this.chargeTimer >= 0.4) {
      // Teleport dash forward
      const dashDirection = this.facingRight ? 1 : -1;
      this.x += CONFIG.FLASH_TRADER_DASH_DISTANCE * dashDirection;
      this.isCharging = false;
      this.dashTimer = 0;
      this.chargeTimer = 0;
    }

    this.x += this.vx * this.crashSpeedMult * dt;
    this.y += this.vy * dt;

    // Patrol boundaries
    if (this.x <= this.patrolLeft) {
      this.x = this.patrolLeft;
      this.vx = Math.abs(this.vx);
      this.facingRight = true;
    }
    if (this.x + this.width >= this.patrolRight) {
      this.x = this.patrolRight - this.width;
      this.vx = -Math.abs(this.vx);
      this.facingRight = false;
    }

    // Collision with solids
    resolveEntityCollisions(this, solids);

    this.animTime += dt;
    return true;
  }

  stomp() {
    this.hp--;
    if (this.hp <= 0) {
      this.alive = false;
      return true;
    }
    return false;
  }

  render(ctx, camera) {
    const sx = this.x - camera.x;
    const sy = this.y - camera.y;
    if (sx + this.width < -20 || sx > CONFIG.VIRTUAL_WIDTH + 20) return;

    const w = this.width;
    const h = this.height;

    ctx.save();

    if (!this.alive) {
      // Squish animation
      const squish = Math.max(0.1, 1 - (this.deathTimer / 0.3));
      ctx.translate(sx + w / 2, sy + h);
      ctx.scale(1.3, squish);
      ctx.translate(-w / 2, -h);
      this._drawBody(ctx, w, h);
      ctx.restore();
      return;
    }

    ctx.translate(sx, sy);

    // Flip if facing left
    if (!this.facingRight) {
      ctx.translate(w, 0);
      ctx.scale(-1, 1);
    }

    this._drawBody(ctx, w, h);

    // Charging glow effect
    if (this.isCharging) {
      const glowIntensity = this.chargeTimer / 0.4;
      ctx.globalAlpha = glowIntensity * 0.5;
      ctx.fillStyle = '#00FF88';
      ctx.beginPath();
      ctx.arc(w / 2, h / 2, w / 2 + 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  _drawBody(ctx, w, h) {
    // Hoodie outline
    ctx.fillStyle = '#1a1a3a';
    ctx.beginPath();
    ctx.arc(w / 2, h * 0.35, w * 0.38, 0, Math.PI * 2);
    ctx.fill();

    // Face (computer screen glow)
    ctx.fillStyle = '#00AA00';
    ctx.fillRect(w * 0.2, h * 0.22, w * 0.6, h * 0.45);

    // Screen frame
    ctx.strokeStyle = '#008800';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(w * 0.2, h * 0.22, w * 0.6, h * 0.45);

    // Screen grid/text effect
    ctx.strokeStyle = '#00FF88';
    ctx.lineWidth = 0.5;
    ctx.globalAlpha = 0.4;
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.moveTo(w * 0.25, h * 0.3 + i * 10);
      ctx.lineTo(w * 0.75, h * 0.3 + i * 10);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // Eyes (glowing dots on screen)
    ctx.fillStyle = '#00FF88';
    ctx.beginPath();
    ctx.arc(w * 0.38, h * 0.35, 2.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(w * 0.62, h * 0.35, 2.5, 0, Math.PI * 2);
    ctx.fill();

    // Body (torso under hoodie)
    ctx.fillStyle = '#2a2a4a';
    ctx.fillRect(w * 0.15, h * 0.65, w * 0.7, h * 0.35);

    // Arms
    ctx.fillStyle = '#1a1a3a';
    ctx.fillRect(w * 0.05, h * 0.7, w * 0.15, h * 0.25);
    ctx.fillRect(w * 0.8, h * 0.7, w * 0.15, h * 0.25);

    // Legs
    ctx.fillStyle = '#000000';
    ctx.fillRect(w * 0.25, h * 0.85, w * 0.18, h * 0.15);
    ctx.fillRect(w * 0.57, h * 0.85, w * 0.18, h * 0.15);
  }
}

class ShortSeller {
  constructor(x, y, patrolLeft, patrolRight) {
    this.x = x;
    this.y = y;
    this.width = CONFIG.SHORT_SELLER_WIDTH;
    this.height = CONFIG.SHORT_SELLER_HEIGHT;
    this.vx = CONFIG.SHORT_SELLER_SPEED;
    this.vy = 0;
    this.patrolLeft = patrolLeft;
    this.patrolRight = patrolRight;
    this.alive = true;
    this.hp = 1;
    this.onGround = false;
    this.animTime = 0;
    this.deathTimer = 0;
    this.facingRight = true;
    this.crashSpeedMult = 1.0;
    this.bobOffset = 0;
  }

  update(dt, solids) {
    if (!this.alive) {
      this.deathTimer += dt;
      return this.deathTimer < 0.5;
    }

    // No gravity for floating enemy
    // Horizontal patrol
    this.x += this.vx * this.crashSpeedMult * dt;

    // Patrol boundaries
    if (this.x <= this.patrolLeft) {
      this.x = this.patrolLeft;
      this.vx = Math.abs(this.vx);
      this.facingRight = true;
    }
    if (this.x + this.width >= this.patrolRight) {
      this.x = this.patrolRight - this.width;
      this.vx = -Math.abs(this.vx);
      this.facingRight = false;
    }

    // Bob up and down sinusoidally
    this.bobOffset = Math.sin(this.animTime * 2) * 15;

    this.animTime += dt;
    return true;
  }

  stomp() {
    this.hp--;
    if (this.hp <= 0) {
      this.alive = false;
      return true;
    }
    return false;
  }

  render(ctx, camera) {
    const sx = this.x - camera.x;
    const sy = this.y - camera.y + this.bobOffset;
    if (sx + this.width < -20 || sx > CONFIG.VIRTUAL_WIDTH + 20) return;

    const w = this.width;
    const h = this.height;

    ctx.save();

    if (!this.alive) {
      // Fade out animation
      const fade = Math.max(0, 1 - (this.deathTimer / 0.5));
      ctx.globalAlpha = fade;
      ctx.translate(sx, sy);
      if (!this.facingRight) {
        ctx.translate(w, 0);
        ctx.scale(-1, 1);
      }
      this._drawBody(ctx, w, h);
      ctx.globalAlpha = 1;
      ctx.restore();
      return;
    }

    ctx.translate(sx, sy);

    // Flip if facing left
    if (!this.facingRight) {
      ctx.translate(w, 0);
      ctx.scale(-1, 1);
    }

    this._drawBody(ctx, w, h);

    ctx.restore();
  }

  _drawBody(ctx, w, h) {
    // Dark cloak/robe
    ctx.fillStyle = '#1a0000';
    ctx.beginPath();
    ctx.moveTo(w * 0.1, h * 0.2);
    ctx.quadraticCurveTo(w * 0.5, h * 0.15, w * 0.9, h * 0.2);
    ctx.quadraticCurveTo(w * 0.95, h * 0.5, w * 0.85, h * 0.95);
    ctx.quadraticCurveTo(w * 0.5, h * 1.0, w * 0.15, h * 0.95);
    ctx.quadraticCurveTo(w * 0.05, h * 0.5, w * 0.1, h * 0.2);
    ctx.fill();

    // Darker hood shadow
    ctx.fillStyle = '#0a0a0a';
    ctx.beginPath();
    ctx.ellipse(w * 0.5, h * 0.25, w * 0.35, h * 0.18, 0, 0, Math.PI * 2);
    ctx.fill();

    // Red glowing eyes
    ctx.fillStyle = '#FF4444';
    ctx.beginPath();
    ctx.arc(w * 0.35, h * 0.28, 3.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(w * 0.65, h * 0.28, 3.5, 0, Math.PI * 2);
    ctx.fill();

    // Eye glow
    ctx.globalAlpha = 0.4;
    ctx.fillStyle = '#FF4444';
    ctx.beginPath();
    ctx.arc(w * 0.35, h * 0.28, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(w * 0.65, h * 0.28, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // "Short" scroll in hand
    ctx.fillStyle = '#CCCCCC';
    ctx.save();
    ctx.translate(w * 0.75, h * 0.5);
    ctx.rotate(0.3);
    ctx.fillRect(-4, -12, 8, 24);
    ctx.restore();

    // Scroll text "SHORT"
    ctx.fillStyle = '#FF0000';
    ctx.font = 'bold 6px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('SHORT', w * 0.75, h * 0.5);

    // Scroll ends
    ctx.fillStyle = '#8B4513';
    ctx.beginPath();
    ctx.arc(w * 0.75, h * 0.32, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(w * 0.75, h * 0.68, 3, 0, Math.PI * 2);
    ctx.fill();
  }
}
  </script>
  <script>
class Player {
  constructor(x, y, characterType) {
    this.x = x;
    this.y = y;
    this.width = CONFIG.PLAYER_WIDTH;
    this.height = CONFIG.PLAYER_HEIGHT;
    this.vx = 0;
    this.vy = 0;
    this.onGround = false;
    this.facingRight = true;

    this.characterType = characterType; // 'chad' or 'diana'

    this.lives = CONFIG.PLAYER_MAX_LIVES;
    this.score = 0;
    this.bullsCollected = 0;
    this.totalBullsCollected = 0;
    this.powered = false;
    this.invincible = false;
    this.invincibleTimer = 0;
    this.damageInvTimer = 0;
    this.alive = true;
    this.hasHeadband = false;
    this.diamondHands = false;

    // Crouch state
    this.crouching = false;
    this.crouchTimer = 0;       // how long we've been crouching
    this.superJumpReady = false; // true when crouch is charged

    this.animTime = 0;
    this.state = 'idle';

    this.spawnX = x;
    this.spawnY = y;
    this.deathAnimTimer = 0;
    this.deathAnimating = false;

    // Jump event flags (read and cleared by main.js each frame)
    this.jumpedThisFrame = false;
    this.superJumpedThisFrame = false;

    // Moving platform velocity transfer (set by main.js each frame)
    this._platformVx = 0;
    this._platformVy = 0;
  }

  _getStandingHeight() {
    return this.powered ? CONFIG.PLAYER_POWERED_HEIGHT : CONFIG.PLAYER_HEIGHT;
  }

  _getCrouchHeight() {
    return this.powered ? CONFIG.PLAYER_POWERED_CROUCH_HEIGHT : CONFIG.PLAYER_CROUCH_HEIGHT;
  }

  update(dt, input, solids) {
    if (this.deathAnimating) {
      this.deathAnimTimer += dt;
      this.vy += CONFIG.GRAVITY * dt * 0.5;
      this.y += this.vy * dt;
      return;
    }

    // === JUMP (check BEFORE crouch so releasing down + jumping on same frame still works) ===
    this.jumpedThisFrame = false;
    this.superJumpedThisFrame = false;
    if (input.jump && this.onGround) {
      if (this.superJumpReady) {
        // SUPER JUMP from crouch!
        this.vy = CONFIG.PLAYER_SUPER_JUMP_VELOCITY;
        // Restore standing height for the jump
        if (this.crouching) {
          const standHeight = this._getStandingHeight();
          this.y -= (standHeight - this.height);
          this.height = standHeight;
        }
        this.superJumpedThisFrame = true;
      } else {
        this.vy = CONFIG.PLAYER_JUMP_VELOCITY;
        if (this.crouching) {
          const standHeight = this._getStandingHeight();
          this.y -= (standHeight - this.height);
          this.height = standHeight;
        }
        this.jumpedThisFrame = true;
      }
      // Transfer moving platform velocity to jump (better jump arcs off moving platforms)
      if (this._platformVx) this.vx += this._platformVx * 0.5;
      if (this._platformVy < 0) this.vy += this._platformVy * 0.3; // Boost from upward platforms
      this.crouching = false;
      this.crouchTimer = 0;
      this.superJumpReady = false;
      this.onGround = false;
    }
    // Clear platform velocity each frame (re-set by main.js if still on platform)
    this._platformVx = 0;
    this._platformVy = 0;

    // === CROUCH ===
    if (!this.crouching && !this.superJumpReady) {
      const wantsCrouch = input.down && this.onGround;
      if (wantsCrouch) {
        // Start crouching — shrink hitbox, keep feet on the ground
        this.crouching = true;
        this.crouchTimer = 0;
        this.superJumpReady = false;
        const oldHeight = this.height;
        this.height = this._getCrouchHeight();
        this.y += (oldHeight - this.height); // keep feet planted
      }
    } else if (this.crouching) {
      this.crouchTimer += dt;
      if (this.crouchTimer >= CONFIG.PLAYER_CROUCH_TIME) {
        this.superJumpReady = true;
      }
      // Stand up when down is released
      if (!input.down) {
        this._standUp(solids);
      }
    }

    // Cancel crouch if not on ground
    if (!this.onGround && this.crouching) {
      this._standUp(solids);
    }

    // === HORIZONTAL MOVEMENT ===
    // Slower when crouching
    const accel = this.crouching ? CONFIG.PLAYER_ACCELERATION * 0.3 : CONFIG.PLAYER_ACCELERATION;
    const maxSpeed = this.invincible ? CONFIG.PLAYER_RUN_SPEED * 1.4
                   : this.crouching ? CONFIG.PLAYER_RUN_SPEED * 0.3
                   : CONFIG.PLAYER_RUN_SPEED;

    if (input.left) {
      this.vx -= accel * dt;
      this.facingRight = false;
    } else if (input.right) {
      this.vx += accel * dt;
      this.facingRight = true;
    } else {
      // Less friction in air for better air control
      const friction = this.onGround ? CONFIG.GROUND_FRICTION : 0.98;
      this.vx *= friction;
      if (Math.abs(this.vx) < 5) this.vx = 0;
    }

    this.vx = Math.clamp(this.vx, -maxSpeed, maxSpeed);

    // === PHYSICS ===
    applyGravity(this, dt);
    moveAndCollide(this, solids, dt);

    // Clamp to left edge of level
    if (this.x < 0) {
      this.x = 0;
      this.vx = 0;
    }

    // Update invincibility timers
    if (this.invincibleTimer > 0) {
      this.invincibleTimer -= dt;
      if (this.invincibleTimer <= 0) {
        this.invincible = false;
        this.diamondHands = false;
        this.invincibleTimer = 0;
      }
    }
    if (this.damageInvTimer > 0) {
      this.damageInvTimer -= dt;
    }

    // === ANIMATION STATE ===
    this.animTime += dt;
    if (!this.onGround) {
      this.state = this.vy < 0 ? 'jumping' : 'falling';
    } else if (this.crouching) {
      this.state = this.superJumpReady ? 'crouch_ready' : 'crouching';
    } else if (Math.abs(this.vx) > 10) {
      this.state = 'running';
    } else {
      this.state = 'idle';
    }
  }

  _standUp(solids) {
    if (!this.crouching) return;
    const standHeight = this._getStandingHeight();
    const heightDiff = standHeight - this.height;
    // Check if there's room to stand up
    const testY = this.y - heightDiff;
    const testEntity = { x: this.x, y: testY, width: this.width, height: standHeight };
    let blocked = false;
    for (const solid of solids) {
      if (solid.semiSolid) continue; // Can pass through semi-solid platforms
      if (aabbOverlap(testEntity, solid)) {
        blocked = true;
        break;
      }
    }
    if (!blocked) {
      this.y -= heightDiff;
      this.height = standHeight;
      this.crouching = false;
      this.crouchTimer = 0;
      this.superJumpReady = false;
    }
    // If blocked, stay crouched
  }

  takeDamage() {
    if (this.invincible || this.damageInvTimer > 0) return false;
    if (this.hasHeadband) {
      this.hasHeadband = false;
      this.damageInvTimer = CONFIG.PLAYER_INVINCIBILITY_TIME;
      return false;
    }
    if (this.powered) {
      this.powered = false;
      this.width = CONFIG.PLAYER_WIDTH;
      this.height = this.crouching ? CONFIG.PLAYER_CROUCH_HEIGHT : CONFIG.PLAYER_HEIGHT;
      this.damageInvTimer = CONFIG.PLAYER_INVINCIBILITY_TIME;
      return false;
    }
    return true;
  }

  die() {
    this.lives--;
    this.deathAnimating = true;
    this.deathAnimTimer = 0;
    this.vy = -400;
    this.vx = 0;
    this.crouching = false;
    this.crouchTimer = 0;
    this.superJumpReady = false;
  }

  respawn() {
    this.x = this.spawnX;
    this.y = this.spawnY;
    this.vx = 0;
    this.vy = 0;
    this.deathAnimating = false;
    this.deathAnimTimer = 0;
    this.damageInvTimer = CONFIG.PLAYER_INVINCIBILITY_TIME;
    this.onGround = false;
    this.crouching = false;
    this.crouchTimer = 0;
    this.superJumpReady = false;
    this.width = CONFIG.PLAYER_WIDTH;
    this.height = CONFIG.PLAYER_HEIGHT;
    this.hasHeadband = false;
    this.diamondHands = false;
    this.invincible = false;
    this.invincibleTimer = 0;
    this.powered = false;
  }

  collectBull() {
    this.bullsCollected++;
    this.totalBullsCollected++;
    this.score += CONFIG.BULL_SCORE;
    if (this.bullsCollected >= CONFIG.BULLS_FOR_DIAMOND_HANDS) {
      this.bullsCollected = 0;
      this.activateDiamondHands();
      return 'diamondHands';
    }
    return false;
  }

  applyPowerUp(type) {
    if (type === 'greenCandle') {
      if (!this.powered) {
        this.powered = true;
        const newHeight = this.crouching ? CONFIG.PLAYER_POWERED_CROUCH_HEIGHT : CONFIG.PLAYER_POWERED_HEIGHT;
        this.y -= (newHeight - this.height);
        this.width = CONFIG.PLAYER_POWERED_WIDTH;
        this.height = newHeight;
      }
    } else if (type === 'hodlItem') {
      this.hasHeadband = true;
    }
  }

  activateDiamondHands() {
    this.invincible = true;
    this.diamondHands = true;
    this.invincibleTimer = CONFIG.DIAMOND_HANDS_DURATION;
  }

  render(ctx, camera) {
    if (this.damageInvTimer > 0 && Math.floor(this.damageInvTimer * 10) % 2 === 0 && !this.deathAnimating) {
      return;
    }

    const screenX = this.x - camera.x;
    const screenY = this.y - camera.y;

    ctx.save();

    // Diamond Hands invincibility glow
    if (this.diamondHands) {
      // Diamond-shaped sparkling aura
      const cx = screenX + this.width / 2;
      const cy = screenY + this.height / 2;
      const auraSize = this.width * 1.1;

      // Outer diamond glow
      ctx.globalAlpha = 0.25 + Math.sin(this.animTime * 8) * 0.1;
      ctx.fillStyle = '#88DDFF';
      ctx.beginPath();
      ctx.moveTo(cx, cy - auraSize);
      ctx.lineTo(cx + auraSize * 0.7, cy);
      ctx.lineTo(cx, cy + auraSize);
      ctx.lineTo(cx - auraSize * 0.7, cy);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;

      // Sparkle particles around player
      for (let i = 0; i < 6; i++) {
        const angle = this.animTime * 3 + i * (Math.PI * 2 / 6);
        const dist = this.width * 0.8 + Math.sin(this.animTime * 5 + i) * 5;
        const px = cx + Math.cos(angle) * dist;
        const py = cy + Math.sin(angle) * dist * 0.7;
        ctx.globalAlpha = 0.6 + Math.sin(this.animTime * 10 + i * 2) * 0.4;
        ctx.fillStyle = '#FFFFFF';
        // Diamond shape sparkle
        ctx.beginPath();
        ctx.moveTo(px, py - 3);
        ctx.lineTo(px + 2, py);
        ctx.lineTo(px, py + 3);
        ctx.lineTo(px - 2, py);
        ctx.closePath();
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Rainbow cycle border
      const hue = (this.animTime * 200) % 360;
      ctx.globalAlpha = 0.2;
      ctx.fillStyle = 'hsl(' + hue + ', 100%, 70%)';
      ctx.fillRect(screenX - 2, screenY - 2, this.width + 4, this.height + 4);
      ctx.globalAlpha = 1;
    } else if (this.invincible) {
      // Generic invincibility glow (fallback)
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = CONFIG.COLORS.BULL_GOLD;
      ctx.beginPath();
      ctx.arc(screenX + this.width / 2, screenY + this.height / 2, this.width * 0.9, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // Super jump ready indicator
    if (this.superJumpReady && this.crouching) {
      // Pulsing glow under feet
      const pulse = 0.3 + Math.sin(this.animTime * 10) * 0.2;
      ctx.globalAlpha = pulse;
      ctx.fillStyle = CONFIG.COLORS.BULL_GOLD;
      ctx.beginPath();
      ctx.ellipse(screenX + this.width / 2, screenY + this.height, this.width * 0.7, 6, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // Arrow indicator
      ctx.fillStyle = CONFIG.COLORS.BULL_GOLD;
      ctx.font = 'bold 16px sans-serif';
      ctx.textAlign = 'center';
      const bounce = Math.sin(this.animTime * 8) * 3;
      ctx.fillText('\u25B2', screenX + this.width / 2, screenY - 8 + bounce);
    }

    if (!this.facingRight) {
      ctx.translate(screenX + this.width, screenY);
      ctx.scale(-1, 1);
    } else {
      ctx.translate(screenX, screenY);
    }

    // When crouching, squash the character drawing
    if (this.crouching) {
      const standH = this._getStandingHeight();
      const squashRatio = this.height / standH;
      // Scale vertically to squash, keep bottom aligned
      ctx.translate(0, this.height);
      ctx.scale(1.15, squashRatio); // slightly wider when crouching
      ctx.translate(-this.width * 0.075, -standH); // offset for wider scale
      // Draw at standing dimensions — the scale will squash it
      if (this.characterType === 'chad') {
        this._renderChad(ctx, this.width / 1.15, standH);
      } else {
        this._renderDiana(ctx, this.width / 1.15, standH);
      }
    } else {
      if (this.characterType === 'chad') {
        this._renderChad(ctx, this.width, this.height);
      } else {
        this._renderDiana(ctx, this.width, this.height);
      }
    }

    ctx.restore();
  }

  _renderChad(ctx, w, h) {
    const legSwing = this.state === 'running' ? Math.sin(this.animTime * 12) * 8 : 0;
    const armSwing = this.state === 'running' ? Math.sin(this.animTime * 12) * 15 : 0;

    // Legs
    ctx.fillStyle = '#1a1a3a';
    ctx.save();
    ctx.translate(w * 0.25, h * 0.68);
    ctx.rotate(legSwing * Math.PI / 180);
    ctx.fillRect(-w * 0.09, 0, w * 0.18, h * 0.32);
    ctx.fillStyle = '#111';
    ctx.fillRect(-w * 0.09, h * 0.28, w * 0.22, h * 0.06);
    ctx.restore();

    ctx.fillStyle = '#1a1a3a';
    ctx.save();
    ctx.translate(w * 0.7, h * 0.68);
    ctx.rotate(-legSwing * Math.PI / 180);
    ctx.fillRect(-w * 0.09, 0, w * 0.18, h * 0.32);
    ctx.fillStyle = '#111';
    ctx.fillRect(-w * 0.09, h * 0.28, w * 0.22, h * 0.06);
    ctx.restore();

    // Body (suit jacket)
    ctx.fillStyle = CONFIG.COLORS.PLAYER_SUIT;
    ctx.fillRect(w * 0.1, h * 0.3, w * 0.8, h * 0.4);

    // Shirt collar / V-neck
    ctx.fillStyle = CONFIG.COLORS.PLAYER_SHIRT;
    ctx.beginPath();
    ctx.moveTo(w * 0.35, h * 0.3);
    ctx.lineTo(w * 0.5, h * 0.5);
    ctx.lineTo(w * 0.65, h * 0.3);
    ctx.fill();

    // Tie
    ctx.fillStyle = CONFIG.COLORS.PLAYER_TIE;
    ctx.beginPath();
    ctx.moveTo(w * 0.45, h * 0.32);
    ctx.lineTo(w * 0.55, h * 0.32);
    ctx.lineTo(w * 0.52, h * 0.58);
    ctx.lineTo(w * 0.5, h * 0.62);
    ctx.lineTo(w * 0.48, h * 0.58);
    ctx.closePath();
    ctx.fill();

    // Left arm
    ctx.fillStyle = CONFIG.COLORS.PLAYER_SUIT;
    ctx.save();
    ctx.translate(w * 0.08, h * 0.32);
    ctx.rotate(-armSwing * Math.PI / 180 * 0.5);
    ctx.fillRect(0, 0, w * 0.14, h * 0.3);
    ctx.fillStyle = CONFIG.COLORS.PLAYER_SKIN;
    ctx.fillRect(0, h * 0.27, w * 0.12, h * 0.06);
    ctx.restore();

    // Right arm + briefcase
    ctx.fillStyle = CONFIG.COLORS.PLAYER_SUIT;
    ctx.save();
    ctx.translate(w * 0.78, h * 0.32);
    ctx.rotate(armSwing * Math.PI / 180 * 0.5);
    ctx.fillRect(0, 0, w * 0.14, h * 0.3);
    ctx.fillStyle = CONFIG.COLORS.PLAYER_SKIN;
    ctx.fillRect(0, h * 0.27, w * 0.12, h * 0.06);
    ctx.fillStyle = '#8B6914';
    ctx.fillRect(-w * 0.02, h * 0.3, w * 0.28, h * 0.18);
    ctx.fillStyle = '#A07818';
    ctx.fillRect(-w * 0.02, h * 0.3, w * 0.28, h * 0.04);
    ctx.fillStyle = CONFIG.COLORS.BULL_GOLD;
    ctx.fillRect(w * 0.08, h * 0.34, w * 0.08, h * 0.03);
    ctx.restore();

    // Head
    ctx.fillStyle = CONFIG.COLORS.PLAYER_SKIN;
    ctx.beginPath();
    ctx.ellipse(w * 0.5, h * 0.18, w * 0.28, h * 0.16, 0, 0, Math.PI * 2);
    ctx.fill();

    // Hair (slicked back)
    ctx.fillStyle = CONFIG.COLORS.PLAYER_HAIR_MALE;
    ctx.beginPath();
    ctx.ellipse(w * 0.5, h * 0.1, w * 0.3, h * 0.1, 0, Math.PI, Math.PI * 2);
    ctx.fill();
    ctx.fillRect(w * 0.2, h * 0.08, w * 0.6, h * 0.06);

    // Eyes
    ctx.fillStyle = CONFIG.COLORS.BLACK;
    ctx.fillRect(w * 0.35, h * 0.16, 3, 4);
    ctx.fillRect(w * 0.58, h * 0.16, 3, 4);

    // Confident smile
    ctx.strokeStyle = CONFIG.COLORS.BLACK;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(w * 0.5, h * 0.22, 5, 0.1, Math.PI - 0.1);
    ctx.stroke();

    if (this.hasHeadband) {
      // Red headband on forehead
      ctx.fillStyle = '#CC0000';
      ctx.fillRect(w * 0.15, h * 0.08, w * 0.7, h * 0.05);
      // Cat ears
      ctx.beginPath();
      ctx.moveTo(w * 0.2, h * 0.1);
      ctx.lineTo(w * 0.15, h * 0.0);
      ctx.lineTo(w * 0.3, h * 0.08);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(w * 0.7, h * 0.08);
      ctx.lineTo(w * 0.85, h * 0.0);
      ctx.lineTo(w * 0.8, h * 0.1);
      ctx.fill();
      // Trailing ribbons
      ctx.strokeStyle = '#CC0000';
      ctx.lineWidth = 1.5;
      const wave = Math.sin(this.animTime * 6) * 3;
      ctx.beginPath();
      ctx.moveTo(w * 0.15, h * 0.1);
      ctx.quadraticCurveTo(w * 0.05, h * 0.18 + wave, w * 0.08, h * 0.25);
      ctx.stroke();
    }

    if (this.powered) {
      ctx.fillStyle = 'rgba(0,204,102,0.15)';
      ctx.fillRect(0, 0, w, h);
    }
  }

  _renderDiana(ctx, w, h) {
    const legSwing = this.state === 'running' ? Math.sin(this.animTime * 12) * 8 : 0;
    const armSwing = this.state === 'running' ? Math.sin(this.animTime * 12) * 12 : 0;

    // Legs
    ctx.fillStyle = '#1a1a3a';
    ctx.save();
    ctx.translate(w * 0.28, h * 0.68);
    ctx.rotate(legSwing * Math.PI / 180);
    ctx.fillRect(-w * 0.08, 0, w * 0.16, h * 0.3);
    ctx.fillStyle = '#333';
    ctx.fillRect(-w * 0.08, h * 0.26, w * 0.2, h * 0.06);
    ctx.restore();

    ctx.fillStyle = '#1a1a3a';
    ctx.save();
    ctx.translate(w * 0.68, h * 0.68);
    ctx.rotate(-legSwing * Math.PI / 180);
    ctx.fillRect(-w * 0.08, 0, w * 0.16, h * 0.3);
    ctx.fillStyle = '#333';
    ctx.fillRect(-w * 0.08, h * 0.26, w * 0.2, h * 0.06);
    ctx.restore();

    // Body (power blazer)
    ctx.fillStyle = CONFIG.COLORS.PLAYER_BLAZER;
    ctx.fillRect(w * 0.1, h * 0.3, w * 0.8, h * 0.4);

    // Blazer lapels
    ctx.fillStyle = CONFIG.COLORS.PLAYER_BLAZER_LIGHT;
    ctx.beginPath();
    ctx.moveTo(w * 0.35, h * 0.3);
    ctx.lineTo(w * 0.5, h * 0.45);
    ctx.lineTo(w * 0.65, h * 0.3);
    ctx.lineTo(w * 0.6, h * 0.3);
    ctx.lineTo(w * 0.5, h * 0.4);
    ctx.lineTo(w * 0.4, h * 0.3);
    ctx.fill();

    // Blouse
    ctx.fillStyle = '#E8E0D0';
    ctx.beginPath();
    ctx.moveTo(w * 0.4, h * 0.3);
    ctx.lineTo(w * 0.5, h * 0.42);
    ctx.lineTo(w * 0.6, h * 0.3);
    ctx.fill();

    // Left arm
    ctx.fillStyle = CONFIG.COLORS.PLAYER_BLAZER;
    ctx.save();
    ctx.translate(w * 0.08, h * 0.32);
    ctx.rotate(-armSwing * Math.PI / 180 * 0.4);
    ctx.fillRect(0, 0, w * 0.14, h * 0.28);
    ctx.fillStyle = CONFIG.COLORS.PLAYER_SKIN;
    ctx.fillRect(0, h * 0.25, w * 0.12, h * 0.06);
    ctx.restore();

    // Right arm + tablet
    ctx.fillStyle = CONFIG.COLORS.PLAYER_BLAZER;
    ctx.save();
    ctx.translate(w * 0.78, h * 0.32);
    ctx.rotate(armSwing * Math.PI / 180 * 0.4);
    ctx.fillRect(0, 0, w * 0.14, h * 0.28);
    ctx.fillStyle = CONFIG.COLORS.PLAYER_SKIN;
    ctx.fillRect(0, h * 0.25, w * 0.12, h * 0.06);
    ctx.fillStyle = '#222';
    ctx.fillRect(-w * 0.06, h * 0.28, w * 0.3, h * 0.2);
    ctx.fillStyle = '#4488FF';
    ctx.fillRect(-w * 0.04, h * 0.3, w * 0.26, h * 0.14);
    ctx.strokeStyle = CONFIG.COLORS.TICKER_GREEN;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-w * 0.02, h * 0.4);
    ctx.lineTo(w * 0.04, h * 0.36);
    ctx.lineTo(w * 0.1, h * 0.38);
    ctx.lineTo(w * 0.16, h * 0.33);
    ctx.lineTo(w * 0.2, h * 0.34);
    ctx.stroke();
    ctx.restore();

    // Head
    ctx.fillStyle = CONFIG.COLORS.PLAYER_SKIN;
    ctx.beginPath();
    ctx.ellipse(w * 0.5, h * 0.18, w * 0.26, h * 0.15, 0, 0, Math.PI * 2);
    ctx.fill();

    // Hair
    ctx.fillStyle = CONFIG.COLORS.PLAYER_HAIR_FEMALE;
    ctx.beginPath();
    ctx.ellipse(w * 0.5, h * 0.1, w * 0.3, h * 0.12, 0, Math.PI, Math.PI * 2);
    ctx.fill();
    ctx.fillRect(w * 0.2, h * 0.06, w * 0.6, h * 0.08);
    ctx.fillRect(w * 0.15, h * 0.1, w * 0.14, h * 0.22);
    ctx.fillRect(w * 0.71, h * 0.1, w * 0.14, h * 0.22);
    ctx.beginPath();
    ctx.arc(w * 0.22, h * 0.32, w * 0.07, 0, Math.PI);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(w * 0.78, h * 0.32, w * 0.07, 0, Math.PI);
    ctx.fill();

    // Eyes
    ctx.fillStyle = CONFIG.COLORS.BLACK;
    ctx.fillRect(w * 0.36, h * 0.16, 3, 4);
    ctx.fillRect(w * 0.58, h * 0.16, 3, 4);

    // Eyelashes
    ctx.strokeStyle = CONFIG.COLORS.BLACK;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(w * 0.34, h * 0.15);
    ctx.lineTo(w * 0.42, h * 0.15);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(w * 0.56, h * 0.15);
    ctx.lineTo(w * 0.64, h * 0.15);
    ctx.stroke();

    // Smile
    ctx.strokeStyle = '#CC6666';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(w * 0.5, h * 0.22, 4, 0.1, Math.PI - 0.1);
    ctx.stroke();

    if (this.hasHeadband) {
      // Red headband on forehead
      ctx.fillStyle = '#CC0000';
      ctx.fillRect(w * 0.15, h * 0.08, w * 0.7, h * 0.05);
      // Cat ears (over hair)
      ctx.beginPath();
      ctx.moveTo(w * 0.2, h * 0.1);
      ctx.lineTo(w * 0.15, h * 0.0);
      ctx.lineTo(w * 0.3, h * 0.08);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(w * 0.7, h * 0.08);
      ctx.lineTo(w * 0.85, h * 0.0);
      ctx.lineTo(w * 0.8, h * 0.1);
      ctx.fill();
      // Trailing ribbons
      ctx.strokeStyle = '#CC0000';
      ctx.lineWidth = 1.5;
      const wave = Math.sin(this.animTime * 6) * 3;
      ctx.beginPath();
      ctx.moveTo(w * 0.15, h * 0.1);
      ctx.quadraticCurveTo(w * 0.05, h * 0.18 + wave, w * 0.08, h * 0.25);
      ctx.stroke();
    }

    if (this.powered) {
      ctx.fillStyle = 'rgba(0,204,102,0.15)';
      ctx.fillRect(0, 0, w, h);
    }
  }
}
  </script>
  <script>
// LEVEL DESIGN REFERENCE:
// Ground surface:  y = 432
// Player on ground: y = 378 (432 - 54 height)
// Player head on ground: y = 378
// Question blocks should be at y <= 320 so player (54px tall) can walk under
// Block bottom at y+48, so block at y=320 has bottom at 368 — player at 378 can walk under
// Platforms are optional elevated areas, NOT on the ground path unless intentional
// Pits: gaps between ground segments

const LEVEL_1 = {
  name: "Wall Street",
  width: 9600,
  playerStart: { x: 96, y: 370 },
  goalPosition: { x: 9300, y: 380 },

  // Dow 30 stock ticker — fallback data (overridden by live API fetch if available)
  tickerStocks: [
    { symbol: 'AAPL', price: 232.47, change: 1.2 },
    { symbol: 'MSFT', price: 415.30, change: 0.8 },
    { symbol: 'AMGN', price: 313.55, change: -0.4 },
    { symbol: 'AXP', price: 298.10, change: 1.5 },
    { symbol: 'BA', price: 178.42, change: -1.1 },
    { symbol: 'CAT', price: 362.80, change: 0.6 },
    { symbol: 'CRM', price: 332.15, change: 1.9 },
    { symbol: 'CSCO', price: 58.73, change: 0.3 },
    { symbol: 'CVX', price: 155.60, change: -0.7 },
    { symbol: 'DIS', price: 112.88, change: 2.1 },
    { symbol: 'GS', price: 598.45, change: 0.9 },
    { symbol: 'HD', price: 388.20, change: -0.3 },
    { symbol: 'HON', price: 210.35, change: 0.4 },
    { symbol: 'IBM', price: 228.90, change: 1.1 },
    { symbol: 'JNJ', price: 152.44, change: -0.2 },
    { symbol: 'JPM', price: 252.68, change: 1.3 },
    { symbol: 'KO', price: 61.35, change: 0.5 },
    { symbol: 'MCD', price: 295.80, change: -0.6 },
    { symbol: 'MMM', price: 135.22, change: 2.4 },
    { symbol: 'MRK', price: 99.15, change: -1.8 },
    { symbol: 'NKE', price: 71.50, change: -2.3 },
    { symbol: 'PG', price: 168.92, change: 0.7 },
    { symbol: 'TRV', price: 258.40, change: 1.0 },
    { symbol: 'UNH', price: 528.75, change: -0.5 },
    { symbol: 'V', price: 318.60, change: 1.4 },
    { symbol: 'VZ', price: 40.88, change: 0.2 },
    { symbol: 'WBA', price: 10.25, change: -3.5 },
    { symbol: 'WMT', price: 92.44, change: 0.8 },
    { symbol: 'DOW', price: 42.30, change: -1.2 },
    { symbol: 'INTC', price: 20.15, change: -2.8 },
  ],

  // Ground segments: { x, width } - gaps between segments are pits
  // Ground surface is at y=432. Gaps between these = death pits.
  groundSegments: [
    // Section 1: Tutorial (0 - 1500) — long flat ground to learn controls
    { x: 0, width: 1500 },
    // Pit 1 (width=144, from 1500 to 1644)
    // Section 2: Post-tutorial (1644 - 2640)
    { x: 1644, width: 996 },
    // Pit 2 (width=144, from 2640 to 2784)
    // Section 3: Mid-level (2784 - 3600)
    { x: 2784, width: 816 },
    // Pit 3 (width=192, from 3600 to 3792)
    // Section 4: Challenge area (3792 - 5100)
    { x: 3792, width: 1308 },
    // Pit 4 (width=144)
    // Section 5: Double pit area
    { x: 5244, width: 480 },
    // Pit 5 (width=192)
    { x: 5916, width: 576 },
    // Pit 6 (width=144)
    // Section 6: Peak difficulty (6636 - 7500)
    { x: 6636, width: 864 },
    // Pit 7 (width=192)
    // Section 7: Victory run (7692 - 9600)
    { x: 7692, width: 1908 },
  ],

  // Floating platforms: above ground, player can jump up to them
  // These should NOT block the ground-level path
  platforms: [
    // == TUTORIAL AREA (0-1500) ==
    // Elevated platforms to teach jumping — off to the side of the main path
    { x: 460, y: 340, w: 144, h: 16, type: 'desk' },
    { x: 668, y: 290, w: 144, h: 16, type: 'desk' },
    { x: 880, y: 240, w: 96, h: 16, type: 'ledge' },
    { x: 1150, y: 310, w: 144, h: 16, type: 'desk' },
    { x: 650, y: 380, w: 120, h: 16, type: 'ledge' },  // NEW: extra platform for variety

    // == OVER PIT 1 ==
    // Stepping stone over the pit
    { x: 1520, y: 390, w: 96, h: 16, type: 'taxi' },

    // == SECTION 2 (1644-2640) ==
    { x: 2004, y: 340, w: 144, h: 16, type: 'desk' },
    { x: 2198, y: 280, w: 120, h: 16, type: 'ledge' },
    { x: 2300, y: 320, w: 144, h: 16, type: 'desk' },
    { x: 2450, y: 370, w: 96, h: 16, type: 'ledge' },  // NEW: extra platform

    // == OVER PIT 2 ==
    { x: 2660, y: 380, w: 96, h: 16, type: 'taxi' },

    // == SECTION 3 (2784-3600) ==
    { x: 2900, y: 340, w: 120, h: 16, type: 'desk' },
    { x: 3100, y: 280, w: 96, h: 16, type: 'ledge' },
    { x: 3300, y: 230, w: 120, h: 16, type: 'ledge' },
    { x: 3480, y: 320, w: 96, h: 16, type: 'desk' },

    // == OVER PIT 3 ==
    { x: 3630, y: 370, w: 120, h: 16, type: 'taxi' },

    // == SECTION 4: CHALLENGE (3792-5100) ==
    { x: 4210, y: 340, w: 144, h: 16, type: 'desk' },
    { x: 4210, y: 280, w: 120, h: 16, type: 'ledge' },
    { x: 4450, y: 220, w: 144, h: 16, type: 'ledge' },
    { x: 4700, y: 310, w: 120, h: 16, type: 'desk' },
    { x: 4950, y: 260, w: 96, h: 16, type: 'ledge' },

    // == OVER PIT 4 ==
    { x: 5130, y: 380, w: 96, h: 16, type: 'taxi' },

    // == SECTION 5: DOUBLE PIT ==
    { x: 5350, y: 340, w: 96, h: 16, type: 'desk' },
    // Over pit 5
    { x: 5760, y: 370, w: 120, h: 16, type: 'taxi' },
    // Section between pit 5 and 6
    { x: 6050, y: 330, w: 96, h: 16, type: 'desk' },
    // Over pit 6
    { x: 6530, y: 380, w: 96, h: 16, type: 'taxi' },

    // == SECTION 6: PEAK DIFFICULTY ==
    { x: 6750, y: 340, w: 96, h: 16, type: 'ledge' },
    { x: 7048, y: 280, w: 72, h: 16, type: 'ledge' },
    { x: 7150, y: 220, w: 96, h: 16, type: 'ledge' },
    { x: 7350, y: 300, w: 72, h: 16, type: 'desk' },

    // == OVER PIT 7 ==
    { x: 7550, y: 370, w: 120, h: 16, type: 'taxi' },

    // == SECTION 7: VICTORY RUN ==
    { x: 8154, y: 350, w: 192, h: 16, type: 'desk' },
    { x: 8200, y: 300, w: 144, h: 16, type: 'ledge' },
    { x: 8598, y: 340, w: 192, h: 16, type: 'desk' },
    { x: 8800, y: 280, w: 144, h: 16, type: 'ledge' },
    { x: 9198, y: 320, w: 144, h: 16, type: 'desk' },
  ],

  // Question blocks: floating above ground level, player can walk UNDER them
  // Block is 48x48. At y=320, bottom edge = 368. Player head at ~378. Gap = 10px ✓
  // Better: y=300 → bottom=348, gap to head=30px ✓✓
  // Best for walkability: y=280 → bottom=328, gap to head=50px ✓✓✓
  questionBlocks: [
    // Tutorial — floating above the ground path
    { x: 300, y: 280, contents: 'bull' },
    { x: 356, y: 280, contents: 'bull' },
    { x: 412, y: 280, contents: 'bull' },

    // Above elevated platform area
    { x: 620, y: 210, contents: 'greenCandle' },  // One green candle early on

    // Section 2
    { x: 1900, y: 240, contents: 'bull' },
    { x: 1956, y: 240, contents: 'bull' },
    { x: 2150, y: 220, contents: 'bull' },

    // Challenge area
    { x: 4050, y: 240, contents: 'bull' },
    { x: 4106, y: 240, contents: 'bull' },
    { x: 4162, y: 240, contents: 'hodlItem' },  // One HODL headband mid-level

    // Peak difficulty reward
    { x: 7000, y: 220, contents: 'bull' },

    // Victory run
    { x: 8050, y: 250, contents: 'bull' },
    { x: 8106, y: 250, contents: 'bull' },
    { x: 8550, y: 240, contents: 'bull' },
    { x: 9150, y: 220, contents: 'bull' },
  ],

  // Enemies on ground: y should be groundY - enemyHeight
  // BabyBear: 36px tall → y = 432 - 36 = 396
  // GrizzlyBear: 54px tall → y = 432 - 54 = 378
  // FlashTrader: 30px tall → y = 432 - 30 = 402
  // ShortSeller floats: y = 280-320
  enemies: [
    // Tutorial — single easy bear (well after start, gives room to learn)
    { type: 'baby', x: 500, y: 396, patrolLeft: 400, patrolRight: 750 },

    // More bears
    { type: 'baby', x: 950, y: 396, patrolLeft: 850, patrolRight: 1150 },
    { type: 'baby', x: 1300, y: 396, patrolLeft: 1200, patrolRight: 1480 },

    // Section 2
    { type: 'baby', x: 1800, y: 396, patrolLeft: 1650, patrolRight: 2000 },
    { type: 'baby', x: 2200, y: 396, patrolLeft: 2100, patrolRight: 2450 },

    // First grizzly!
    { type: 'grizzly', x: 2500, y: 378, patrolLeft: 2350, patrolRight: 2620 },

    // Section 3
    { type: 'baby', x: 2900, y: 396, patrolLeft: 2800, patrolRight: 3100 },
    { type: 'baby', x: 3350, y: 396, patrolLeft: 3200, patrolRight: 3550 },

    // Challenge area
    { type: 'baby', x: 3900, y: 396, patrolLeft: 3800, patrolRight: 4100 },
    { type: 'baby', x: 4400, y: 396, patrolLeft: 4300, patrolRight: 4600 },
    { type: 'grizzly', x: 4800, y: 378, patrolLeft: 4650, patrolRight: 5050 },

    // NEW: FlashTrader enemies added
    { type: 'flashTrader', x: 2300, y: 402, patrolLeft: 2150, patrolRight: 2450 },
    { type: 'flashTrader', x: 4950, y: 402, patrolLeft: 4800, patrolRight: 5100 },

    // NEW: ShortSeller enemy added
    { type: 'shortSeller', x: 3200, y: 300, patrolLeft: 3000, patrolRight: 3400 },

    // Peak difficulty
    { type: 'baby', x: 6750, y: 396, patrolLeft: 6650, patrolRight: 6950 },
    { type: 'grizzly', x: 7100, y: 378, patrolLeft: 6950, patrolRight: 7350 },
    { type: 'baby', x: 7350, y: 396, patrolLeft: 7250, patrolRight: 7480 },

    // Victory run — lighter
    { type: 'baby', x: 7900, y: 396, patrolLeft: 7700, patrolRight: 8100 },
    { type: 'baby', x: 8400, y: 396, patrolLeft: 8300, patrolRight: 8600 },

    // On elevated platforms (y = platform.y - bearHeight)
    { type: 'baby', x: 620, y: 254, patrolLeft: 600, patrolRight: 744 },
    { type: 'baby', x: 4220, y: 244, patrolLeft: 4200, patrolRight: 4320 },
    { type: 'baby', x: 8220, y: 264, patrolLeft: 8200, patrolRight: 8344 },
  ],

  // Short Squeeze jump pads: { x, y } — placed on ground level (y=432-16=416)
  shortSqueezePads: [
    { x: 1470, y: 416 },   // Before pit 1 — helps clear it
    { x: 3570, y: 416 },   // Before pit 3 — reach high platform
    { x: 5200, y: 416 },   // Before pit 4 area
    { x: 7650, y: 416 },   // Before pit 7 — launch into victory run
  ],

  // Red Candle danger zones: { x, width } — red candles fall periodically in these areas
  redCandleZones: [
    { x: 2900, width: 400 },   // Section 3 danger
    { x: 4600, width: 500 },   // Challenge area danger
    { x: 6700, width: 400 },   // Peak difficulty danger
  ],

  // Dividend bonus coins: rare high-value collectibles (500pts each)
  dividendCoins: [
    { x: 900, y: 200 },    // High above tutorial area — hard to reach
    { x: 3330, y: 190 },   // Above high ledge in section 3
    { x: 4480, y: 180 },   // Above high ledge in challenge area
    { x: 7180, y: 180 },   // Peak difficulty high reward
  ],

  // Collectible bulls: floating at various heights
  // Ground level bulls: y ≈ 400 (above ground, player walks through them)
  // Platform bulls: y = platform.y - 30 or so
  bulls: [
    // Tutorial — line of bulls on ground
    { x: 150, y: 400 }, { x: 185, y: 400 }, { x: 220, y: 400 }, { x: 255, y: 400 },

    // On first desk platform
    { x: 370, y: 308 }, { x: 405, y: 308 }, { x: 440, y: 308 },

    // Arc in air (jumping reward)
    { x: 520, y: 340 }, { x: 560, y: 320 }, { x: 600, y: 300 },
    { x: 640, y: 320 }, { x: 680, y: 340 },

    // High platform reward
    { x: 890, y: 208 }, { x: 930, y: 208 },

    // Before pit 1 — guide to jump
    { x: 1460, y: 360 }, { x: 1500, y: 340 }, { x: 1540, y: 340 }, { x: 1580, y: 360 },

    // Section 2 ground
    { x: 1700, y: 400 }, { x: 1735, y: 400 }, { x: 1770, y: 400 },

    // On section 2 platforms
    { x: 1820, y: 308 }, { x: 1855, y: 308 },
    { x: 2070, y: 248 }, { x: 2110, y: 248 },

    // Before pit 2
    { x: 2610, y: 360 }, { x: 2650, y: 340 }, { x: 2690, y: 340 }, { x: 2730, y: 360 },

    // Section 3
    { x: 2850, y: 400 }, { x: 2885, y: 400 },
    { x: 3120, y: 248 }, { x: 3160, y: 248 },
    { x: 3320, y: 198 }, { x: 3360, y: 198 },

    // Before pit 3
    { x: 3560, y: 360 }, { x: 3600, y: 340 }, { x: 3660, y: 340 }, { x: 3700, y: 360 },

    // Challenge area
    { x: 3850, y: 400 }, { x: 3885, y: 400 }, { x: 3920, y: 400 },
    { x: 4220, y: 248 }, { x: 4260, y: 248 },
    { x: 4470, y: 188 }, { x: 4510, y: 188 }, { x: 4550, y: 188 },
    { x: 4720, y: 278 }, { x: 4760, y: 278 },

    // Before pit 4
    { x: 5100, y: 360 }, { x: 5150, y: 350 }, { x: 5200, y: 360 },

    // Double pit sections
    { x: 5300, y: 400 }, { x: 5380, y: 308 },
    { x: 5780, y: 340 }, { x: 5820, y: 340 },
    { x: 5960, y: 400 }, { x: 6000, y: 400 },

    // Peak difficulty rewards
    { x: 6700, y: 400 }, { x: 6735, y: 400 },
    { x: 6770, y: 308 },
    { x: 6970, y: 248 }, { x: 7010, y: 248 },
    { x: 7170, y: 188 }, { x: 7210, y: 188 }, { x: 7250, y: 188 },

    // Victory run — generous bulls
    { x: 7750, y: 400 }, { x: 7785, y: 400 }, { x: 7820, y: 400 }, { x: 7855, y: 400 },
    { x: 7920, y: 318 }, { x: 7960, y: 318 }, { x: 8000, y: 318 },
    { x: 8220, y: 268 }, { x: 8260, y: 268 }, { x: 8300, y: 268 },
    { x: 8520, y: 308 }, { x: 8560, y: 308 },
    { x: 8820, y: 248 }, { x: 8860, y: 248 },
    { x: 9120, y: 288 }, { x: 9160, y: 288 },

    // Final approach to goal
    { x: 9220, y: 370 }, { x: 9255, y: 360 }, { x: 9280, y: 350 },
  ],
};

const LEVEL_2 = {
  name: "The Trading Floor",
  theme: 'tradingFloor',
  width: 12000,
  playerStart: { x: 96, y: 370 },
  goalPosition: { x: 11700, y: 380 },

  tickerStocks: [
    { symbol: 'AAPL', price: 232.47, change: 1.2 },
    { symbol: 'MSFT', price: 415.30, change: 0.8 },
    { symbol: 'AMGN', price: 313.55, change: -0.4 },
    { symbol: 'AXP', price: 298.10, change: 1.5 },
    { symbol: 'BA', price: 178.42, change: -1.1 },
    { symbol: 'CAT', price: 362.80, change: 0.6 },
    { symbol: 'CRM', price: 332.15, change: 1.9 },
    { symbol: 'CSCO', price: 58.73, change: 0.3 },
    { symbol: 'CVX', price: 155.60, change: -0.7 },
    { symbol: 'DIS', price: 112.88, change: 2.1 },
    { symbol: 'GS', price: 598.45, change: 0.9 },
    { symbol: 'HD', price: 388.20, change: -0.3 },
    { symbol: 'HON', price: 210.35, change: 0.4 },
    { symbol: 'IBM', price: 228.90, change: 1.1 },
    { symbol: 'JNJ', price: 152.44, change: -0.2 },
    { symbol: 'JPM', price: 252.68, change: 1.3 },
    { symbol: 'KO', price: 61.35, change: 0.5 },
    { symbol: 'MCD', price: 295.80, change: -0.6 },
    { symbol: 'MMM', price: 135.22, change: 2.4 },
    { symbol: 'MRK', price: 99.15, change: -1.8 },
    { symbol: 'NKE', price: 71.50, change: -2.3 },
    { symbol: 'PG', price: 168.92, change: 0.7 },
    { symbol: 'TRV', price: 258.40, change: 1.0 },
    { symbol: 'UNH', price: 528.75, change: -0.5 },
    { symbol: 'V', price: 318.60, change: 1.4 },
    { symbol: 'VZ', price: 40.88, change: 0.2 },
    { symbol: 'WBA', price: 10.25, change: -3.5 },
    { symbol: 'WMT', price: 92.44, change: 0.8 },
    { symbol: 'DOW', price: 42.30, change: -1.2 },
    { symbol: 'INTC', price: 20.15, change: -2.8 },
  ],

  // 10 ground segments with wider/more pits — total covering 12000px
  groundSegments: [
    // Section 1: Entrance lobby (0-1200) — learn the new environment
    { x: 0, width: 1200 },
    // Pit 1 (width=168, from 1200 to 1368)
    // Section 2: First trading desks (1368-2280)
    { x: 1368, width: 912 },
    // Pit 2 (width=192, from 2280 to 2472)
    // Section 3: Terminal banks (2472-3360)
    { x: 2472, width: 888 },
    // Pit 3 (width=216, from 3360 to 3576) — wider
    // Section 4: The Pit (trading pit) (3576-4680)
    { x: 3576, width: 1104 },
    // Pit 4 (width=192, from 4680 to 4872)
    // Section 5: Short island (4872-5280)
    { x: 4872, width: 408 },
    // Pit 5 (width=240, from 5280 to 5520) — wide pit
    // Section 6: Recovery zone (5520-6360)
    { x: 5520, width: 840 },
    // Pit 6 (width=168, from 6360 to 6528)
    // Section 7: High-frequency zone (6528-7680)
    { x: 6528, width: 1152 },
    // Pit 7 (width=216, from 7680 to 7896)
    // Section 8: Another short island (7896-8280)
    { x: 7896, width: 384 },
    // Pit 8 (width=192, from 8280 to 8472)
    // Section 9: Executive row (8472-10200)
    { x: 8472, width: 1728 },
    // Pit 9 (width=240, from 10200 to 10440) — widest pit
    // Section 10: Final run to goal (10440-12000)
    { x: 10440, width: 1560 },
  ],

  // ~50 floating platforms using desk, terminal, column types
  platforms: [
    // == ENTRANCE LOBBY (0-1200) ==
    { x: 424, y: 340, w: 144, h: 16, type: 'desk' },
    { x: 550, y: 290, w: 120, h: 16, type: 'terminal' },
    { x: 800, y: 250, w: 96, h: 16, type: 'column' },
    { x: 1050, y: 320, w: 144, h: 16, type: 'desk' },

    // == OVER PIT 1 ==
    { x: 1240, y: 380, w: 96, h: 16, type: 'terminal' },

    // == SECTION 2: FIRST TRADING DESKS (1368-2280) ==
    { x: 1644, y: 340, w: 144, h: 16, type: 'desk' },
    { x: 1720, y: 280, w: 120, h: 16, type: 'terminal' },
    { x: 1950, y: 240, w: 96, h: 16, type: 'column' },
    { x: 2100, y: 310, w: 144, h: 16, type: 'desk' },

    // == OVER PIT 2 ==
    { x: 2330, y: 370, w: 96, h: 16, type: 'terminal' },

    // == SECTION 3: TERMINAL BANKS (2472-3360) ==
    { x: 2688, y: 340, w: 120, h: 16, type: 'terminal' },
    { x: 2888, y: 280, w: 96, h: 16, type: 'column' },
    { x: 2980, y: 230, w: 120, h: 16, type: 'terminal' },
    { x: 3150, y: 300, w: 144, h: 16, type: 'desk' },

    // == OVER PIT 3 (wider) ==
    { x: 3400, y: 360, w: 96, h: 16, type: 'terminal' },
    { x: 3500, y: 320, w: 72, h: 16, type: 'column' },

    // == SECTION 4: THE PIT (3576-4680) ==
    { x: 3700, y: 350, w: 144, h: 16, type: 'desk' },
    { x: 4168, y: 290, w: 120, h: 16, type: 'terminal' },
    { x: 4168, y: 240, w: 96, h: 16, type: 'column' },
    { x: 4280, y: 200, w: 120, h: 16, type: 'terminal' },
    { x: 4450, y: 260, w: 144, h: 16, type: 'desk' },
    { x: 4600, y: 320, w: 96, h: 16, type: 'terminal' },

    // == OVER PIT 4 ==
    { x: 4730, y: 380, w: 96, h: 16, type: 'desk' },

    // == SECTION 5: SHORT ISLAND (4872-5280) ==
    { x: 4950, y: 340, w: 96, h: 16, type: 'terminal' },
    { x: 5100, y: 280, w: 120, h: 16, type: 'column' },

    // == OVER PIT 5 (wide) ==
    { x: 5320, y: 370, w: 72, h: 16, type: 'terminal' },
    { x: 5430, y: 330, w: 72, h: 16, type: 'column' },

    // == SECTION 6: RECOVERY ZONE (5520-6360) ==
    { x: 5650, y: 350, w: 144, h: 16, type: 'desk' },
    { x: 6004, y: 290, w: 120, h: 16, type: 'terminal' },
    { x: 6050, y: 240, w: 96, h: 16, type: 'column' },
    { x: 6200, y: 310, w: 144, h: 16, type: 'desk' },

    // == OVER PIT 6 ==
    { x: 6400, y: 380, w: 96, h: 16, type: 'terminal' },

    // == SECTION 7: HIGH-FREQUENCY ZONE (6528-7680) ==
    { x: 6650, y: 340, w: 96, h: 16, type: 'terminal' },
    { x: 6830, y: 280, w: 72, h: 16, type: 'column' },
    { x: 7038, y: 230, w: 96, h: 16, type: 'terminal' },
    { x: 7130, y: 280, w: 72, h: 16, type: 'column' },
    { x: 7280, y: 340, w: 120, h: 16, type: 'desk' },
    { x: 7518, y: 250, w: 96, h: 16, type: 'terminal' },
    { x: 7580, y: 310, w: 120, h: 16, type: 'desk' },

    // == OVER PIT 7 ==
    { x: 7730, y: 370, w: 96, h: 16, type: 'terminal' },
    { x: 7830, y: 330, w: 72, h: 16, type: 'column' },

    // == SECTION 8: SHORT ISLAND (7896-8280) ==
    { x: 7960, y: 290, w: 120, h: 16, type: 'desk' },
    { x: 8130, y: 340, w: 96, h: 16, type: 'terminal' },

    // == OVER PIT 8 ==
    { x: 8330, y: 380, w: 96, h: 16, type: 'desk' },

    // == SECTION 9: EXECUTIVE ROW (8472-10200) ==
    { x: 8600, y: 340, w: 192, h: 16, type: 'desk' },
    { x: 8900, y: 280, w: 144, h: 16, type: 'terminal' },
    { x: 9230, y: 230, w: 120, h: 16, type: 'column' },
    { x: 9400, y: 290, w: 144, h: 16, type: 'desk' },
    { x: 9700, y: 340, w: 120, h: 16, type: 'terminal' },
    { x: 10018, y: 260, w: 96, h: 16, type: 'column' },

    // == OVER PIT 9 (widest) ==
    { x: 10250, y: 360, w: 96, h: 16, type: 'terminal' },
    { x: 10360, y: 310, w: 72, h: 16, type: 'column' },

    // == SECTION 10: FINAL RUN (10440-12000) ==
    { x: 10600, y: 340, w: 144, h: 16, type: 'desk' },
    { x: 10850, y: 300, w: 120, h: 16, type: 'terminal' },
    { x: 11100, y: 260, w: 144, h: 16, type: 'desk' },
    { x: 11350, y: 320, w: 120, h: 16, type: 'terminal' },
    { x: 11550, y: 280, w: 144, h: 16, type: 'desk' },

    // NEW: Extra platforms for more interesting layout
    { x: 900, y: 370, w: 96, h: 16, type: 'column' },
    { x: 3800, y: 380, w: 120, h: 16, type: 'desk' },
    { x: 9950, y: 370, w: 96, h: 16, type: 'terminal' },
  ],

  // 15 question blocks — mostly bulls, rare power-ups
  questionBlocks: [
    // Entrance area
    { x: 320, y: 240, contents: 'bull' },
    { x: 376, y: 240, contents: 'bull' },

    // Section 2
    { x: 1540, y: 240, contents: 'bull' },
    { x: 1596, y: 240, contents: 'greenCandle' },  // One green candle

    // Section 3
    { x: 2640, y: 240, contents: 'bull' },
    { x: 2840, y: 220, contents: 'bull' },

    // Section 4 — The Pit
    { x: 3940, y: 220, contents: 'bull' },
    { x: 3996, y: 220, contents: 'bull' },
    { x: 4120, y: 180, contents: 'hodlItem' },  // One HODL headband

    // Section 6
    { x: 5900, y: 220, contents: 'bull' },
    { x: 5956, y: 220, contents: 'bull' },

    // Section 7
    { x: 6990, y: 170, contents: 'bull' },
    { x: 7470, y: 180, contents: 'bull' },

    // Executive row
    { x: 9170, y: 170, contents: 'bull' },
    { x: 9970, y: 200, contents: 'bull' },
  ],

  // ~20 enemies — more grizzlies than Level 1
  enemies: [
    // Entrance lobby
    { type: 'baby', x: 400, y: 396, patrolLeft: 300, patrolRight: 600 },
    { type: 'baby', x: 850, y: 396, patrolLeft: 750, patrolRight: 1050 },
    { type: 'grizzly', x: 1100, y: 378, patrolLeft: 1000, patrolRight: 1190 },

    // Section 2
    { type: 'baby', x: 1550, y: 396, patrolLeft: 1380, patrolRight: 1750 },
    { type: 'grizzly', x: 2000, y: 378, patrolLeft: 1850, patrolRight: 2200 },

    // Section 3
    { type: 'baby', x: 2600, y: 396, patrolLeft: 2480, patrolRight: 2800 },
    { type: 'grizzly', x: 3100, y: 378, patrolLeft: 2950, patrolRight: 3300 },
    { type: 'baby', x: 3250, y: 396, patrolLeft: 3150, patrolRight: 3350 },

    // Section 4 — The Pit (toughest)
    { type: 'grizzly', x: 3800, y: 378, patrolLeft: 3600, patrolRight: 4000 },
    { type: 'baby', x: 4200, y: 396, patrolLeft: 4100, patrolRight: 4400 },
    { type: 'grizzly', x: 4500, y: 378, patrolLeft: 4350, patrolRight: 4660 },

    // NEW: FlashTrader enemies added (3 total)
    { type: 'flashTrader', x: 1900, y: 402, patrolLeft: 1750, patrolRight: 2050 },
    { type: 'flashTrader', x: 3650, y: 402, patrolLeft: 3500, patrolRight: 3800 },
    { type: 'flashTrader', x: 7050, y: 402, patrolLeft: 6900, patrolRight: 7200 },

    // NEW: ShortSeller enemies added (2 total)
    { type: 'shortSeller', x: 2800, y: 310, patrolLeft: 2600, patrolRight: 3000 },
    { type: 'shortSeller', x: 6000, y: 280, patrolLeft: 5850, patrolRight: 6150 },

    // Section 6
    { type: 'baby', x: 5700, y: 396, patrolLeft: 5530, patrolRight: 5900 },
    { type: 'grizzly', x: 6100, y: 378, patrolLeft: 5950, patrolRight: 6300 },

    // Section 7 — high frequency
    { type: 'baby', x: 6700, y: 396, patrolLeft: 6540, patrolRight: 6900 },
    { type: 'grizzly', x: 7050, y: 378, patrolLeft: 6900, patrolRight: 7250 },
    { type: 'baby', x: 7400, y: 396, patrolLeft: 7300, patrolRight: 7600 },

    // Executive row
    { type: 'grizzly', x: 8800, y: 378, patrolLeft: 8500, patrolRight: 9050 },
    { type: 'baby', x: 9300, y: 396, patrolLeft: 9150, patrolRight: 9500 },
    { type: 'grizzly', x: 9700, y: 378, patrolLeft: 9500, patrolRight: 9900 },

    // Final run
    { type: 'grizzly', x: 10800, y: 378, patrolLeft: 10500, patrolRight: 11000 },

    // On elevated platforms
    { type: 'baby', x: 1740, y: 244, patrolLeft: 1720, patrolRight: 1840 },
    { type: 'baby', x: 4300, y: 164, patrolLeft: 4280, patrolRight: 4400 },
    { type: 'baby', x: 8920, y: 244, patrolLeft: 8900, patrolRight: 9044 },
  ],

  // 5 short squeeze pads
  shortSqueezePads: [
    { x: 1170, y: 416 },   // Before pit 1
    { x: 3330, y: 416 },   // Before pit 3 (wide)
    { x: 5250, y: 416 },   // Before pit 5 (wide)
    { x: 7650, y: 416 },   // Before pit 7
    { x: 10170, y: 416 },  // Before pit 9 (widest)
  ],

  // 4 red candle zones
  redCandleZones: [
    { x: 2700, width: 400 },   // Terminal banks
    { x: 4000, width: 500 },   // The Pit
    { x: 6700, width: 500 },   // High-frequency zone
    { x: 9500, width: 500 },   // Executive row
  ],

  // 6 dividend coins
  dividendCoins: [
    { x: 820, y: 210 },     // Above column in entrance
    { x: 2000, y: 200 },    // High above section 2
    { x: 4310, y: 160 },    // Very high in The Pit
    { x: 6080, y: 200 },    // Above column in recovery zone
    { x: 7470, y: 210 },    // High-frequency zone reward
    { x: 9980, y: 220 },    // Executive row reward
  ],

  // 90+ bull collectibles
  bulls: [
    // Entrance lobby — welcome line
    { x: 150, y: 400 }, { x: 185, y: 400 }, { x: 220, y: 400 }, { x: 255, y: 400 },

    // On first desk
    { x: 320, y: 308 }, { x: 355, y: 308 }, { x: 390, y: 308 },

    // Arc to terminal
    { x: 460, y: 340 }, { x: 500, y: 310 }, { x: 540, y: 290 }, { x: 580, y: 310 },

    // High column reward
    { x: 810, y: 218 }, { x: 850, y: 218 },

    // Before pit 1
    { x: 1160, y: 360 }, { x: 1200, y: 340 }, { x: 1260, y: 340 }, { x: 1300, y: 360 },

    // Section 2 ground
    { x: 1420, y: 400 }, { x: 1455, y: 400 }, { x: 1490, y: 400 },

    // Section 2 platforms
    { x: 1520, y: 308 }, { x: 1555, y: 308 },
    { x: 1740, y: 248 }, { x: 1780, y: 248 },
    { x: 1970, y: 208 },

    // Before pit 2
    { x: 2240, y: 360 }, { x: 2280, y: 340 }, { x: 2350, y: 340 }, { x: 2390, y: 360 },

    // Section 3
    { x: 2530, y: 400 }, { x: 2565, y: 400 },
    { x: 2620, y: 308 }, { x: 2660, y: 308 },
    { x: 2820, y: 248 }, { x: 2860, y: 248 },
    { x: 3000, y: 198 }, { x: 3040, y: 198 },

    // Before pit 3
    { x: 3320, y: 360 }, { x: 3360, y: 340 }, { x: 3420, y: 320 }, { x: 3520, y: 300 },

    // Section 4 — The Pit
    { x: 3640, y: 400 }, { x: 3675, y: 400 },
    { x: 3720, y: 318 }, { x: 3760, y: 318 },
    { x: 3940, y: 258 }, { x: 3980, y: 258 },
    { x: 4120, y: 208 }, { x: 4160, y: 208 },
    { x: 4300, y: 168 }, { x: 4340, y: 168 },
    { x: 4470, y: 228 }, { x: 4510, y: 228 },

    // Before pit 4
    { x: 4650, y: 360 }, { x: 4700, y: 350 }, { x: 4750, y: 360 },

    // Section 5 island
    { x: 4920, y: 400 }, { x: 4970, y: 308 }, { x: 5010, y: 308 },
    { x: 5120, y: 248 }, { x: 5160, y: 248 },

    // Over pit 5
    { x: 5340, y: 338 }, { x: 5450, y: 298 },

    // Section 6
    { x: 5580, y: 400 }, { x: 5615, y: 400 },
    { x: 5670, y: 318 }, { x: 5710, y: 318 },
    { x: 5900, y: 258 }, { x: 5940, y: 258 },
    { x: 6070, y: 208 }, { x: 6110, y: 208 },

    // Before pit 6
    { x: 6330, y: 360 }, { x: 6370, y: 340 }, { x: 6420, y: 340 },

    // Section 7 — HFT
    { x: 6590, y: 400 }, { x: 6625, y: 400 },
    { x: 6670, y: 308 }, { x: 6710, y: 308 },
    { x: 6850, y: 248 },
    { x: 6990, y: 198 }, { x: 7030, y: 198 },
    { x: 7150, y: 248 },
    { x: 7300, y: 308 }, { x: 7340, y: 308 },
    { x: 7470, y: 218 },
    { x: 7600, y: 278 }, { x: 7640, y: 278 },

    // Over pit 7
    { x: 7750, y: 338 }, { x: 7850, y: 298 },

    // Section 8 island
    { x: 7920, y: 400 }, { x: 7980, y: 258 },

    // Section 9 — Executive row
    { x: 8530, y: 400 }, { x: 8565, y: 400 }, { x: 8600, y: 400 },
    { x: 8620, y: 308 }, { x: 8660, y: 308 }, { x: 8700, y: 308 },
    { x: 8920, y: 248 }, { x: 8960, y: 248 },
    { x: 9170, y: 198 }, { x: 9210, y: 198 },
    { x: 9420, y: 258 }, { x: 9460, y: 258 },
    { x: 9720, y: 308 }, { x: 9760, y: 308 },
    { x: 9970, y: 228 },

    // Over pit 9
    { x: 10270, y: 328 }, { x: 10380, y: 278 },

    // Section 10 — final run
    { x: 10500, y: 400 }, { x: 10535, y: 400 }, { x: 10570, y: 400 },
    { x: 10620, y: 308 }, { x: 10660, y: 308 },
    { x: 10870, y: 268 }, { x: 10910, y: 268 },
    { x: 11120, y: 228 }, { x: 11160, y: 228 },
    { x: 11370, y: 288 }, { x: 11410, y: 288 },
    { x: 11570, y: 248 }, { x: 11610, y: 248 },

    // Final approach
    { x: 11650, y: 360 }, { x: 11680, y: 350 },
  ],

  // 4 moving platforms
  movingPlatforms: [
    { x: 3000, y: 350, w: 96, h: 16, type: 'terminal', speed: 50, waypoints: [{ x: 3000, y: 350 }, { x: 3000, y: 200 }] },
    { x: 5400, y: 350, w: 96, h: 16, type: 'desk', speed: 60, waypoints: [{ x: 5350, y: 350 }, { x: 5480, y: 250 }] },
    { x: 7200, y: 300, w: 96, h: 16, type: 'terminal', speed: 70, waypoints: [{ x: 7100, y: 300 }, { x: 7300, y: 300 }] },
    { x: 10300, y: 380, w: 120, h: 16, type: 'desk', speed: 50, waypoints: [{ x: 10250, y: 380 }, { x: 10250, y: 240 }] },
  ],

  // 2 market crash zones
  marketCrashZones: [
    { x: 4000 },
    { x: 8000 },
  ],
};

const LEVEL_3 = {
  name: "The Crypto Mines",
  theme: 'cryptoMines',
  width: 14400,
  playerStart: { x: 96, y: 370 },
  goalPosition: { x: 14100, y: 380 },

  tickerStocks: [
    { symbol: 'AAPL', price: 232.47, change: 1.2 },
    { symbol: 'MSFT', price: 415.30, change: 0.8 },
    { symbol: 'AMGN', price: 313.55, change: -0.4 },
    { symbol: 'AXP', price: 298.10, change: 1.5 },
    { symbol: 'BA', price: 178.42, change: -1.1 },
    { symbol: 'CAT', price: 362.80, change: 0.6 },
    { symbol: 'CRM', price: 332.15, change: 1.9 },
    { symbol: 'CSCO', price: 58.73, change: 0.3 },
    { symbol: 'CVX', price: 155.60, change: -0.7 },
    { symbol: 'DIS', price: 112.88, change: 2.1 },
    { symbol: 'GS', price: 598.45, change: 0.9 },
    { symbol: 'HD', price: 388.20, change: -0.3 },
    { symbol: 'HON', price: 210.35, change: 0.4 },
    { symbol: 'IBM', price: 228.90, change: 1.1 },
    { symbol: 'JNJ', price: 152.44, change: -0.2 },
    { symbol: 'JPM', price: 252.68, change: 1.3 },
    { symbol: 'KO', price: 61.35, change: 0.5 },
    { symbol: 'MCD', price: 295.80, change: -0.6 },
    { symbol: 'MMM', price: 135.22, change: 2.4 },
    { symbol: 'MRK', price: 99.15, change: -1.8 },
    { symbol: 'NKE', price: 71.50, change: -2.3 },
    { symbol: 'PG', price: 168.92, change: 0.7 },
    { symbol: 'TRV', price: 258.40, change: 1.0 },
    { symbol: 'UNH', price: 528.75, change: -0.5 },
    { symbol: 'V', price: 318.60, change: 1.4 },
    { symbol: 'VZ', price: 40.88, change: 0.2 },
    { symbol: 'WBA', price: 10.25, change: -3.5 },
    { symbol: 'WMT', price: 92.44, change: 0.8 },
    { symbol: 'DOW', price: 42.30, change: -1.2 },
    { symbol: 'INTC', price: 20.15, change: -2.8 },
  ],

  // 12 ground segments with many pits — total covering 14400px
  groundSegments: [
    // Section 1: Mine entrance (0-1080)
    { x: 0, width: 1080 },
    // Pit 1 (width=168)
    // Section 2: First tunnels (1248-2040)
    { x: 1248, width: 792 },
    // Pit 2 (width=216)
    // Section 3: Server farms (2256-3000)
    { x: 2256, width: 744 },
    // Pit 3 (width=240 — wide)
    // Section 4: Crystal cavern (3240-4200)
    { x: 3240, width: 960 },
    // Pit 4 (width=192)
    // Section 5: Narrow bridge (4392-4680)
    { x: 4392, width: 288 },
    // Pit 5 (width=264 — very wide)
    // Section 6: Hash mines (4944-5760)
    { x: 4944, width: 816 },
    // Pit 6 (width=216)
    // Section 7: Neon corridor (5976-6960)
    { x: 5976, width: 984 },
    // Pit 7 (width=240)
    // Section 8: Short ledge (7200-7500)
    { x: 7200, width: 300 },
    // Pit 8 (width=264 — very wide)
    // Section 9: Blockchain bridge (7764-8760)
    { x: 7764, width: 996 },
    // Pit 9 (width=192)
    // Section 10: Deep mines (8952-10800)
    { x: 8952, width: 1848 },
    // Pit 10 (width=240)
    // Section 11: Pre-boss gauntlet (11040-12600)
    { x: 11040, width: 1560 },
    // Pit 11 (width=200)
    // Section 12: Boss arena + goal (12800-14400)
    { x: 12800, width: 1600 },
  ],

  // ~60 platforms using ledge, server, crystal types
  platforms: [
    // == MINE ENTRANCE (0-1080) ==
    { x: 404, y: 340, w: 120, h: 16, type: 'server' },
    { x: 480, y: 290, w: 96, h: 16, type: 'crystal' },
    { x: 700, y: 250, w: 72, h: 16, type: 'ledge' },
    { x: 900, y: 320, w: 120, h: 16, type: 'server' },

    // == OVER PIT 1 ==
    { x: 1110, y: 380, w: 96, h: 16, type: 'crystal' },

    // == SECTION 2: TUNNELS (1248-2040) ==
    { x: 1448, y: 340, w: 120, h: 16, type: 'server' },
    { x: 1628, y: 280, w: 96, h: 16, type: 'crystal' },
    { x: 1720, y: 230, w: 72, h: 16, type: 'ledge' },
    { x: 1900, y: 300, w: 120, h: 16, type: 'server' },

    // == OVER PIT 2 ==
    { x: 2090, y: 370, w: 72, h: 16, type: 'crystal' },
    { x: 2180, y: 320, w: 72, h: 16, type: 'ledge' },

    // == SECTION 3: SERVER FARMS (2256-3000) ==
    { x: 2380, y: 340, w: 96, h: 16, type: 'server' },
    { x: 2608, y: 270, w: 72, h: 16, type: 'crystal' },
    { x: 2748, y: 220, w: 96, h: 16, type: 'ledge' },
    { x: 2850, y: 300, w: 120, h: 16, type: 'server' },

    // == OVER PIT 3 (wide) ==
    { x: 3040, y: 370, w: 72, h: 16, type: 'crystal' },
    { x: 3130, y: 320, w: 72, h: 16, type: 'ledge' },

    // == SECTION 4: CRYSTAL CAVERN (3240-4200) ==
    { x: 3380, y: 340, w: 120, h: 16, type: 'crystal' },
    { x: 3628, y: 280, w: 96, h: 16, type: 'server' },
    { x: 3800, y: 230, w: 72, h: 16, type: 'crystal' },
    { x: 3948, y: 200, w: 96, h: 16, type: 'ledge' },
    { x: 4050, y: 260, w: 120, h: 16, type: 'crystal' },

    // == OVER PIT 4 ==
    { x: 4250, y: 380, w: 96, h: 16, type: 'server' },

    // == SECTION 5: NARROW BRIDGE (4392-4680) ==
    { x: 4450, y: 330, w: 72, h: 16, type: 'crystal' },
    { x: 4580, y: 280, w: 72, h: 16, type: 'ledge' },

    // == OVER PIT 5 (very wide) ==
    { x: 4720, y: 370, w: 72, h: 16, type: 'crystal' },
    { x: 4820, y: 320, w: 72, h: 16, type: 'ledge' },
    { x: 4900, y: 380, w: 72, h: 16, type: 'crystal' },

    // == SECTION 6: HASH MINES (4944-5760) ==
    { x: 5080, y: 340, w: 96, h: 16, type: 'server' },
    { x: 5318, y: 280, w: 72, h: 16, type: 'crystal' },
    { x: 5468, y: 230, w: 96, h: 16, type: 'ledge' },
    { x: 5570, y: 300, w: 120, h: 16, type: 'server' },

    // == OVER PIT 6 ==
    { x: 5810, y: 370, w: 72, h: 16, type: 'crystal' },
    { x: 5910, y: 320, w: 72, h: 16, type: 'ledge' },

    // == SECTION 7: NEON CORRIDOR (5976-6960) ==
    { x: 6100, y: 340, w: 96, h: 16, type: 'server' },
    { x: 6328, y: 280, w: 72, h: 16, type: 'crystal' },
    { x: 6480, y: 230, w: 72, h: 16, type: 'ledge' },
    { x: 6540, y: 280, w: 96, h: 16, type: 'crystal' },
    { x: 6700, y: 340, w: 72, h: 16, type: 'server' },
    { x: 6850, y: 260, w: 96, h: 16, type: 'crystal' },

    // == OVER PIT 7 (wide) ==
    { x: 7010, y: 370, w: 72, h: 16, type: 'crystal' },
    { x: 7100, y: 320, w: 72, h: 16, type: 'ledge' },

    // == SECTION 8: SHORT LEDGE (7200-7500) ==
    { x: 7280, y: 300, w: 96, h: 16, type: 'server' },
    { x: 7420, y: 340, w: 72, h: 16, type: 'crystal' },

    // == OVER PIT 8 (very wide) ==
    { x: 7550, y: 370, w: 72, h: 16, type: 'crystal' },
    { x: 7640, y: 310, w: 72, h: 16, type: 'ledge' },
    { x: 7720, y: 360, w: 72, h: 16, type: 'crystal' },

    // == SECTION 9: BLOCKCHAIN BRIDGE (7764-8760) ==
    { x: 7900, y: 340, w: 120, h: 16, type: 'server' },
    { x: 8168, y: 280, w: 96, h: 16, type: 'crystal' },
    { x: 8380, y: 230, w: 72, h: 16, type: 'ledge' },
    { x: 8500, y: 290, w: 120, h: 16, type: 'server' },
    { x: 8680, y: 340, w: 96, h: 16, type: 'crystal' },

    // == OVER PIT 9 ==
    { x: 8810, y: 380, w: 96, h: 16, type: 'server' },

    // == SECTION 10: DEEP MINES (8952-10800) ==
    { x: 9100, y: 340, w: 120, h: 16, type: 'server' },
    { x: 9418, y: 280, w: 96, h: 16, type: 'crystal' },
    { x: 9618, y: 230, w: 72, h: 16, type: 'ledge' },
    { x: 9750, y: 280, w: 96, h: 16, type: 'crystal' },
    { x: 9950, y: 340, w: 120, h: 16, type: 'server' },
    { x: 10200, y: 260, w: 72, h: 16, type: 'crystal' },
    { x: 10400, y: 300, w: 96, h: 16, type: 'server' },
    { x: 10600, y: 250, w: 72, h: 16, type: 'ledge' },

    // == OVER PIT 10 ==
    { x: 10850, y: 370, w: 72, h: 16, type: 'crystal' },
    { x: 10950, y: 320, w: 72, h: 16, type: 'ledge' },

    // == SECTION 11: PRE-BOSS GAUNTLET (11040-12600) ==
    { x: 11180, y: 340, w: 96, h: 16, type: 'server' },
    { x: 11350, y: 280, w: 72, h: 16, type: 'crystal' },
    { x: 11568, y: 230, w: 72, h: 16, type: 'ledge' },
    { x: 11650, y: 280, w: 96, h: 16, type: 'crystal' },
    { x: 11800, y: 340, w: 120, h: 16, type: 'server' },
    { x: 12000, y: 260, w: 72, h: 16, type: 'crystal' },
    { x: 12200, y: 300, w: 96, h: 16, type: 'server' },
    { x: 12400, y: 340, w: 120, h: 16, type: 'crystal' },

    // NEW: Extra platforms for more interesting platforming
    { x: 700, y: 380, w: 96, h: 16, type: 'ledge' },
    { x: 3500, y: 370, w: 96, h: 16, type: 'server' },
    { x: 6350, y: 370, w: 96, h: 16, type: 'crystal' },
  ],

  // 18 question blocks — mostly bulls, rare power-ups
  questionBlocks: [
    // Mine entrance
    { x: 300, y: 240, contents: 'bull' },
    { x: 356, y: 240, contents: 'bull' },

    // Tunnels
    { x: 1400, y: 240, contents: 'bull' },
    { x: 1580, y: 220, contents: 'bull' },

    // Server farms
    { x: 2560, y: 220, contents: 'bull' },
    { x: 2700, y: 170, contents: 'greenCandle' },  // One green candle

    // Crystal cavern
    { x: 3580, y: 220, contents: 'bull' },
    { x: 3740, y: 180, contents: 'bull' },
    { x: 3900, y: 150, contents: 'bull' },

    // Hash mines
    { x: 5270, y: 220, contents: 'bull' },
    { x: 5420, y: 180, contents: 'hodlItem' },  // One HODL headband

    // Neon corridor
    { x: 6280, y: 220, contents: 'bull' },
    { x: 6420, y: 180, contents: 'bull' },

    // Blockchain bridge
    { x: 8120, y: 220, contents: 'bull' },
    { x: 8320, y: 180, contents: 'bull' },

    // Deep mines
    { x: 9370, y: 220, contents: 'bull' },
    { x: 9570, y: 180, contents: 'bull' },

    // Pre-boss gauntlet
    { x: 11520, y: 180, contents: 'greenCandle' },  // One more green candle before boss
  ],

  // ~25 enemies — lots of grizzlies
  enemies: [
    // Mine entrance
    { type: 'baby', x: 350, y: 396, patrolLeft: 250, patrolRight: 550 },
    { type: 'grizzly', x: 750, y: 378, patrolLeft: 600, patrolRight: 950 },

    // Tunnels
    { type: 'grizzly', x: 1400, y: 378, patrolLeft: 1260, patrolRight: 1600 },
    { type: 'baby', x: 1750, y: 396, patrolLeft: 1650, patrolRight: 1900 },
    { type: 'grizzly', x: 1950, y: 378, patrolLeft: 1850, patrolRight: 2030 },

    // Server farms
    { type: 'grizzly', x: 2500, y: 378, patrolLeft: 2270, patrolRight: 2700 },
    { type: 'baby', x: 2850, y: 396, patrolLeft: 2750, patrolRight: 2990 },

    // Crystal cavern
    { type: 'grizzly', x: 3450, y: 378, patrolLeft: 3250, patrolRight: 3650 },
    { type: 'baby', x: 3800, y: 396, patrolLeft: 3700, patrolRight: 3950 },
    { type: 'grizzly', x: 4100, y: 378, patrolLeft: 3950, patrolRight: 4190 },

    // NEW: FlashTrader enemies added (3 total)
    { type: 'flashTrader', x: 2050, y: 402, patrolLeft: 1900, patrolRight: 2200 },
    { type: 'flashTrader', x: 4950, y: 402, patrolLeft: 4800, patrolRight: 5150 },
    { type: 'flashTrader', x: 7300, y: 402, patrolLeft: 7150, patrolRight: 7450 },

    // NEW: ShortSeller enemies added (2-3 total)
    { type: 'shortSeller', x: 3000, y: 310, patrolLeft: 2800, patrolRight: 3200 },
    { type: 'shortSeller', x: 5500, y: 290, patrolLeft: 5350, patrolRight: 5700 },
    { type: 'shortSeller', x: 8200, y: 320, patrolLeft: 8000, patrolRight: 8400 },

    // Hash mines
    { type: 'grizzly', x: 5150, y: 378, patrolLeft: 4950, patrolRight: 5350 },
    { type: 'baby', x: 5500, y: 396, patrolLeft: 5400, patrolRight: 5700 },
    { type: 'grizzly', x: 5700, y: 378, patrolLeft: 5550, patrolRight: 5750 },

    // Neon corridor
    { type: 'grizzly', x: 6200, y: 378, patrolLeft: 5990, patrolRight: 6400 },
    { type: 'baby', x: 6550, y: 396, patrolLeft: 6450, patrolRight: 6700 },
    { type: 'grizzly', x: 6850, y: 378, patrolLeft: 6700, patrolRight: 6950 },

    // Blockchain bridge
    { type: 'grizzly', x: 8000, y: 378, patrolLeft: 7780, patrolRight: 8200 },
    { type: 'baby', x: 8400, y: 396, patrolLeft: 8300, patrolRight: 8550 },
    { type: 'grizzly', x: 8700, y: 378, patrolLeft: 8550, patrolRight: 8750 },

    // Deep mines
    { type: 'grizzly', x: 9300, y: 378, patrolLeft: 8960, patrolRight: 9500 },
    { type: 'baby', x: 9800, y: 396, patrolLeft: 9700, patrolRight: 10000 },
    { type: 'grizzly', x: 10300, y: 378, patrolLeft: 10100, patrolRight: 10500 },
    { type: 'grizzly', x: 10700, y: 378, patrolLeft: 10500, patrolRight: 10790 },

    // Pre-boss gauntlet
    { type: 'grizzly', x: 11300, y: 378, patrolLeft: 11050, patrolRight: 11500 },
    { type: 'grizzly', x: 11700, y: 378, patrolLeft: 11550, patrolRight: 11900 },
    { type: 'baby', x: 12100, y: 396, patrolLeft: 12000, patrolRight: 12300 },
    { type: 'grizzly', x: 12450, y: 378, patrolLeft: 12300, patrolRight: 12590 },

    // On elevated platforms
    { type: 'baby', x: 1580, y: 244, patrolLeft: 1560, patrolRight: 1656 },
    { type: 'baby', x: 3740, y: 194, patrolLeft: 3720, patrolRight: 3792 },
    { type: 'baby', x: 6280, y: 244, patrolLeft: 6260, patrolRight: 6332 },
  ],

  // 6 short squeeze pads
  shortSqueezePads: [
    { x: 1050, y: 416 },    // Before pit 1
    { x: 2970, y: 416 },    // Before pit 3 (wide)
    { x: 4650, y: 416 },    // Before pit 5 (very wide)
    { x: 6930, y: 416 },    // Before pit 7 (wide)
    { x: 10770, y: 416 },   // Before pit 10
    { x: 12570, y: 416 },   // Before pit 11
  ],

  // 5 red candle zones
  redCandleZones: [
    { x: 2400, width: 400 },   // Server farms
    { x: 3600, width: 500 },   // Crystal cavern
    { x: 5200, width: 500 },   // Hash mines
    { x: 6300, width: 500 },   // Neon corridor
    { x: 9400, width: 600 },   // Deep mines
  ],

  // 8 dividend coins
  dividendCoins: [
    { x: 720, y: 210 },     // Mine entrance high area
    { x: 1740, y: 190 },    // Above ledge in tunnels
    { x: 2700, y: 180 },    // Above ledge in server farms
    { x: 3900, y: 160 },    // Above high ledge in crystal cavern
    { x: 5420, y: 190 },    // Hash mines high
    { x: 6420, y: 190 },    // Neon corridor high
    { x: 8320, y: 190 },    // Blockchain bridge high
    { x: 10220, y: 220 },   // Deep mines
  ],

  // 100+ bulls
  bulls: [
    // Mine entrance — opening line
    { x: 150, y: 400 }, { x: 185, y: 400 }, { x: 220, y: 400 },

    // On server platform
    { x: 300, y: 308 }, { x: 340, y: 308 },

    // Crystal arc
    { x: 420, y: 330 }, { x: 460, y: 300 }, { x: 500, y: 280 }, { x: 540, y: 300 },

    // High ledge
    { x: 710, y: 218 }, { x: 750, y: 218 },

    // Ground near pit 1
    { x: 960, y: 400 }, { x: 1000, y: 400 },
    { x: 1050, y: 360 }, { x: 1090, y: 340 }, { x: 1130, y: 340 },

    // Section 2 ground
    { x: 1300, y: 400 }, { x: 1335, y: 400 },
    { x: 1400, y: 308 }, { x: 1440, y: 308 },
    { x: 1580, y: 248 }, { x: 1620, y: 248 },
    { x: 1740, y: 198 },

    // Over pit 2
    { x: 2110, y: 338 }, { x: 2200, y: 288 },

    // Section 3
    { x: 2310, y: 400 }, { x: 2345, y: 400 },
    { x: 2400, y: 308 }, { x: 2440, y: 308 },
    { x: 2560, y: 238 }, { x: 2600, y: 238 },
    { x: 2700, y: 188 }, { x: 2740, y: 188 },

    // Over pit 3
    { x: 3060, y: 338 }, { x: 3150, y: 288 },

    // Section 4 — Crystal cavern
    { x: 3300, y: 400 }, { x: 3335, y: 400 },
    { x: 3400, y: 308 }, { x: 3440, y: 308 },
    { x: 3580, y: 248 }, { x: 3620, y: 248 },
    { x: 3740, y: 198 }, { x: 3780, y: 198 },
    { x: 3900, y: 168 }, { x: 3940, y: 168 },
    { x: 4070, y: 228 }, { x: 4110, y: 228 },

    // Over pit 4
    { x: 4270, y: 348 },

    // Section 5 narrow
    { x: 4430, y: 400 },
    { x: 4470, y: 298 }, { x: 4600, y: 248 },

    // Over pit 5
    { x: 4740, y: 338 }, { x: 4840, y: 288 }, { x: 4920, y: 348 },

    // Section 6 — Hash mines
    { x: 5000, y: 400 }, { x: 5035, y: 400 },
    { x: 5100, y: 308 }, { x: 5140, y: 308 },
    { x: 5270, y: 248 }, { x: 5310, y: 248 },
    { x: 5420, y: 198 }, { x: 5460, y: 198 },
    { x: 5590, y: 268 }, { x: 5630, y: 268 },

    // Over pit 6
    { x: 5830, y: 338 }, { x: 5930, y: 288 },

    // Section 7 — Neon corridor
    { x: 6030, y: 400 }, { x: 6065, y: 400 },
    { x: 6120, y: 308 }, { x: 6160, y: 308 },
    { x: 6280, y: 248 }, { x: 6320, y: 248 },
    { x: 6420, y: 198 }, { x: 6460, y: 198 },
    { x: 6560, y: 248 },
    { x: 6720, y: 308 },
    { x: 6870, y: 228 }, { x: 6910, y: 228 },

    // Over pit 7
    { x: 7030, y: 338 }, { x: 7120, y: 288 },

    // Section 8 short
    { x: 7250, y: 400 },
    { x: 7300, y: 268 }, { x: 7440, y: 308 },

    // Over pit 8
    { x: 7570, y: 338 }, { x: 7660, y: 278 }, { x: 7740, y: 328 },

    // Section 9 — Blockchain
    { x: 7820, y: 400 }, { x: 7855, y: 400 },
    { x: 7920, y: 308 }, { x: 7960, y: 308 },
    { x: 8120, y: 248 }, { x: 8160, y: 248 },
    { x: 8320, y: 198 }, { x: 8360, y: 198 },
    { x: 8520, y: 258 }, { x: 8560, y: 258 },
    { x: 8700, y: 308 },

    // Over pit 9
    { x: 8830, y: 348 },

    // Section 10 — Deep mines
    { x: 9010, y: 400 }, { x: 9045, y: 400 }, { x: 9080, y: 400 },
    { x: 9120, y: 308 }, { x: 9160, y: 308 },
    { x: 9370, y: 248 }, { x: 9410, y: 248 },
    { x: 9570, y: 198 }, { x: 9610, y: 198 },
    { x: 9770, y: 248 }, { x: 9810, y: 248 },
    { x: 9970, y: 308 }, { x: 10010, y: 308 },
    { x: 10220, y: 228 }, { x: 10260, y: 228 },
    { x: 10420, y: 268 }, { x: 10460, y: 268 },
    { x: 10620, y: 218 }, { x: 10660, y: 218 },

    // Over pit 10
    { x: 10870, y: 338 }, { x: 10970, y: 288 },

    // Section 11 — Pre-boss gauntlet
    { x: 11100, y: 400 }, { x: 11135, y: 400 },
    { x: 11200, y: 308 }, { x: 11240, y: 308 },
    { x: 11370, y: 248 }, { x: 11410, y: 248 },
    { x: 11520, y: 198 }, { x: 11560, y: 198 },
    { x: 11670, y: 248 },
    { x: 11820, y: 308 }, { x: 11860, y: 308 },
    { x: 12020, y: 228 }, { x: 12060, y: 228 },
    { x: 12220, y: 268 },
    { x: 12420, y: 308 },

    // Section 12 — Boss arena approach
    { x: 12850, y: 400 }, { x: 12885, y: 400 }, { x: 12920, y: 400 },
    { x: 12955, y: 400 }, { x: 12990, y: 400 },
  ],

  // 6 moving platforms
  movingPlatforms: [
    { x: 2700, y: 350, w: 96, h: 16, type: 'crystal', speed: 50, waypoints: [{ x: 2700, y: 350 }, { x: 2700, y: 200 }] },
    { x: 4800, y: 360, w: 96, h: 16, type: 'server', speed: 60, waypoints: [{ x: 4720, y: 360 }, { x: 4900, y: 260 }] },
    { x: 6600, y: 300, w: 96, h: 16, type: 'crystal', speed: 70, waypoints: [{ x: 6500, y: 300 }, { x: 6700, y: 300 }] },
    { x: 7650, y: 370, w: 96, h: 16, type: 'server', speed: 55, waypoints: [{ x: 7560, y: 370 }, { x: 7710, y: 250 }] },
    { x: 10100, y: 300, w: 96, h: 16, type: 'crystal', speed: 65, waypoints: [{ x: 10000, y: 300 }, { x: 10200, y: 300 }] },
    { x: 10900, y: 380, w: 120, h: 16, type: 'server', speed: 50, waypoints: [{ x: 10850, y: 380 }, { x: 10850, y: 240 }] },
  ],

  // 3 market crash zones
  marketCrashZones: [
    { x: 3600 },
    { x: 6500 },
    { x: 10500 },
  ],

  // Boss arena at end of level
  bossArena: { x: 13600, wallLeft: 13600, wallRight: 14200, y: 432 },
};

function loadLevel(levelData) {
  const groundY = 432;
  const groundH = CONFIG.VIRTUAL_HEIGHT - groundY + 200;

  const level = {
    width: levelData.width || 9600,
    height: CONFIG.VIRTUAL_HEIGHT + 200,
    solids: [],
    platforms: [],
    questionBlocks: [],
    enemies: [],
    collectibles: [],
    shortSqueezePads: [],
    movingPlatforms: [],
    marketCrashZones: levelData.marketCrashZones ? levelData.marketCrashZones.map(z => ({ ...z, triggered: false })) : [],
    redCandleZones: levelData.redCandleZones || [],
    redCandleTimer: 0,
    goalPosition: { ...levelData.goalPosition },
    tickerStocks: levelData.tickerStocks,
    name: levelData.name,
    bossArena: levelData.bossArena || null,
    boss: null,
  };

  // Create ground platforms from segments
  for (const seg of levelData.groundSegments) {
    const ground = new Platform(seg.x, groundY, seg.width, groundH, 'ground');
    level.solids.push(ground);
    level.platforms.push(ground);
  }

  // Add floating platforms
  for (const plt of levelData.platforms) {
    const platform = new Platform(plt.x, plt.y, plt.w, plt.h, plt.type);
    level.solids.push(platform);
    level.platforms.push(platform);
  }

  // Add moving platforms
  if (levelData.movingPlatforms) {
    for (const mp of levelData.movingPlatforms) {
      const platform = new MovingPlatform(mp.x, mp.y, mp.w, mp.h, mp.type, mp.waypoints, mp.speed);
      level.movingPlatforms.push(platform);
      level.solids.push(platform); // Also add to solids for collision
    }
  }

  // Add question blocks
  for (const qb of levelData.questionBlocks) {
    const block = new QuestionBlock(qb.x, qb.y, qb.contents);
    level.questionBlocks.push(block);
    level.solids.push(block); // Must be in solids so player can hit from below
  }

  // Add enemies
  for (const e of levelData.enemies) {
    if (e.type === 'baby') {
      level.enemies.push(new BabyBear(e.x, e.y, e.patrolLeft, e.patrolRight));
    } else if (e.type === 'grizzly') {
      level.enemies.push(new GrizzlyBear(e.x, e.y, e.patrolLeft, e.patrolRight));
    } else if (e.type === 'flashTrader') {
      level.enemies.push(new FlashTrader(e.x, e.y, e.patrolLeft, e.patrolRight));
    } else if (e.type === 'shortSeller') {
      level.enemies.push(new ShortSeller(e.x, e.y, e.patrolLeft, e.patrolRight));
    }
  }

  // Add collectible bulls
  for (const b of levelData.bulls) {
    level.collectibles.push(new GoldBull(b.x, b.y));
  }

  // Add dividend coins
  if (levelData.dividendCoins) {
    for (const d of levelData.dividendCoins) {
      level.collectibles.push(new DividendCoin(d.x, d.y));
    }
  }

  // Add short squeeze pads
  if (levelData.shortSqueezePads) {
    for (const pad of levelData.shortSqueezePads) {
      level.shortSqueezePads.push(new ShortSqueezePad(pad.x, pad.y));
    }
  }

  // Spawn boss if bossArena is defined
  if (levelData.bossArena) {
    const arena = levelData.bossArena;
    const bossX = (arena.wallLeft + arena.wallRight) / 2 - 60; // center boss
    const bossY = arena.y - 90; // boss height is 90
    level.boss = new WhaleBoss(bossX, bossY, arena.wallLeft, arena.wallRight);
  }

  return level;
}
  </script>
  <script>
class HUD {
  constructor(tickerStocks) {
    this.tickerStocks = tickerStocks;
    this.tickerOffset = 0;
    this.tickerSpeed = 100;
    this.tickerItemWidth = 220;
  }

  update(dt) {
    this.tickerOffset += this.tickerSpeed * dt;
    const totalWidth = this.tickerStocks.length * this.tickerItemWidth;
    if (this.tickerOffset > totalWidth) {
      this.tickerOffset -= totalWidth;
    }
    // Update flash timers for real-time price updates
    for (const stock of this.tickerStocks) {
      if (stock._flashTimer > 0) {
        stock._flashTimer -= dt;
      }
    }
  }

  render(ctx, player, canvasWidth) {
    // Stock ticker bar at very top
    ctx.fillStyle = CONFIG.COLORS.TICKER_BG;
    ctx.fillRect(0, 0, canvasWidth, 24);

    // Ticker border
    ctx.fillStyle = 'rgba(255,215,0,0.3)';
    ctx.fillRect(0, 23, canvasWidth, 1);

    ctx.font = 'bold 13px monospace';
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'left';

    const totalWidth = this.tickerStocks.length * this.tickerItemWidth;

    // Draw ticker items (doubled for seamless loop)
    for (let pass = 0; pass < 2; pass++) {
      for (let i = 0; i < this.tickerStocks.length; i++) {
        const stock = this.tickerStocks[i];
        let xPos = canvasWidth - this.tickerOffset + i * this.tickerItemWidth + pass * totalWidth;

        if (xPos > canvasWidth + 20 || xPos + this.tickerItemWidth < -20) continue;

        const isUp = stock.change >= 0;
        const arrow = isUp ? '\u25B2' : '\u25BC';

        // Symbol
        ctx.fillStyle = CONFIG.COLORS.WHITE;
        ctx.fillText(stock.symbol, xPos, 12);

        // Price and change — flash on real-time update
        if (stock._flashTimer > 0) {
          const pulse = Math.sin(stock._flashTimer * 10) > 0 ? 1 : 0.6;
          ctx.fillStyle = stock._flash === 'green'
            ? 'rgba(0, 255, 136, ' + pulse + ')'
            : 'rgba(255, 68, 68, ' + pulse + ')';
        } else {
          ctx.fillStyle = isUp ? CONFIG.COLORS.TICKER_GREEN : CONFIG.COLORS.TICKER_RED;
        }
        const priceText = '$' + stock.price.toFixed(2) + ' ' + arrow + Math.abs(stock.change).toFixed(1) + '%';
        ctx.fillText(priceText, xPos + 55, 12);

        // Separator dot
        ctx.fillStyle = '#444';
        ctx.fillText('\u2022', xPos + this.tickerItemWidth - 20, 12);
      }
    }

    // HUD panel - score and stats
    const panelX = 10;
    const panelY = 32;
    const panelW = 200;
    const panelH = 68;

    ctx.fillStyle = CONFIG.COLORS.HUD_BG;
    ctx.fillRect(panelX, panelY, panelW, panelH);
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 1;
    ctx.strokeRect(panelX, panelY, panelW, panelH);

    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';

    // Score
    ctx.fillStyle = CONFIG.COLORS.BULL_GOLD;
    ctx.font = 'bold 15px monospace';
    ctx.fillText('$' + player.score.toLocaleString(), panelX + 8, panelY + 6);

    // Lives
    ctx.fillStyle = CONFIG.COLORS.WHITE;
    ctx.font = '13px monospace';
    let livesText = 'LIVES: ';
    for (let i = 0; i < player.lives; i++) {
      livesText += '\u2665 ';
    }
    ctx.fillText(livesText, panelX + 8, panelY + 26);

    // Bull counter — progress toward Diamond Hands (100 bulls)
    ctx.fillStyle = CONFIG.COLORS.BULL_GOLD;
    ctx.font = '13px monospace';
    const target = CONFIG.BULLS_FOR_DIAMOND_HANDS;
    const barLen = 10;
    const filled = Math.round((player.bullsCollected / target) * barLen);
    const bullBar = '\u25A0'.repeat(filled) + '\u25A1'.repeat(barLen - filled);
    ctx.fillText(bullBar + ' ' + player.bullsCollected + '/' + target, panelX + 8, panelY + 46);

    // Power-up indicators (right side)
    let indicatorY = panelY + 6;

    if (player.hasHeadband) {
      ctx.fillStyle = '#FF4444';
      ctx.font = 'bold 13px monospace';
      ctx.textAlign = 'right';
      ctx.fillText('\u2660 HODL HEADBAND', canvasWidth - 12, indicatorY);
      indicatorY += 18;
    }

    if (player.powered) {
      ctx.fillStyle = CONFIG.COLORS.GREEN_CANDLE;
      ctx.font = 'bold 13px monospace';
      ctx.textAlign = 'right';
      ctx.fillText('\u25B2 POWERED UP', canvasWidth - 12, indicatorY);
      indicatorY += 18;
    }

    if (player.diamondHands) {
      ctx.fillStyle = '#88DDFF';
      ctx.font = 'bold 13px monospace';
      ctx.textAlign = 'right';
      const timeLeft = ' ' + Math.ceil(player.invincibleTimer) + 's';
      ctx.fillText('\u25C6 DIAMOND HANDS' + timeLeft, canvasWidth - 12, indicatorY);
    }
  }

  renderBossHealth(ctx, canvasWidth, boss) {
    if (!boss || !boss.alive) return;
    const barW = 200;
    const barH = 12;
    const barX = (canvasWidth - barW) / 2;
    const barY = 28;

    // Background
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(barX - 2, barY - 2, barW + 4, barH + 4);

    // Health bar
    const healthPct = boss.hp / boss.maxHp;
    const barColor = boss.phase === 3 ? '#FF2222' : boss.phase === 2 ? '#FF8800' : '#FF4444';
    ctx.fillStyle = '#333';
    ctx.fillRect(barX, barY, barW, barH);
    ctx.fillStyle = barColor;
    ctx.fillRect(barX, barY, barW * healthPct, barH);

    // Border
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 1;
    ctx.strokeRect(barX, barY, barW, barH);

    // Label
    ctx.fillStyle = '#FFF';
    ctx.font = 'bold 10px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('THE WHALE', canvasWidth / 2, barY + barH / 2);
  }
}
  </script>
  <script>
// ==========================================
//  Game Integrity - Anti-Cheat Score Verification
// ==========================================
// Tracks gameplay events and generates a server-verifiable proof
// that the score was earned through actual gameplay.
//
// How it works:
// 1. During gameplay, every score-affecting event is logged with a timestamp
// 2. At submission time, the event log is hashed with a server-shared secret
// 3. The server (Supabase RPC) replays the event log to verify:
//    a) The final score matches the sum of events
//    b) The HMAC matches (proving the log wasn't tampered with)
//    c) Timing between events is plausible (not all instant)
//    d) Event types/values match game rules

class GameIntegrity {
  constructor() {
    this.reset();
  }

  reset() {
    this.events = [];
    this.sessionId = this._generateSessionId();
    this.startTime = null;
    this.computedScore = 0;
    this.bullCount = 0;
  }

  start() {
    this.reset();
    this.startTime = Date.now();
    this.events.push({ t: 0, e: 'start', v: 0 });
  }

  // Log a score-affecting event
  // type: 'bull' | 'stomp_baby' | 'stomp_baby_kill' | 'stomp_grizzly' | 'stomp_grizzly_kill' |
  //       'diamond_kill' | 'dividend' | 'time_bonus' | 'boss_hit' | 'boss_kill'
  logEvent(type, value) {
    if (!this.startTime) return;

    const elapsed = Date.now() - this.startTime;
    this.events.push({ t: elapsed, e: type, v: value });
    this.computedScore += value;

    if (type === 'bull') {
      this.bullCount++;
    }
  }

  // Generate the integrity payload for submission
  getPayload(playerName, timeTaken, characterUsed) {
    const finalScore = this.computedScore;
    const eventLog = JSON.stringify(this.events);

    // Create a simple hash of the event log + session data
    // The server will have the same key and re-derive this
    const dataString = `${this.sessionId}|${eventLog}|${finalScore}|${this.bullCount}|${Math.round(timeTaken * 100)}`;
    const hash = this._simpleHash(dataString);

    return {
      session_id: this.sessionId,
      player_name: playerName,
      score: Math.min(finalScore, 49999),
      bulls_collected: Math.min(this.bullCount, 99),
      time_taken: Math.max(timeTaken, 10.1),
      character_used: characterUsed,
      event_log: eventLog,
      event_count: this.events.length,
      integrity_hash: hash,
      client_version: 2
    };
  }

  // Validate that the tracked score matches what the game thinks
  isConsistent(gameScore, gameBulls) {
    return this.computedScore === gameScore && this.bullCount === gameBulls;
  }

  _generateSessionId() {
    const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
    let id = '';
    for (let i = 0; i < 24; i++) {
      id += chars[Math.floor(Math.random() * chars.length)];
    }
    return `gs_${Date.now().toString(36)}_${id}`;
  }

  // Simple deterministic hash (DJB2 variant)
  // Not cryptographically secure, but makes casual forgery much harder.
  // The real security comes from the server validating the event log.
  _simpleHash(str) {
    let h1 = 0xdeadbeef;
    let h2 = 0x41c6ce57;
    for (let i = 0; i < str.length; i++) {
      const ch = str.charCodeAt(i);
      h1 = Math.imul(h1 ^ ch, 2654435761);
      h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507);
    h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909);
    h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507);
    h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909);
    return (4294967296 * (2097151 & h2) + (h1 >>> 0)).toString(36);
  }
}

  </script>
  <script>
// ==========================================
//  Leaderboard - Supabase Integration
// ==========================================
// Handles score submission, leaderboard fetching, and name input UI.
// Fails gracefully — game works fine if Supabase is unreachable.

class Leaderboard {
  constructor(supabaseUrl, supabaseAnonKey) {
    this.supabase = null;
    this.playerName = localStorage.getItem('bullrun_playerName') || null;
    this.submittedThisSession = false;
    this.lastLeaderboard = null;
    this.lastRank = null;

    // Initialize Supabase client if the library loaded
    try {
      if (typeof supabase !== 'undefined' && supabase.createClient) {
        this.supabase = supabase.createClient(supabaseUrl, supabaseAnonKey);
      }
    } catch (e) {
      console.warn('Leaderboard: Supabase client failed to initialize', e);
    }
  }

  isAvailable() {
    return this.supabase !== null;
  }

  hasPlayerName() {
    return this.playerName !== null && this.playerName.length > 0;
  }

  setPlayerName(name) {
    this.playerName = name.trim().substring(0, 16);
    localStorage.setItem('bullrun_playerName', this.playerName);
  }

  async submitScore(score, bullsCollected, timeTaken, characterUsed, integrityPayload) {
    if (!this.isAvailable() || this.submittedThisSession) return null;

    try {
      // Use server-side RPC that validates the event log instead of direct INSERT.
      // This prevents forged scores via raw API calls (the old direct INSERT is
      // now blocked by RLS — see supabase_migration.sql).
      const payload = integrityPayload || {
        player_name: this.playerName,
        score: Math.min(score, 49999),
        bulls_collected: Math.min(bullsCollected, 99),
        time_taken: Math.max(timeTaken, 10.1),
        character_used: characterUsed,
        event_log: '[]',
        event_count: 0,
        integrity_hash: '',
        session_id: '',
        client_version: 2
      };

      // Ensure player name is set from the leaderboard instance
      payload.player_name = this.playerName;

      const { data, error } = await this.supabase
        .rpc('submit_score', {
          p_session_id: payload.session_id,
          p_player_name: payload.player_name,
          p_score: payload.score,
          p_bulls_collected: payload.bulls_collected,
          p_time_taken: payload.time_taken,
          p_character_used: payload.character_used,
          p_event_log: payload.event_log,
          p_event_count: payload.event_count,
          p_integrity_hash: payload.integrity_hash,
          p_client_version: payload.client_version
        });

      if (error) {
        console.warn('Leaderboard: Submit failed', error.message);
        return null;
      }

      this.submittedThisSession = true;

      // Fetch rank + leaderboard after submission
      const [rankResult, lbResult] = await Promise.all([
        this.getPlayerRank(),
        this.getTopScores()
      ]);

      return {
        rank: rankResult ? rankResult.rank : null,
        total: rankResult ? rankResult.total : null,
        leaderboard: lbResult
      };
    } catch (e) {
      console.warn('Leaderboard: Submit error', e);
      return null;
    }
  }

  async getTopScores(limit = 10) {
    if (!this.isAvailable()) return null;

    try {
      const { data, error } = await this.supabase
        .from('scores')
        .select('player_name, score, bulls_collected, time_taken, character_used')
        .order('score', { ascending: false })
        .limit(limit);

      if (error) {
        console.warn('Leaderboard: Fetch failed', error.message);
        return null;
      }

      this.lastLeaderboard = data;
      return data;
    } catch (e) {
      console.warn('Leaderboard: Fetch error', e);
      return null;
    }
  }

  async getPlayerRank() {
    if (!this.isAvailable() || !this.playerName) return null;

    try {
      const { data, error } = await this.supabase
        .rpc('get_player_rank', { p_name: this.playerName });

      if (error) {
        console.warn('Leaderboard: Rank query failed', error.message);
        return null;
      }

      if (data && data.length > 0) {
        this.lastRank = { rank: data[0].rank, total: data[0].total };
        return this.lastRank;
      }
      return null;
    } catch (e) {
      console.warn('Leaderboard: Rank error', e);
      return null;
    }
  }

  resetSession() {
    this.submittedThisSession = false;
    this.lastLeaderboard = null;
    this.lastRank = null;
  }

  // ==========================================
  //  Name Input DOM Overlay
  // ==========================================
  showNameInput(onSubmit, onSkip) {
    // Remove existing overlay if any
    this.hideNameInput();

    const overlay = document.createElement('div');
    overlay.id = 'leaderboard-name-overlay';
    overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;' +
      'display:flex;align-items:center;justify-content:center;' +
      'background:rgba(0,0,0,0.85);z-index:1000;font-family:sans-serif;';

    const box = document.createElement('div');
    box.style.cssText = 'background:#0a0a2e;border:2px solid #FFD700;border-radius:12px;' +
      'padding:24px 32px;text-align:center;max-width:360px;width:90%;';

    const title = document.createElement('div');
    title.textContent = 'SUBMIT YOUR SCORE';
    title.style.cssText = 'color:#FFD700;font-size:20px;font-weight:bold;margin-bottom:16px;';

    const inputField = document.createElement('input');
    inputField.type = 'text';
    inputField.maxLength = 16;
    inputField.placeholder = 'Enter your name';
    inputField.value = this.playerName || '';
    inputField.autocomplete = 'off';
    inputField.style.cssText = 'width:100%;padding:10px 14px;font-size:18px;font-weight:bold;' +
      'background:#1a1a3e;border:2px solid #555;border-radius:8px;color:#fff;' +
      'text-align:center;outline:none;font-family:monospace;box-sizing:border-box;';
    inputField.addEventListener('focus', () => {
      inputField.style.borderColor = '#FFD700';
    });
    inputField.addEventListener('blur', () => {
      inputField.style.borderColor = '#555';
    });
    // Filter out non-alphanumeric (allow spaces)
    inputField.addEventListener('input', () => {
      inputField.value = inputField.value.replace(/[^a-zA-Z0-9 _-]/g, '');
    });

    const btnRow = document.createElement('div');
    btnRow.style.cssText = 'display:flex;gap:12px;margin-top:16px;justify-content:center;';

    const submitBtn = document.createElement('button');
    submitBtn.textContent = 'Submit Score';
    submitBtn.style.cssText = 'padding:10px 24px;font-size:16px;font-weight:bold;' +
      'background:#FFD700;color:#000;border:none;border-radius:8px;cursor:pointer;' +
      'font-family:sans-serif;';
    submitBtn.addEventListener('click', () => {
      const name = inputField.value.trim();
      if (name.length > 0) {
        this.setPlayerName(name);
        this.hideNameInput();
        onSubmit(name);
      } else {
        inputField.style.borderColor = '#FF4444';
        inputField.placeholder = 'Name required!';
      }
    });

    const skipBtn = document.createElement('button');
    skipBtn.textContent = 'Skip';
    skipBtn.style.cssText = 'padding:10px 20px;font-size:14px;' +
      'background:transparent;color:#888;border:1px solid #555;border-radius:8px;' +
      'cursor:pointer;font-family:sans-serif;';
    skipBtn.addEventListener('click', () => {
      this.hideNameInput();
      onSkip();
    });

    // Enter key submits
    inputField.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        submitBtn.click();
      }
    });

    btnRow.appendChild(submitBtn);
    btnRow.appendChild(skipBtn);
    box.appendChild(title);
    box.appendChild(inputField);
    box.appendChild(btnRow);
    overlay.appendChild(box);
    document.body.appendChild(overlay);

    // Focus the input after a short delay (helps mobile keyboards)
    setTimeout(() => inputField.focus(), 100);
  }

  hideNameInput() {
    const existing = document.getElementById('leaderboard-name-overlay');
    if (existing) existing.remove();
  }
}
  </script>
  <script>
class TitleScreen {
  constructor() {
    this.animTime = 0;
    this.selectedCharacter = null;
    this.phase = 'title'; // 'title' -> 'select'
    this.hoverIndex = 0;  // 0=chad, 1=diana
    this.tipIndex = 0;
    this.tips = [
      "Past performance is not indicative of future results",
      "This is not financial advice",
      "Buy low, sell high. Or don't.",
      "Diamond hands are just hands that haven't sold yet",
      "Bears make money, bulls make money, pigs get slaughtered",
      "In this economy?!",
      "Time in the market beats timing the market... unless you fall in a pit",
      "Sir, this is a Wendy's",
      "Stonks only go up (and sometimes down, into pits)",
      "HODL for 5 seconds for a surprise"
    ];
  }

  update(dt, input) {
    this.animTime += dt;
    this.tipIndex = Math.floor(this.animTime / 4) % this.tips.length;

    if (this.phase === 'title') {
      if (input.wasPressed('Enter') || input.wasPressed('Space')) {
        this.phase = 'select';
        this.selectDebounce = 0.3; // prevent instant confirmation on touch
      }
    } else {
      // Debounce prevents the same tap that entered select phase from also confirming
      if (this.selectDebounce > 0) {
        this.selectDebounce -= dt;
        return null;
      }

      if (input.wasPressed('ArrowLeft') || input.wasPressed('KeyA')) {
        this.hoverIndex = 0;
      }
      if (input.wasPressed('ArrowRight') || input.wasPressed('KeyD')) {
        this.hoverIndex = 1;
      }
      if (input.wasPressed('Digit1')) {
        this.hoverIndex = 0;
      }
      if (input.wasPressed('Digit2')) {
        this.hoverIndex = 1;
      }
      if (input.wasPressed('Enter') || input.wasPressed('Space')) {
        this.selectedCharacter = this.hoverIndex === 0 ? 'chad' : 'diana';
        return 'start';
      }
    }
    return null;
  }

  render(ctx, w, h) {
    // Dark background
    const grad = ctx.createLinearGradient(0, 0, 0, h);
    grad.addColorStop(0, '#050515');
    grad.addColorStop(0.5, '#0a0a25');
    grad.addColorStop(1, '#151535');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);

    // City silhouette at bottom
    ctx.fillStyle = '#0a0a1a';
    const buildings = [
      { x: 20, bw: 60, bh: 140 }, { x: 90, bw: 40, bh: 100 },
      { x: 140, bw: 80, bh: 200 }, { x: 230, bw: 50, bh: 120 },
      { x: 290, bw: 70, bh: 180 }, { x: 370, bw: 90, bh: 160 },
      { x: 470, bw: 45, bh: 130 }, { x: 525, bw: 75, bh: 220 },
      { x: 610, bw: 55, bh: 150 }, { x: 675, bw: 85, bh: 190 },
      { x: 770, bw: 60, bh: 140 }, { x: 840, bw: 100, bh: 210 },
    ];
    for (const b of buildings) {
      ctx.fillRect(b.x, h - b.bh, b.bw, b.bh);
      // Scattered windows
      ctx.fillStyle = 'rgba(255,228,181,0.3)';
      for (let r = 0; r < b.bh / 16; r++) {
        for (let c = 0; c < b.bw / 14; c++) {
          if (Math.sin(b.x + r * 7 + c * 13) > 0.2) {
            ctx.fillRect(b.x + 4 + c * 14, h - b.bh + 8 + r * 16, 6, 8);
          }
        }
      }
      ctx.fillStyle = '#0a0a1a';
    }

    // Title: "BULL RUN"
    const titleBounce = Math.sin(this.animTime * 2) * 6;
    const titleY = h * 0.2 + titleBounce;

    // Title shadow
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.font = 'bold 72px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('BULL RUN', w / 2 + 3, titleY + 3);

    // Title gold gradient
    const titleGrad = ctx.createLinearGradient(w / 2 - 150, titleY - 30, w / 2 + 150, titleY + 30);
    titleGrad.addColorStop(0, '#FFD700');
    titleGrad.addColorStop(0.5, '#FFEE88');
    titleGrad.addColorStop(1, '#FFD700');
    ctx.fillStyle = titleGrad;
    ctx.fillText('BULL RUN', w / 2, titleY);

    // Subtitle
    ctx.fillStyle = '#888';
    ctx.font = '18px sans-serif';
    ctx.fillText('A Wall Street Adventure', w / 2, h * 0.3);

    // Bull horns decoration
    ctx.strokeStyle = CONFIG.COLORS.BULL_GOLD;
    ctx.lineWidth = 3;
    // Left horn
    ctx.beginPath();
    ctx.moveTo(w / 2 - 160, titleY);
    ctx.quadraticCurveTo(w / 2 - 180, titleY - 40, w / 2 - 150, titleY - 50);
    ctx.stroke();
    // Right horn
    ctx.beginPath();
    ctx.moveTo(w / 2 + 160, titleY);
    ctx.quadraticCurveTo(w / 2 + 180, titleY - 40, w / 2 + 150, titleY - 50);
    ctx.stroke();

    if (this.phase === 'title') {
      // Blinking prompt
      if (Math.floor(this.animTime * 2) % 2 === 0) {
        ctx.fillStyle = CONFIG.COLORS.WHITE;
        ctx.font = '22px sans-serif';
        const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        ctx.fillText(isMobile ? 'Tap to Start' : 'Press ENTER to Start', w / 2, h * 0.55);
      }

      // Controls hint
      ctx.fillStyle = '#555';
      ctx.font = '14px sans-serif';
      const isMobile2 = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
      if (isMobile2) {
        ctx.fillText('Left side = Move  |  Right side: Tap = Jump, Hold = Crouch + Super Jump', w / 2, h * 0.65);
      } else {
        ctx.fillText('Arrow Keys / WASD to move  |  Space to jump  |  Down to crouch + super jump', w / 2, h * 0.65);
      }
    } else {
      // Character select
      ctx.fillStyle = CONFIG.COLORS.WHITE;
      ctx.font = 'bold 26px sans-serif';
      ctx.fillText('SELECT YOUR INVESTOR', w / 2, h * 0.4);

      // Chad (left)
      const chadX = w * 0.3;
      const dianaX = w * 0.7;
      const charY = h * 0.58;

      // Selection highlight
      const selectedX = this.hoverIndex === 0 ? chadX : dianaX;
      ctx.strokeStyle = CONFIG.COLORS.BULL_GOLD;
      ctx.lineWidth = 3;
      ctx.strokeRect(selectedX - 55, charY - 50, 110, 120);
      ctx.fillStyle = 'rgba(255,215,0,0.08)';
      ctx.fillRect(selectedX - 55, charY - 50, 110, 120);

      // Draw mini characters
      this._drawMiniChad(ctx, chadX - 18, charY - 30);
      this._drawMiniDiana(ctx, dianaX - 18, charY - 30);

      // Names
      ctx.fillStyle = this.hoverIndex === 0 ? CONFIG.COLORS.BULL_GOLD : '#AAA';
      ctx.font = '16px sans-serif';
      ctx.fillText('Chad Stocksworth', chadX, charY + 50);
      ctx.fillStyle = '#777';
      ctx.font = '12px sans-serif';
      ctx.fillText('[1] or LEFT', chadX, charY + 68);

      ctx.fillStyle = this.hoverIndex === 1 ? CONFIG.COLORS.BULL_GOLD : '#AAA';
      ctx.font = '16px sans-serif';
      ctx.fillText('Diana Dividend', dianaX, charY + 50);
      ctx.fillStyle = '#777';
      ctx.font = '12px sans-serif';
      ctx.fillText('[2] or RIGHT', dianaX, charY + 68);

      // Instruction
      ctx.fillStyle = CONFIG.COLORS.WHITE;
      ctx.font = '16px sans-serif';
      const isMobileSelect = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
      ctx.fillText(isMobileSelect ? 'Tap to confirm' : 'Press ENTER to confirm', w / 2, h * 0.88);
    }

    // Loading tip at bottom
    ctx.fillStyle = '#444';
    ctx.font = 'italic 13px sans-serif';
    ctx.fillText('"' + this.tips[this.tipIndex] + '"', w / 2, h * 0.95);
  }

  _drawMiniChad(ctx, x, y) {
    // Simplified chad at 36x54 scale
    ctx.fillStyle = CONFIG.COLORS.PLAYER_SUIT;
    ctx.fillRect(x + 4, y + 18, 28, 22);
    ctx.fillStyle = CONFIG.COLORS.PLAYER_SHIRT;
    ctx.beginPath();
    ctx.moveTo(x + 13, y + 18);
    ctx.lineTo(x + 18, y + 30);
    ctx.lineTo(x + 23, y + 18);
    ctx.fill();
    ctx.fillStyle = CONFIG.COLORS.PLAYER_TIE;
    ctx.fillRect(x + 16, y + 20, 4, 14);
    ctx.fillStyle = CONFIG.COLORS.PLAYER_SKIN;
    ctx.beginPath();
    ctx.ellipse(x + 18, y + 10, 10, 9, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = CONFIG.COLORS.PLAYER_HAIR_MALE;
    ctx.fillRect(x + 8, y + 2, 20, 5);
    ctx.fillStyle = '#1a1a3a';
    ctx.fillRect(x + 8, y + 40, 8, 14);
    ctx.fillRect(x + 20, y + 40, 8, 14);
    ctx.fillStyle = '#8B6914';
    ctx.fillRect(x + 28, y + 34, 10, 8);
  }

  _drawMiniDiana(ctx, x, y) {
    ctx.fillStyle = CONFIG.COLORS.PLAYER_BLAZER;
    ctx.fillRect(x + 4, y + 18, 28, 22);
    ctx.fillStyle = '#E8E0D0';
    ctx.beginPath();
    ctx.moveTo(x + 14, y + 18);
    ctx.lineTo(x + 18, y + 28);
    ctx.lineTo(x + 22, y + 18);
    ctx.fill();
    ctx.fillStyle = CONFIG.COLORS.PLAYER_SKIN;
    ctx.beginPath();
    ctx.ellipse(x + 18, y + 10, 9, 8, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = CONFIG.COLORS.PLAYER_HAIR_FEMALE;
    ctx.fillRect(x + 7, y + 2, 22, 6);
    ctx.fillRect(x + 6, y + 6, 6, 12);
    ctx.fillRect(x + 24, y + 6, 6, 12);
    ctx.fillStyle = '#1a1a3a';
    ctx.fillRect(x + 10, y + 40, 7, 14);
    ctx.fillRect(x + 20, y + 40, 7, 14);
    ctx.fillStyle = '#222';
    ctx.fillRect(x + 28, y + 30, 10, 8);
    ctx.fillStyle = '#4488FF';
    ctx.fillRect(x + 29, y + 31, 8, 5);
  }
}

class GameOverScreen {
  constructor() {
    this.animTime = 0;
    this.finalScore = 0;
    this.bullsCollected = 0;
    this.leaderboardData = null;
    this.playerRank = null;
    this.playerTotal = null;
    this.leaderboardStatus = null; // 'pending'|'submitting'|'done'|'error'|'skipped'
  }

  update(dt) {
    this.animTime += dt;
  }

  render(ctx, w, h) {
    // Dark red overlay
    ctx.fillStyle = 'rgba(30, 0, 0, 0.9)';
    ctx.fillRect(0, 0, w, h);

    // Red candlestick chart going down in background
    ctx.strokeStyle = 'rgba(255,50,50,0.15)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, h * 0.2);
    for (let x = 0; x < w; x += 20) {
      const y = h * 0.2 + (x / w) * h * 0.5 + Math.sin(x * 0.05) * 30;
      ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Animated crash effect
    const shake = this.animTime < 0.5 ? Math.sin(this.animTime * 40) * 5 : 0;

    ctx.fillStyle = CONFIG.COLORS.TICKER_RED;
    ctx.font = 'bold 40px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('YOUR PORTFOLIO HAS BEEN', w / 2 + shake, h * 0.28);

    ctx.font = 'bold 56px sans-serif';
    ctx.fillText('LIQUIDATED', w / 2 + shake, h * 0.38);

    // Sad chart icon
    ctx.fillStyle = CONFIG.COLORS.TICKER_RED;
    ctx.font = '60px sans-serif';
    ctx.fillText('\u25BC', w / 2, h * 0.5);

    // Score
    ctx.fillStyle = CONFIG.COLORS.WHITE;
    ctx.font = '22px sans-serif';
    ctx.fillText('Final Portfolio: $' + this.finalScore.toLocaleString(), w / 2, h * 0.62);
    ctx.fillText('Bulls Collected: ' + this.bullsCollected, w / 2, h * 0.68);

    // Leaderboard
    renderLeaderboardSection(ctx, w, h, 0.74, this);

    // Continue prompt
    if (this.leaderboardStatus !== 'pending' && Math.floor(this.animTime * 1.5) % 2 === 0) {
      ctx.fillStyle = '#AAA';
      ctx.font = '20px sans-serif';
      const isMobileGO = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
      ctx.fillText(isMobileGO ? 'Tap to try again' : 'Press ENTER to try again', w / 2, h * 0.82);
    }

    // Disclaimer
    ctx.fillStyle = '#444';
    ctx.font = 'italic 12px sans-serif';
    ctx.fillText('Past performance is not indicative of future results', w / 2, h * 0.92);
  }
}

class LevelCompleteScreen {
  constructor() {
    this.animTime = 0;
    this.finalScore = 0;
    this.bullsCollected = 0;
    this.timeTaken = 0;
    this.timeBonus = 0;
    this.leaderboardData = null;
    this.playerRank = null;
    this.playerTotal = null;
    this.leaderboardStatus = null;
  }

  update(dt) {
    this.animTime += dt;
  }

  render(ctx, w, h) {
    // Dark green overlay
    ctx.fillStyle = 'rgba(0, 20, 0, 0.9)';
    ctx.fillRect(0, 0, w, h);

    // Green chart going up in background
    ctx.strokeStyle = 'rgba(0,255,136,0.12)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, h * 0.8);
    for (let x = 0; x < w; x += 20) {
      const y = h * 0.8 - (x / w) * h * 0.5 + Math.sin(x * 0.04) * 25;
      ctx.lineTo(x, y);
    }
    ctx.stroke();

    ctx.fillStyle = CONFIG.COLORS.TICKER_GREEN;
    ctx.font = 'bold 48px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('MARKET CLOSE', w / 2, h * 0.18);

    ctx.fillStyle = CONFIG.COLORS.BULL_GOLD;
    ctx.font = 'bold 36px sans-serif';
    ctx.fillText('YOUR PORTFOLIO IS UP!', w / 2, h * 0.3);

    // Up arrow
    ctx.fillStyle = CONFIG.COLORS.TICKER_GREEN;
    ctx.font = '50px sans-serif';
    ctx.fillText('\u25B2', w / 2, h * 0.42);

    // Stats with animation
    const showDelay = 0.5;
    ctx.font = '22px sans-serif';

    if (this.animTime > showDelay) {
      ctx.fillStyle = CONFIG.COLORS.WHITE;
      ctx.fillText('Portfolio Value: $' + this.finalScore.toLocaleString(), w / 2, h * 0.54);
    }
    if (this.animTime > showDelay + 0.3) {
      ctx.fillStyle = CONFIG.COLORS.BULL_GOLD;
      ctx.fillText('Bulls Collected: ' + this.bullsCollected, w / 2, h * 0.61);
    }
    if (this.animTime > showDelay + 0.6) {
      ctx.fillStyle = CONFIG.COLORS.WHITE;
      ctx.fillText('Time: ' + this.timeTaken.toFixed(1) + 's', w / 2, h * 0.68);
    }
    if (this.animTime > showDelay + 0.9) {
      ctx.fillStyle = this.timeBonus > 0 ? CONFIG.COLORS.TICKER_GREEN : '#888';
      ctx.fillText('Time Bonus: +$' + this.timeBonus.toLocaleString(), w / 2, h * 0.74);
    }

    // Leaderboard
    if (this.animTime > showDelay + 1.2) {
      renderLeaderboardSection(ctx, w, h, 0.80, this);
    }

    if (this.animTime > 2.5 && this.leaderboardStatus !== 'pending') {
      if (Math.floor(this.animTime * 1.5) % 2 === 0) {
        ctx.fillStyle = '#AAA';
        ctx.font = '20px sans-serif';
        const isMobileLC = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        ctx.fillText(isMobileLC ? 'Tap to continue' : 'Press ENTER to continue', w / 2, h * 0.93);
      }
    }

    // Celebratory text
    ctx.fillStyle = '#555';
    ctx.font = 'italic 13px sans-serif';
    ctx.fillText('Congratulations! You survived the bear market.', w / 2, h * 0.97);
  }
}

// ==========================================
//  Shared Leaderboard Rendering
// ==========================================
function renderLeaderboardSection(ctx, w, h, startY, screen) {
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  if (screen.leaderboardStatus === 'submitting' || screen.leaderboardStatus === 'pending') {
    ctx.fillStyle = '#888';
    ctx.font = '14px sans-serif';
    ctx.fillText('Submitting score...', w / 2, h * startY);
    return;
  }

  if (screen.leaderboardStatus === 'error') {
    ctx.fillStyle = '#666';
    ctx.font = '14px sans-serif';
    ctx.fillText('Leaderboard unavailable', w / 2, h * startY);
    return;
  }

  if (screen.leaderboardStatus !== 'done' || !screen.leaderboardData) return;

  // Player rank
  if (screen.playerRank != null) {
    ctx.fillStyle = CONFIG.COLORS.BULL_GOLD;
    ctx.font = 'bold 16px sans-serif';
    ctx.fillText('Your Rank: #' + screen.playerRank + ' of ' + screen.playerTotal, w / 2, h * startY);
  }

  // Top scores header
  const tableTop = h * startY + 22;
  ctx.fillStyle = '#999';
  ctx.font = 'bold 11px monospace';
  ctx.fillText('--- TOP 10 ---', w / 2, tableTop);

  // Leaderboard rows — two columns: 1-5 left, 6-10 right
  const rowH = 14;
  const data = screen.leaderboardData.slice(0, 10);
  const colOffset = 160; // half-width of each column

  for (let i = 0; i < data.length; i++) {
    const entry = data[i];
    const col = i < 5 ? 0 : 1;
    const row = i < 5 ? i : i - 5;
    const colCenter = col === 0 ? w / 2 - colOffset / 2 - 10 : w / 2 + colOffset / 2 + 10;
    const y = tableTop + 16 + row * rowH;
    const rank = (i + 1) + '.';
    const name = entry.player_name.substring(0, 10);
    const score = '$' + entry.score.toLocaleString();

    ctx.fillStyle = i === 0 ? CONFIG.COLORS.BULL_GOLD : '#CCC';
    ctx.font = '11px monospace';
    ctx.textAlign = 'right';
    ctx.fillText(rank, colCenter - 65, y);
    ctx.textAlign = 'left';
    ctx.fillText(name, colCenter - 56, y);
    ctx.textAlign = 'right';
    ctx.fillText(score, colCenter + 80, y);
    ctx.textAlign = 'center';
  }
}
  </script>
  <script>
class BackgroundRenderer {
  constructor(theme) {
    this.theme = theme || 'nightCity';

    if (this.theme === 'nightCity') {
      this._initNightCity();
    } else if (this.theme === 'tradingFloor') {
      this._initTradingFloor();
    } else if (this.theme === 'cryptoMines') {
      this._initCryptoMines();
    }
  }

  // ==============================
  //  Night City (Level 1) - init
  // ==============================
  _initNightCity() {
    this.layers = [
      this._generateBuildings(15, 0.1, 0.5),
      this._generateBuildings(12, 0.3, 0.7),
      this._generateBuildings(10, 0.5, 0.9),
    ];
    this.stars = [];
    for (let i = 0; i < 80; i++) {
      this.stars.push({
        x: Math.random() * 2000,
        y: Math.random() * 300,
        size: Math.random() * 2 + 0.5,
        twinkle: Math.random() * Math.PI * 2
      });
    }
  }

  _generateBuildings(count, parallax, alpha) {
    const buildings = [];
    let x = -100;
    for (let i = 0; i < count; i++) {
      const w = 60 + Math.random() * 100;
      const h = 120 + Math.random() * 280;
      const windowCols = Math.floor(w / 18);
      const windowRows = Math.floor(h / 18);
      const windows = [];
      for (let r = 0; r < windowRows; r++) {
        for (let c = 0; c < windowCols; c++) {
          windows.push(Math.random() > 0.35);
        }
      }
      buildings.push({
        x: x, w: w, h: h,
        color: [CONFIG.COLORS.BUILDING_1, CONFIG.COLORS.BUILDING_2,
                CONFIG.COLORS.BUILDING_3, CONFIG.COLORS.BUILDING_4][i % 4],
        windowCols: windowCols,
        windowRows: windowRows,
        windows: windows,
        hasAntenna: Math.random() > 0.6,
        antennaHeight: 20 + Math.random() * 30
      });
      x += w + 15 + Math.random() * 40;
    }
    return { buildings: buildings, parallax: parallax, alpha: alpha, totalWidth: x };
  }

  // ==============================
  //  Trading Floor (Level 2) - init
  // ==============================
  _initTradingFloor() {
    this.layers = [
      this._generateTerminals(18, 0.1, 0.4),
      this._generateTerminals(14, 0.3, 0.6),
      this._generateTerminals(10, 0.5, 0.85),
    ];
    // No stars — indoor
    this.stars = [];
  }

  _generateTerminals(count, parallax, alpha) {
    const terminals = [];
    let x = -80;
    for (let i = 0; i < count; i++) {
      const w = 40 + Math.random() * 80;
      const h = 80 + Math.random() * 200;
      const screenCount = Math.floor(h / 30);
      const screens = [];
      for (let s = 0; s < screenCount; s++) {
        screens.push({
          isGreen: Math.random() > 0.4,
          barCount: 3 + Math.floor(Math.random() * 5),
          hasNumber: Math.random() > 0.5,
        });
      }
      terminals.push({
        x: x, w: w, h: h,
        color: ['#2a2018', '#332818', '#2e2418', '#261e14'][i % 4],
        screenCount: screenCount,
        screens: screens,
        isColumn: Math.random() > 0.7,
        columnColor: ['#4a4a5a', '#555565', '#504a5a'][i % 3],
      });
      x += w + 10 + Math.random() * 30;
    }
    return { buildings: terminals, parallax: parallax, alpha: alpha, totalWidth: x };
  }

  // ==============================
  //  Crypto Mines (Level 3) - init
  // ==============================
  _initCryptoMines() {
    this.layers = [
      this._generateServerRacks(18, 0.1, 0.4),
      this._generateServerRacks(14, 0.3, 0.65),
      this._generateServerRacks(10, 0.5, 0.85),
    ];
    // Floating crypto symbols instead of stars
    this.cryptoSymbols = [];
    const symbols = ['BTC', 'ETH', 'DOGE', 'SOL', 'XRP', 'ADA', 'DOT', 'LTC'];
    for (let i = 0; i < 40; i++) {
      this.cryptoSymbols.push({
        x: Math.random() * 2000,
        y: Math.random() * 280,
        symbol: symbols[Math.floor(Math.random() * symbols.length)],
        speed: 5 + Math.random() * 15,
        phase: Math.random() * Math.PI * 2,
        size: 8 + Math.random() * 4,
      });
    }
    // Matrix falling characters
    this.matrixColumns = [];
    for (let i = 0; i < 60; i++) {
      this.matrixColumns.push({
        x: Math.random() * 2000,
        chars: [],
        speed: 30 + Math.random() * 60,
        phase: Math.random() * 500,
        charCount: 5 + Math.floor(Math.random() * 10),
      });
      for (let j = 0; j < this.matrixColumns[i].charCount; j++) {
        this.matrixColumns[i].chars.push(String.fromCharCode(0x30 + Math.floor(Math.random() * 10)));
      }
    }
    // Stalactites from top
    this.stalactites = [];
    for (let i = 0; i < 30; i++) {
      this.stalactites.push({
        x: Math.random() * 2000,
        length: 20 + Math.random() * 60,
        width: 4 + Math.random() * 12,
      });
    }
    this.stars = [];
  }

  _generateServerRacks(count, parallax, alpha) {
    const racks = [];
    let x = -80;
    for (let i = 0; i < count; i++) {
      const w = 30 + Math.random() * 60;
      const h = 100 + Math.random() * 250;
      const ledCount = Math.floor(h / 12);
      const leds = [];
      for (let l = 0; l < ledCount; l++) {
        leds.push({
          color: Math.random() > 0.5 ? '#00FFCC' : '#FF00FF',
          blink: Math.random() > 0.3,
          phase: Math.random() * Math.PI * 2,
        });
      }
      racks.push({
        x: x, w: w, h: h,
        color: ['#0a0a1a', '#0e0e22', '#0c0c1e', '#08081a'][i % 4],
        ledCount: ledCount,
        leds: leds,
        hasNode: Math.random() > 0.6,
        nodeColor: Math.random() > 0.5 ? '#00CCFF' : '#AA44FF',
      });
      x += w + 8 + Math.random() * 25;
    }
    return { buildings: racks, parallax: parallax, alpha: alpha, totalWidth: x };
  }

  // ==============================
  //  Main render dispatcher
  // ==============================
  render(ctx, camera, canvasWidth, canvasHeight, time) {
    if (this.theme === 'nightCity') {
      this._renderNightCity(ctx, camera, canvasWidth, canvasHeight, time);
    } else if (this.theme === 'tradingFloor') {
      this._renderTradingFloor(ctx, camera, canvasWidth, canvasHeight, time);
    } else if (this.theme === 'cryptoMines') {
      this._renderCryptoMines(ctx, camera, canvasWidth, canvasHeight, time);
    }
  }

  // ==============================
  //  Night City rendering
  // ==============================
  _renderNightCity(ctx, camera, canvasWidth, canvasHeight, time) {
    // Sky gradient
    const grad = ctx.createLinearGradient(0, 0, 0, canvasHeight);
    grad.addColorStop(0, CONFIG.COLORS.SKY_TOP);
    grad.addColorStop(0.5, CONFIG.COLORS.SKY_MID);
    grad.addColorStop(1, CONFIG.COLORS.SKY_BOTTOM);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    // Moon
    ctx.fillStyle = '#FFFFEE';
    ctx.globalAlpha = 0.8;
    ctx.beginPath();
    ctx.arc(canvasWidth * 0.82 - camera.x * 0.02, 60, 30, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 0.2;
    ctx.beginPath();
    ctx.arc(canvasWidth * 0.82 - camera.x * 0.02, 60, 45, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Stars
    for (const star of this.stars) {
      const sx = ((star.x - camera.x * 0.03) % (canvasWidth + 100));
      const twinkle = Math.sin(time * 2 + star.twinkle) * 0.3 + 0.7;
      ctx.globalAlpha = twinkle * 0.8;
      ctx.fillStyle = CONFIG.COLORS.WHITE;
      ctx.fillRect(sx, star.y, star.size, star.size);
    }
    ctx.globalAlpha = 1;

    // Building layers
    for (const layer of this.layers) {
      this._renderBuildingLayer(ctx, camera, canvasWidth, canvasHeight, layer, time);
    }
  }

  _renderBuildingLayer(ctx, camera, canvasWidth, canvasHeight, layer, time) {
    ctx.globalAlpha = layer.alpha;
    const offsetX = camera.x * layer.parallax;

    for (const b of layer.buildings) {
      const repeatW = layer.totalWidth;
      let drawX = ((b.x - offsetX) % repeatW);
      if (drawX > canvasWidth + 200) drawX -= repeatW;
      if (drawX + b.w < -200) drawX += repeatW;
      if (drawX > canvasWidth + 200) continue;
      if (drawX + b.w < -200) continue;

      const by = canvasHeight - b.h;

      ctx.fillStyle = b.color;
      ctx.fillRect(drawX, by, b.w, b.h);

      ctx.fillStyle = 'rgba(255,255,255,0.05)';
      ctx.fillRect(drawX, by, b.w, 3);

      if (b.hasAntenna) {
        ctx.fillStyle = '#555';
        ctx.fillRect(drawX + b.w / 2 - 1, by - b.antennaHeight, 3, b.antennaHeight);
        const blink = Math.sin(time * 3 + b.x) > 0.5;
        if (blink) {
          ctx.fillStyle = '#FF0000';
          ctx.beginPath();
          ctx.arc(drawX + b.w / 2, by - b.antennaHeight, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      const wSize = 8;
      const wGap = 14;
      const startX = drawX + 8;
      const startY = by + 12;
      for (let r = 0; r < b.windowRows; r++) {
        for (let c = 0; c < b.windowCols; c++) {
          const idx = r * b.windowCols + c;
          const lit = b.windows[idx];
          if (lit) {
            const flicker = Math.sin(time * 0.5 + idx * 7.3) > -0.95;
            ctx.fillStyle = flicker ?
              (idx % 3 === 0 ? CONFIG.COLORS.WINDOW_LIT_2 : CONFIG.COLORS.WINDOW_LIT) :
              CONFIG.COLORS.WINDOW_DARK;
          } else {
            ctx.fillStyle = CONFIG.COLORS.WINDOW_DARK;
          }
          ctx.fillRect(startX + c * wGap, startY + r * wGap, wSize, wSize);
        }
      }
    }
    ctx.globalAlpha = 1;
  }

  // ==============================
  //  Trading Floor rendering
  // ==============================
  _renderTradingFloor(ctx, camera, canvasWidth, canvasHeight, time) {
    // Warm amber sky gradient (indoor ceiling)
    const grad = ctx.createLinearGradient(0, 0, 0, canvasHeight);
    grad.addColorStop(0, '#2a1a00');
    grad.addColorStop(0.5, '#3a2a10');
    grad.addColorStop(1, '#4a3a20');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    // Warm ambient glow from ceiling
    ctx.globalAlpha = 0.15;
    const ceilGrad = ctx.createLinearGradient(0, 0, 0, canvasHeight * 0.4);
    ceilGrad.addColorStop(0, '#FF8800');
    ceilGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = ceilGrad;
    ctx.fillRect(0, 0, canvasWidth, canvasHeight * 0.4);
    ctx.globalAlpha = 1;

    // Ceiling light fixtures
    for (let i = 0; i < 6; i++) {
      const lx = ((i * 180 - camera.x * 0.05) % (canvasWidth + 200));
      const pulse = 0.3 + Math.sin(time * 1.5 + i * 1.7) * 0.1;
      ctx.globalAlpha = pulse;
      ctx.fillStyle = '#FFAA44';
      ctx.fillRect(lx, 0, 60, 4);
      // Light cone
      ctx.beginPath();
      ctx.moveTo(lx, 4);
      ctx.lineTo(lx - 20, 80);
      ctx.lineTo(lx + 80, 80);
      ctx.lineTo(lx + 60, 4);
      ctx.closePath();
      ctx.fillStyle = 'rgba(255,170,68,0.04)';
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Terminal/column layers
    for (const layer of this.layers) {
      this._renderTerminalLayer(ctx, camera, canvasWidth, canvasHeight, layer, time);
    }
  }

  _renderTerminalLayer(ctx, camera, canvasWidth, canvasHeight, layer, time) {
    ctx.globalAlpha = layer.alpha;
    const offsetX = camera.x * layer.parallax;

    for (const t of layer.buildings) {
      const repeatW = layer.totalWidth;
      let drawX = ((t.x - offsetX) % repeatW);
      if (drawX > canvasWidth + 200) drawX -= repeatW;
      if (drawX + t.w < -200) drawX += repeatW;
      if (drawX > canvasWidth + 200) continue;
      if (drawX + t.w < -200) continue;

      const by = canvasHeight - t.h;

      if (t.isColumn) {
        // Stone column
        ctx.fillStyle = t.columnColor;
        ctx.fillRect(drawX + t.w * 0.2, by, t.w * 0.6, t.h);
        // Column cap
        ctx.fillStyle = '#6a6a7a';
        ctx.fillRect(drawX, by, t.w, 6);
        ctx.fillRect(drawX + 2, by + 6, t.w - 4, 4);
      } else {
        // Terminal desk body
        ctx.fillStyle = t.color;
        ctx.fillRect(drawX, by, t.w, t.h);

        // Top edge
        ctx.fillStyle = 'rgba(255,200,100,0.08)';
        ctx.fillRect(drawX, by, t.w, 3);

        // Screens on terminals
        const screenH = 18;
        const screenGap = 26;
        for (let s = 0; s < t.screenCount; s++) {
          const sy = by + 10 + s * screenGap;
          if (sy + screenH > canvasHeight) break;
          const screen = t.screens[s];

          // Screen background
          ctx.fillStyle = '#0a1a0a';
          ctx.fillRect(drawX + 4, sy, t.w - 8, screenH);

          // Stock chart bars
          const barW = Math.max(2, (t.w - 16) / screen.barCount);
          for (let b = 0; b < screen.barCount; b++) {
            const barH = 4 + Math.abs(Math.sin(time * 0.8 + s * 3 + b * 2.1)) * (screenH - 6);
            const isGreen = Math.sin(time * 0.3 + s + b * 1.7) > 0;
            ctx.fillStyle = isGreen ? '#00CC66' : '#CC3333';
            ctx.fillRect(drawX + 6 + b * barW, sy + screenH - barH - 1, barW - 1, barH);
          }

          // Screen glow edge
          ctx.strokeStyle = screen.isGreen ? 'rgba(0,204,102,0.2)' : 'rgba(204,51,51,0.2)';
          ctx.lineWidth = 1;
          ctx.strokeRect(drawX + 4, sy, t.w - 8, screenH);
        }
      }
    }
    ctx.globalAlpha = 1;
  }

  // ==============================
  //  Crypto Mines rendering
  // ==============================
  _renderCryptoMines(ctx, camera, canvasWidth, canvasHeight, time) {
    // Deep purple underground gradient
    const grad = ctx.createLinearGradient(0, 0, 0, canvasHeight);
    grad.addColorStop(0, '#0a0020');
    grad.addColorStop(0.5, '#150030');
    grad.addColorStop(1, '#0a0a2a');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    // Matrix falling characters (far background)
    ctx.font = '10px monospace';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    for (const col of this.matrixColumns) {
      const mx = ((col.x - camera.x * 0.05) % (canvasWidth + 100));
      for (let j = 0; j < col.charCount; j++) {
        const my = ((col.phase + time * col.speed + j * 14) % (canvasHeight + 50)) - 20;
        const fade = j === 0 ? 0.5 : 0.12 + (col.charCount - j) / col.charCount * 0.15;
        ctx.globalAlpha = fade;
        ctx.fillStyle = j === 0 ? '#44FF88' : '#00AA44';
        ctx.fillText(col.chars[j], mx, my);
      }
    }
    ctx.globalAlpha = 1;

    // Stalactites from ceiling
    for (const stal of this.stalactites) {
      const sx = ((stal.x - camera.x * 0.08) % (canvasWidth + 200));
      ctx.fillStyle = '#1a1040';
      ctx.beginPath();
      ctx.moveTo(sx - stal.width / 2, 0);
      ctx.lineTo(sx + stal.width / 2, 0);
      ctx.lineTo(sx, stal.length);
      ctx.closePath();
      ctx.fill();
      // Glow tip
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#6622AA';
      ctx.beginPath();
      ctx.arc(sx, stal.length, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // Floating crypto symbols
    ctx.font = 'bold 9px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    for (const cs of this.cryptoSymbols) {
      const cx = ((cs.x - camera.x * 0.04) % (canvasWidth + 100));
      const cy = cs.y + Math.sin(time * 0.5 + cs.phase) * 10;
      const pulse = 0.15 + Math.sin(time * 1.5 + cs.phase) * 0.1;
      ctx.globalAlpha = pulse;
      ctx.fillStyle = cs.symbol === 'BTC' ? '#FF9900' :
                      cs.symbol === 'ETH' ? '#627EEA' :
                      cs.symbol === 'DOGE' ? '#C3A634' :
                      '#00CCFF';
      ctx.fillText(cs.symbol, cx, cy);
    }
    ctx.globalAlpha = 1;

    // Server rack layers
    for (const layer of this.layers) {
      this._renderServerLayer(ctx, camera, canvasWidth, canvasHeight, layer, time);
    }
  }

  _renderServerLayer(ctx, camera, canvasWidth, canvasHeight, layer, time) {
    ctx.globalAlpha = layer.alpha;
    const offsetX = camera.x * layer.parallax;

    for (const r of layer.buildings) {
      const repeatW = layer.totalWidth;
      let drawX = ((r.x - offsetX) % repeatW);
      if (drawX > canvasWidth + 200) drawX -= repeatW;
      if (drawX + r.w < -200) drawX += repeatW;
      if (drawX > canvasWidth + 200) continue;
      if (drawX + r.w < -200) continue;

      const by = canvasHeight - r.h;

      // Server rack body
      ctx.fillStyle = r.color;
      ctx.fillRect(drawX, by, r.w, r.h);

      // Top edge with neon glow
      ctx.fillStyle = 'rgba(0,200,255,0.1)';
      ctx.fillRect(drawX, by, r.w, 2);

      // Side glow
      ctx.fillStyle = 'rgba(170,68,255,0.05)';
      ctx.fillRect(drawX - 1, by, 2, r.h);
      ctx.fillRect(drawX + r.w - 1, by, 2, r.h);

      // LED strips
      const ledGap = 10;
      for (let l = 0; l < r.ledCount; l++) {
        const ly = by + 6 + l * ledGap;
        if (ly > canvasHeight) break;
        const led = r.leds[l];
        if (led.blink && Math.sin(time * 3 + led.phase) < 0) continue;
        ctx.fillStyle = led.color;
        ctx.globalAlpha = layer.alpha * 0.8;
        ctx.fillRect(drawX + 4, ly, 3, 2);
        ctx.fillRect(drawX + r.w - 7, ly, 3, 2);
        // LED glow
        ctx.globalAlpha = layer.alpha * 0.15;
        ctx.fillRect(drawX + 2, ly - 1, 7, 4);
      }
      ctx.globalAlpha = layer.alpha;

      // Blockchain node indicator
      if (r.hasNode) {
        const nx = drawX + r.w / 2;
        const ny = by + 20;
        ctx.globalAlpha = layer.alpha * (0.4 + Math.sin(time * 2 + r.x) * 0.2);
        ctx.strokeStyle = r.nodeColor;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(nx, ny, 6, 0, Math.PI * 2);
        ctx.stroke();
        // Inner dot
        ctx.fillStyle = r.nodeColor;
        ctx.beginPath();
        ctx.arc(nx, ny, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    ctx.globalAlpha = 1;
  }
}

function renderGoldenBriefcase(ctx, camera, pos, time) {
  const sx = pos.x - camera.x;
  const sy = pos.y - camera.y;

  // Glow pulse
  const glowSize = 40 + Math.sin(time * 3) * 8;
  ctx.globalAlpha = 0.2 + Math.sin(time * 3) * 0.1;
  ctx.fillStyle = CONFIG.COLORS.BULL_GOLD;
  ctx.beginPath();
  ctx.arc(sx + 24, sy + 20, glowSize, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;

  // Rays of light
  ctx.strokeStyle = 'rgba(255,215,0,0.3)';
  ctx.lineWidth = 2;
  for (let i = 0; i < 8; i++) {
    const angle = time * 0.5 + i * Math.PI / 4;
    const innerR = 30;
    const outerR = 50 + Math.sin(time * 2 + i) * 10;
    ctx.beginPath();
    ctx.moveTo(sx + 24 + Math.cos(angle) * innerR, sy + 20 + Math.sin(angle) * innerR);
    ctx.lineTo(sx + 24 + Math.cos(angle) * outerR, sy + 20 + Math.sin(angle) * outerR);
    ctx.stroke();
  }

  // Briefcase body
  ctx.fillStyle = CONFIG.COLORS.BULL_GOLD;
  ctx.fillRect(sx + 2, sy + 10, 44, 28);

  // Briefcase top edge
  ctx.fillStyle = '#FFE44D';
  ctx.fillRect(sx + 2, sy + 10, 44, 4);

  // Handle
  ctx.strokeStyle = '#B8860B';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(sx + 24, sy + 10, 10, Math.PI, 0);
  ctx.stroke();

  // Clasp
  ctx.fillStyle = CONFIG.COLORS.WHITE;
  ctx.fillRect(sx + 20, sy + 24, 8, 4);

  // Dollar sign
  ctx.fillStyle = '#B8860B';
  ctx.font = 'bold 16px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('$', sx + 24, sy + 28);

  // Floating sparkles
  for (let i = 0; i < 4; i++) {
    const angle = time * 1.5 + i * Math.PI / 2;
    const dist = 35;
    const px = sx + 24 + Math.cos(angle) * dist;
    const py = sy + 20 + Math.sin(angle) * dist * 0.7;
    ctx.globalAlpha = 0.5 + Math.sin(time * 4 + i) * 0.3;
    ctx.fillStyle = CONFIG.COLORS.WHITE;
    // Star shape
    ctx.beginPath();
    ctx.moveTo(px, py - 3);
    ctx.lineTo(px + 1, py - 1);
    ctx.lineTo(px + 3, py);
    ctx.lineTo(px + 1, py + 1);
    ctx.lineTo(px, py + 3);
    ctx.lineTo(px - 1, py + 1);
    ctx.lineTo(px - 3, py);
    ctx.lineTo(px - 1, py - 1);
    ctx.closePath();
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}
  </script>
  <script>
class AudioManager {
  constructor() {
    this.ctx = null;
    this.enabled = true;
    this.initialized = false;
    this.bgMusicPlaying = false;
    this._bgMusicTimeout = null;
    this.bgMusicGain = null;
  }

  init() {
    if (this.initialized) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.masterGain = this.ctx.createGain();
      this.masterGain.connect(this.ctx.destination);
      this.initialized = true;
    } catch (e) {
      this.enabled = false;
    }
  }

  _playTone(frequency, duration, type, volume, delay) {
    if (!this.ctx || !this.enabled) return;
    type = type || 'square';
    volume = volume || 0.12;
    delay = delay || 0;

    const startTime = this.ctx.currentTime + delay;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(frequency, startTime);
    gain.gain.setValueAtTime(volume, startTime);
    gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
    osc.connect(gain);
    gain.connect(this.masterGain);
    osc.start(startTime);
    osc.stop(startTime + duration);
  }

  playJump() {
    this._playTone(350, 0.08, 'square', 0.1);
    this._playTone(520, 0.1, 'square', 0.08, 0.04);
  }

  playCollect() {
    this._playTone(880, 0.06, 'sine', 0.12);
    this._playTone(1320, 0.1, 'sine', 0.08, 0.05);
  }

  playStomp() {
    this._playTone(180, 0.12, 'sawtooth', 0.15);
    this._playTone(90, 0.15, 'square', 0.08, 0.05);
  }

  playDamage() {
    this._playTone(200, 0.2, 'sawtooth', 0.15);
    this._playTone(120, 0.25, 'sawtooth', 0.1, 0.08);
  }

  playDeath() {
    const notes = [400, 350, 300, 250, 200, 150, 100];
    notes.forEach((freq, i) => {
      this._playTone(freq, 0.18, 'square', 0.12, i * 0.1);
    });
  }

  playPowerUp() {
    const notes = [400, 500, 600, 700, 800, 1000, 1200];
    notes.forEach((freq, i) => {
      this._playTone(freq, 0.08, 'sine', 0.1, i * 0.05);
    });
  }

  playExtraLife() {
    const notes = [523, 659, 784, 1047, 784, 1047];
    notes.forEach((freq, i) => {
      this._playTone(freq, 0.15, 'sine', 0.12, i * 0.1);
    });
  }

  playLevelComplete() {
    const notes = [523, 587, 659, 784, 880, 1047];
    notes.forEach((freq, i) => {
      this._playTone(freq, 0.25, 'sine', 0.12, i * 0.12);
    });
    // Triumphant chord
    this._playTone(523, 0.5, 'sine', 0.06, 0.8);
    this._playTone(659, 0.5, 'sine', 0.06, 0.8);
    this._playTone(784, 0.5, 'sine', 0.06, 0.8);
    this._playTone(1047, 0.5, 'sine', 0.06, 0.8);
  }

  playBlockHit() {
    this._playTone(600, 0.06, 'square', 0.08);
    this._playTone(800, 0.06, 'square', 0.06, 0.03);
  }

  playHodl() {
    this._playTone(440, 0.3, 'sine', 0.08);
    this._playTone(550, 0.3, 'sine', 0.06, 0.15);
    this._playTone(660, 0.4, 'sine', 0.08, 0.3);
  }

  playSuperJump() {
    this._playTone(300, 0.06, 'square', 0.1);
    this._playTone(500, 0.06, 'square', 0.08, 0.03);
    this._playTone(700, 0.08, 'square', 0.08, 0.06);
    this._playTone(900, 0.12, 'sine', 0.1, 0.09);
  }

  playMarginCall() {
    this._playTone(300, 0.15, 'sawtooth', 0.12);
    this._playTone(200, 0.2, 'sawtooth', 0.15, 0.1);
    this._playTone(100, 0.4, 'sawtooth', 0.12, 0.2);
  }

  playClang() {
    this._playTone(800, 0.05, 'square', 0.15);
    this._playTone(600, 0.08, 'triangle', 0.12, 0.03);
    this._playTone(400, 0.1, 'triangle', 0.08, 0.06);
  }

  playDiamondHands() {
    const notes = [523, 659, 784, 1047, 1319, 1568];
    notes.forEach((freq, i) => {
      this._playTone(freq, 0.12, 'sine', 0.12, i * 0.06);
    });
    this._playTone(523, 0.6, 'sine', 0.06, 0.4);
    this._playTone(784, 0.6, 'sine', 0.06, 0.4);
    this._playTone(1047, 0.6, 'sine', 0.06, 0.4);
  }

  // Accelerating tick sound during diamond hands — called from main update loop
  playDiamondHandsTick(remainingRatio) {
    // remainingRatio: 1 = just started, 0 = about to end
    // Pitch rises and volume increases as time runs out
    const baseFreq = 600 + (1 - remainingRatio) * 800;  // 600 → 1400 Hz
    const vol = 0.06 + (1 - remainingRatio) * 0.08;     // 0.06 → 0.14
    this._playTone(baseFreq, 0.04, 'sine', vol);
    this._playTone(baseFreq * 1.5, 0.025, 'sine', vol * 0.5, 0.015);
  }

  playDiamondCollect() {
    // Sparkly catch sound for the running diamond
    const notes = [1047, 1319, 1568, 2093];
    notes.forEach((freq, i) => {
      this._playTone(freq, 0.1, 'sine', 0.12, i * 0.04);
    });
  }

  playGrizzlyStomp() {
    // Heavy impact — deeper than normal stomp
    this._playTone(120, 0.15, 'sawtooth', 0.18);
    this._playTone(80, 0.2, 'square', 0.15, 0.05);
    this._playTone(200, 0.1, 'triangle', 0.1, 0.1);
    this._playTone(60, 0.3, 'sawtooth', 0.1, 0.15);
  }

  playMarketCrash() {
    // Alarm siren — rising and falling tones
    this._playTone(400, 0.3, 'sawtooth', 0.15);
    this._playTone(600, 0.3, 'sawtooth', 0.15, 0.3);
    this._playTone(400, 0.3, 'sawtooth', 0.15, 0.6);
    this._playTone(600, 0.3, 'sawtooth', 0.12, 0.9);
    this._playTone(300, 0.5, 'square', 0.1, 1.2);
  }

  playDividend() {
    this._playTone(1200, 0.06, 'sine', 0.12);
    this._playTone(1600, 0.06, 'sine', 0.1, 0.04);
    this._playTone(2000, 0.1, 'sine', 0.08, 0.08);
    this._playTone(1600, 0.15, 'triangle', 0.06, 0.12);
  }

  playBossRoar() {
    this._playTone(80, 0.5, 'sawtooth', 0.2);
    this._playTone(60, 0.6, 'sawtooth', 0.18, 0.1);
    this._playTone(100, 0.3, 'square', 0.12, 0.3);
  }

  playBossShockwave() {
    this._playTone(100, 0.3, 'sawtooth', 0.15);
    this._playTone(60, 0.4, 'square', 0.12, 0.1);
  }

  playBossDeath() {
    const notes = [523, 659, 784, 1047, 1319, 1568, 2093];
    notes.forEach((freq, i) => {
      this._playTone(freq, 0.15, 'sine', 0.15, i * 0.08);
    });
    this._playTone(523, 1.0, 'sine', 0.08, 0.6);
    this._playTone(784, 1.0, 'sine', 0.08, 0.6);
    this._playTone(1047, 1.0, 'sine', 0.08, 0.6);
    this._playTone(1568, 1.0, 'sine', 0.06, 0.6);
  }

  playBackgroundMusic() {
    if (!this.ctx || this.bgMusicPlaying) return;
    this.bgMusicPlaying = true;

    const ctx = this.ctx;
    const musicGain = ctx.createGain();
    musicGain.gain.value = 0.08;
    musicGain.connect(this.masterGain);
    this.bgMusicGain = musicGain;

    // Tempo: 150 BPM, eighth note ≈ 0.2s
    const BPM = 150;
    const eighth = 60 / BPM / 2;

    // Note frequencies — _ = rest
    const _ = 0;
    const C3=131,D3=147,E3=165,F3=175,G3=196,A3=220,B3=247;
    const C4=262,D4=294,E4=330,F4=349,G4=392,A4=440,B4=494;
    const C5=523,D5=587,E5=659,F5=698,G5=784,A5=880,B5=988;
    const C6=1047,D6=1175;

    // ========== 32-BAR COMPOSITION ==========
    // 8 eighth notes per bar · 256 total notes · ~51 seconds
    // Structure: Intro(4) → Theme A(8) → Theme B(8) → Bridge(4) → Theme A'(8)

    // ---- MELODY (square lead) ----
    const melody = [
      // INTRO (4 bars) — gentle build
      C5,_,E5,_,G5,_,_,_,   E5,_,D5,_,C5,_,_,_,
      C5,D5,E5,G5,E5,D5,C5,D5,  E5,_,G5,_,_,_,_,_,

      // THEME A (8 bars) — "Bull Run" hook
      G5,_,E5,G5,C6,_,G5,_,   A5,G5,E5,C5,D5,_,E5,_,
      G5,_,E5,G5,C6,_,G5,A5,   B5,_,G5,_,D5,_,_,_,
      G5,_,E5,G5,C6,_,G5,_,   A5,G5,E5,C5,D5,E5,G5,A5,
      F5,_,E5,_,D5,_,C5,D5,   E5,_,_,_,_,_,_,_,

      // THEME B (8 bars) — funky, driving
      A5,_,E5,_,A5,G5,E5,_,   F5,_,C5,_,F5,E5,C5,_,
      G5,E5,G5,A5,B5,_,A5,G5,   E5,_,D5,_,_,_,_,_,
      A5,E5,C5,E5,A5,_,G5,E5,   F5,C5,A4,C5,F5,_,E5,C5,
      D5,E5,F5,G5,A5,B5,C6,D6,   C6,_,_,_,B5,_,_,_,

      // BRIDGE (4 bars) — lyrical, breathing room
      F5,_,A5,C6,_,A5,F5,_,   G5,_,B5,D5,_,_,G5,_,
      E5,G5,B5,G5,E5,B4,E5,G5,   A5,_,E5,C5,_,_,_,_,

      // THEME A' (8 bars) — triumphant return
      G5,_,E5,G5,C6,_,G5,E5,   A5,G5,E5,C5,D5,_,E5,G5,
      C6,_,G5,_,E5,_,G5,A5,   B5,_,D6,_,B5,_,G5,_,
      C6,G5,E5,G5,C6,_,E5,G5,   A5,G5,E5,C5,F5,A5,C6,A5,
      G5,B5,D6,B5,G5,D5,B4,D5,   C5,E5,G5,C6,_,_,_,_,
    ];

    // ---- BASS (triangle — bouncy, every other eighth) ----
    const bassLine = [
      // Intro: C | C | C | C
      C3,_,C3,_,G3,_,C3,_,  C3,_,C3,_,G3,_,C3,_,
      C3,_,C3,_,G3,_,C3,_,  C3,_,G3,_,C3,_,_,_,
      // Theme A: C | Am | C | G  |  C | Am | F | C
      C3,_,G3,_,C3,_,G3,_,  A3,_,E3,_,A3,_,E3,_,
      C3,_,G3,_,C3,_,G3,_,  G3,_,D3,_,G3,_,D3,_,
      C3,_,G3,_,C3,_,G3,_,  A3,_,E3,_,A3,_,E3,_,
      F3,_,C3,_,F3,_,C3,_,  C3,_,G3,_,C3,_,_,_,
      // Theme B: Am | F | G | Em  |  Am | F | Dm | C
      A3,_,E3,_,A3,_,E3,_,  F3,_,C3,_,F3,_,C3,_,
      G3,_,D3,_,G3,_,D3,_,  E3,_,B3,_,E3,_,_,_,
      A3,_,E3,_,A3,_,E3,_,  F3,_,C3,_,F3,_,C3,_,
      D3,_,A3,_,D3,_,A3,_,  C3,_,G3,_,C3,_,_,_,
      // Bridge: F | G | Em | Am
      F3,_,C3,_,F3,_,C3,_,  G3,_,D3,_,G3,_,D3,_,
      E3,_,B3,_,E3,_,B3,_,  A3,_,E3,_,A3,_,_,_,
      // Theme A': C | Am | C | G  |  C | F | G | C
      C3,_,G3,_,C3,_,G3,_,  A3,_,E3,_,A3,_,E3,_,
      C3,_,G3,_,C3,_,G3,_,  G3,_,D3,_,G3,_,D3,_,
      C3,_,G3,_,C3,_,G3,_,  F3,_,C3,_,F3,_,A3,_,
      G3,_,D3,_,G3,_,D3,_,  C3,_,G3,_,C3,_,_,_,
    ];

    // ---- CHORD ARPEGGIOS (sine — soft harmonic bed) ----
    const chordTones = [
      [C4,E4,G4],[C4,E4,G4],[C4,E4,G4],[C4,E4,G4],           // Intro
      [C4,E4,G4],[A3,C4,E4],[C4,E4,G4],[G3,B3,D4],           // A1
      [C4,E4,G4],[A3,C4,E4],[F3,A3,C4],[C4,E4,G4],           // A2
      [A3,C4,E4],[F3,A3,C4],[G3,B3,D4],[E3,G3,B3],           // B1
      [A3,C4,E4],[F3,A3,C4],[D3,F3,A3],[C4,E4,G4],           // B2
      [F3,A3,C4],[G3,B3,D4],[E3,G3,B3],[A3,C4,E4],           // Bridge
      [C4,E4,G4],[A3,C4,E4],[C4,E4,G4],[G3,B3,D4],           // A'1
      [C4,E4,G4],[F3,A3,C4],[G3,B3,D4],[C4,E4,G4],           // A'2
    ];
    const arpeggio = [];
    for (const ch of chordTones) {
      for (let i = 0; i < 8; i++) arpeggio.push(ch[i % 3]);
    }

    const totalNotes = melody.length;
    const loopDuration = totalNotes * eighth;

    // Helper: schedule one short oscillator note
    const note = (freq, time, dur, type, vol) => {
      if (!freq) return;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, time);
      g.gain.setValueAtTime(vol, time);
      g.gain.exponentialRampToValueAtTime(0.001, time + dur);
      o.connect(g);
      g.connect(musicGain);
      o.start(time);
      o.stop(time + dur + 0.01);
    };

    // Noise buffer for hi-hats (created once, reused)
    const noiseBuf = ctx.createBuffer(1, ctx.sampleRate * 0.04, ctx.sampleRate);
    const nd = noiseBuf.getChannelData(0);
    for (let j = 0; j < nd.length; j++) nd[j] = Math.random() * 2 - 1;

    const playLoop = () => {
      if (!this.bgMusicPlaying) return;
      const t0 = ctx.currentTime + 0.05;

      // ── Lead melody (square wave, articulated) ──
      for (let i = 0; i < melody.length; i++) {
        if (!melody[i]) continue;
        note(melody[i], t0 + i * eighth, eighth * 0.8, 'square', 0.20);
      }

      // ── Bass line (triangle wave) ──
      for (let i = 0; i < bassLine.length; i++) {
        if (!bassLine[i]) continue;
        note(bassLine[i], t0 + i * eighth, eighth * 0.9, 'triangle', 0.32);
      }

      // ── Arpeggios (sine wave, gentle) ──
      for (let i = 0; i < arpeggio.length; i++) {
        if (!arpeggio[i]) continue;
        note(arpeggio[i], t0 + i * eighth, eighth * 0.55, 'sine', 0.08);
      }

      // ── Percussion ──
      for (let i = 0; i < totalNotes; i++) {
        const beat = i % 8;
        const t = t0 + i * eighth;

        // Kick drum on beats 1 & 3 (pitch-dropping sine)
        if (beat === 0 || beat === 4) {
          const ko = ctx.createOscillator();
          const kg = ctx.createGain();
          ko.type = 'sine';
          ko.frequency.setValueAtTime(150, t);
          ko.frequency.exponentialRampToValueAtTime(40, t + 0.12);
          kg.gain.setValueAtTime(0.28, t);
          kg.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
          ko.connect(kg);
          kg.connect(musicGain);
          ko.start(t);
          ko.stop(t + 0.2);
        }

        // Hi-hat on every other eighth note (filtered noise)
        if (beat % 2 === 0) {
          const ns = ctx.createBufferSource();
          ns.buffer = noiseBuf;
          const ng = ctx.createGain();
          ng.gain.setValueAtTime(0.045, t);
          ng.gain.exponentialRampToValueAtTime(0.001, t + 0.035);
          const hpf = ctx.createBiquadFilter();
          hpf.type = 'highpass';
          hpf.frequency.value = 7000;
          ns.connect(hpf);
          hpf.connect(ng);
          ng.connect(musicGain);
          ns.start(t);
          ns.stop(t + 0.05);
        }

        // Snare on beat 4 of every 2nd bar (noise + tone)
        if (beat === 6 && (Math.floor(i / 8) % 2 === 1)) {
          note(200, t, 0.08, 'triangle', 0.12);
          const sn = ctx.createBufferSource();
          sn.buffer = noiseBuf;
          const sg = ctx.createGain();
          sg.gain.setValueAtTime(0.07, t);
          sg.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
          sn.connect(sg);
          sg.connect(musicGain);
          sn.start(t);
          sn.stop(t + 0.1);
        }
      }

      this._bgMusicTimeout = setTimeout(() => playLoop(), (loopDuration - 0.15) * 1000);
    };

    playLoop();
  }

  stopBackgroundMusic() {
    this.bgMusicPlaying = false;
    if (this._bgMusicTimeout) {
      clearTimeout(this._bgMusicTimeout);
      this._bgMusicTimeout = null;
    }
  }
}
  </script>
  <script>
// ============================================================
//  GAMEPLAY RECORDER & REPLAY LIBRARY
//  Records human + bot gameplay as state→action pairs.
//  Stored in localStorage, consulted by the bot as an advisor.
// ============================================================

(function () {
  'use strict';

  const STORAGE_KEY = 'bullrun_replays';
  const MAX_REPLAYS = 20;         // Keep top 20 replays
  const SAMPLE_INTERVAL = 6;      // Record every 6th frame (~10 samples/sec at 60fps)
  const STATE_BUCKET_X = 40;      // Quantize X to 40px buckets
  const STATE_BUCKET_Y = 30;      // Quantize Y to 30px buckets

  // ── Replay Library ──────────────────────────────────────────
  const replayLib = {
    replays: [],         // Array of completed replay objects
    stateIndex: {},      // Fast lookup: stateKey → [{ action, score, replayIdx }]
    bestScore: 0,
  };

  // Load from localStorage
  function loadLibrary() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw) {
        const data = JSON.parse(raw);
        replayLib.replays = data.replays || [];
        replayLib.bestScore = data.bestScore || 0;
        rebuildIndex();
        console.log('%c[REPLAY LIB] Loaded ' + replayLib.replays.length +
          ' replays (best: $' + replayLib.bestScore + ')',
          'color:#00BFFF;font-weight:bold');
      }
    } catch (e) {
      console.warn('[REPLAY LIB] Failed to load:', e);
    }
  }

  // Save to localStorage
  function saveLibrary() {
    try {
      const data = {
        replays: replayLib.replays,
        bestScore: replayLib.bestScore,
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    } catch (e) {
      console.warn('[REPLAY LIB] Failed to save:', e);
    }
  }

  // Build fast state→action lookup index from all replays
  function rebuildIndex() {
    replayLib.stateIndex = {};
    for (let ri = 0; ri < replayLib.replays.length; ri++) {
      const replay = replayLib.replays[ri];
      const weight = replay.score / Math.max(1, replayLib.bestScore); // 0-1 quality weight
      for (const frame of replay.frames) {
        const key = frame.key;
        if (!replayLib.stateIndex[key]) replayLib.stateIndex[key] = [];
        replayLib.stateIndex[key].push({
          action: frame.action,
          score: replay.score,
          weight: weight,
          replayIdx: ri,
        });
      }
    }
  }

  // ── State Encoding ──────────────────────────────────────────
  // Quantize the game state into a lookup key
  function encodeState(playerX, playerY, levelIdx, extras) {
    const bx = Math.round(playerX / STATE_BUCKET_X);
    const by = Math.round(playerY / STATE_BUCKET_Y);
    // extras: onGround, nearEnemy, nearItem, nearPit
    const flags =
      (extras.onGround ? 1 : 0) |
      (extras.nearEnemy ? 2 : 0) |
      (extras.nearItem ? 4 : 0) |
      (extras.nearPit ? 8 : 0);
    return levelIdx + ':' + bx + ':' + by + ':' + flags;
  }

  // Encode action as a compact number
  function encodeAction(left, right, jump, down) {
    return (left ? 1 : 0) | (right ? 2 : 0) | (jump ? 4 : 0) | (down ? 8 : 0);
  }

  function decodeAction(code) {
    return {
      left:  !!(code & 1),
      right: !!(code & 2),
      jump:  !!(code & 4),
      down:  !!(code & 8),
    };
  }

  // ── Active Recording Session ────────────────────────────────
  let recording = false;
  let currentReplay = null;
  let frameCounter = 0;
  let recordSource = 'human'; // 'human' or 'bot'

  function startRecording(source) {
    recording = true;
    recordSource = source || 'human';
    frameCounter = 0;
    currentReplay = {
      source: recordSource,
      score: 0,
      completed: false,
      timestamp: Date.now(),
      frames: [],
    };
  }

  function recordFrame(playerX, playerY, levelIdx, extras, actionLeft, actionRight, actionJump, actionDown) {
    if (!recording || !currentReplay) return;
    frameCounter++;
    if (frameCounter % SAMPLE_INTERVAL !== 0) return;

    const key = encodeState(playerX, playerY, levelIdx, extras);
    const action = encodeAction(actionLeft, actionRight, actionJump, actionDown);

    currentReplay.frames.push({ key, action });

    // Cap frame memory per replay (max ~3000 samples ≈ 5 min of play)
    if (currentReplay.frames.length > 3000) {
      currentReplay.frames.shift();
    }
  }

  function finishRecording(finalScore, completed) {
    if (!recording || !currentReplay) return;
    recording = false;
    currentReplay.score = finalScore || 0;
    currentReplay.completed = completed || false;

    // Only keep replays that scored something
    if (currentReplay.score > 0 && currentReplay.frames.length > 10) {
      replayLib.replays.push(currentReplay);
      if (currentReplay.score > replayLib.bestScore) {
        replayLib.bestScore = currentReplay.score;
      }

      // Keep only the top MAX_REPLAYS by score
      if (replayLib.replays.length > MAX_REPLAYS) {
        replayLib.replays.sort((a, b) => b.score - a.score);
        replayLib.replays = replayLib.replays.slice(0, MAX_REPLAYS);
      }

      rebuildIndex();
      saveLibrary();

      console.log('%c[REPLAY LIB] Saved ' + recordSource + ' replay: $' +
        currentReplay.score + ' (' + currentReplay.frames.length + ' frames) — ' +
        'Library: ' + replayLib.replays.length + ' replays',
        'color:#00BFFF;font-weight:bold');
    }
    currentReplay = null;
  }

  // ── Advisor: consult library for best action ────────────────
  // Returns { action: {left,right,jump,down}, confidence: 0-1 } or null
  function advise(playerX, playerY, levelIdx, extras) {
    const key = encodeState(playerX, playerY, levelIdx, extras);
    const entries = replayLib.stateIndex[key];
    if (!entries || entries.length === 0) return null;

    // Vote: weight each recorded action by the replay's quality
    const votes = {};
    let totalWeight = 0;
    for (const entry of entries) {
      const a = entry.action;
      if (!votes[a]) votes[a] = 0;
      votes[a] += entry.weight;
      totalWeight += entry.weight;
    }

    // Find the highest-voted action
    let bestAction = 0;
    let bestVotes = 0;
    for (const [action, weight] of Object.entries(votes)) {
      if (weight > bestVotes) {
        bestVotes = weight;
        bestAction = parseInt(action);
      }
    }

    const confidence = totalWeight > 0 ? bestVotes / totalWeight : 0;
    return {
      action: decodeAction(bestAction),
      confidence: confidence,
      sampleCount: entries.length,
    };
  }

  // ── Fuzzy advisor: check nearby states too ──────────────────
  function adviseFuzzy(playerX, playerY, levelIdx, extras) {
    // Try exact match first
    let result = advise(playerX, playerY, levelIdx, extras);
    if (result && result.sampleCount >= 2) return result;

    // Try nearby positions (±1 bucket)
    const offsets = [
      [STATE_BUCKET_X, 0], [-STATE_BUCKET_X, 0],
      [0, STATE_BUCKET_Y], [0, -STATE_BUCKET_Y],
    ];
    let bestResult = result;
    for (const [dx, dy] of offsets) {
      const r = advise(playerX + dx, playerY + dy, levelIdx, extras);
      if (r && (!bestResult || r.sampleCount > bestResult.sampleCount)) {
        bestResult = r;
      }
    }
    return bestResult;
  }

  // ── Public API ──────────────────────────────────────────────
  window.ReplayLib = {
    load: loadLibrary,
    save: saveLibrary,
    startRecording,
    recordFrame,
    finishRecording,
    advise: adviseFuzzy,
    getStats: () => ({
      replayCount: replayLib.replays.length,
      bestScore: replayLib.bestScore,
      indexSize: Object.keys(replayLib.stateIndex).length,
      totalFrames: replayLib.replays.reduce((s, r) => s + r.frames.length, 0),
    }),
    clear: () => {
      replayLib.replays = [];
      replayLib.stateIndex = {};
      replayLib.bestScore = 0;
      localStorage.removeItem(STORAGE_KEY);
      console.log('%c[REPLAY LIB] Cleared all replays', 'color:#FF6666');
    },
  };

  // Auto-load on init
  loadLibrary();
})();
  </script>
  <script>
// ==========================================
//  BULL RUN - Main Game Loop & State Machine
// ==========================================

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const input = new InputHandler();
const touchControls = new TouchControls(canvas, input);
const audio = new AudioManager();
const particles = new ParticleSystem();
const floatingText = new FloatingText();

const leaderboard = new Leaderboard(SUPABASE_URL, SUPABASE_ANON_KEY);
const gameIntegrity = new GameIntegrity();

let currentState = GameState.TITLE;
let titleScreen = new TitleScreen();
let gameOverScreen = new GameOverScreen();
let levelCompleteScreen = new LevelCompleteScreen();
let leaderboardPending = false; // true while waiting for name input or submission

let player = null;
let level = null;
let camera = null;
let hud = null;
let background = new BackgroundRenderer();

let levelTime = 0;
let gameTime = 0;
let debugMode = false;

// Death/respawn state
let deathPauseTimer = 0;
let marginCallShown = false;
let flashCrashTimer = 0;

// Grizzly stomp combo tracking
let grizzlyComboTarget = null;

// Stock ticker refresh
let lastStockFetchTime = 0;
const STOCK_FETCH_INTERVAL = 60; // seconds

// Market crash event
let marketCrashActive = false;
let marketCrashTimer = 0;
let marketCrashShakeOffset = { x: 0, y: 0 };
let diamondSpawnTimer = 0;
let dhTickTimer = 0;

// Level system
let currentLevelIndex = 0;

// ==========================================
//  Canvas setup
// ==========================================
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function getScale() {
  const scaleX = canvas.width / CONFIG.VIRTUAL_WIDTH;
  const scaleY = canvas.height / CONFIG.VIRTUAL_HEIGHT;
  return Math.min(scaleX, scaleY);
}

// ==========================================
//  Game Start
// ==========================================
function startGame(characterType, levelIndex) {
  currentLevelIndex = levelIndex || 0;
  const LEVELS = [LEVEL_1, LEVEL_2, LEVEL_3];
  const levelData = LEVELS[currentLevelIndex];
  level = loadLevel(levelData);
  player = new Player(levelData.playerStart.x, levelData.playerStart.y, characterType);
  camera = new Camera(CONFIG.VIRTUAL_WIDTH, CONFIG.VIRTUAL_HEIGHT);
  camera.levelWidth = level.width;
  camera.levelHeight = level.height;
  background = new BackgroundRenderer(levelData.theme || 'nightCity');
  hud = new HUD(level.tickerStocks);
  levelTime = 0;
  deathPauseTimer = 0;
  marginCallShown = false;
  leaderboardPending = false;
  grizzlyComboTarget = null;
  marketCrashActive = false;
  marketCrashTimer = 0;
  marketCrashShakeOffset = { x: 0, y: 0 };
  diamondSpawnTimer = 0;
  dhTickTimer = 0;
  leaderboard.resetSession();
  gameIntegrity.start();

  // Wire up question block callbacks
  for (const block of level.questionBlocks) {
    block.setHitCallback((contents, x, y) => {
      spawnFromBlock(contents, x, y);
      audio.playBlockHit();
    });
  }

  currentState = GameState.PLAYING;

  // Try to fetch live stock data
  fetchLiveStockData().then(stocks => {
    if (stocks) {
      level.tickerStocks = stocks;
      hud.tickerStocks = stocks;
    }
  });
}

function spawnFromBlock(contents, x, y) {
  let item;
  if (contents === 'bull') {
    item = new GoldBull(x, y);
  } else if (contents === 'hodlItem') {
    item = new HodlItem(x, y);
  } else if (contents === 'greenCandle') {
    item = new GreenCandle(x, y);
  }
  if (item) {
    item.fromBlock = true;
    item.vy = -200; // Pop upward
    level.collectibles.push(item);
  }
}

// ==========================================
//  Main Update
// ==========================================
function update(dt) {
  gameTime += dt;

  // Debug mode toggle
  if (input.wasPressed('F1') || input.wasPressed('Backquote')) {
    debugMode = !debugMode;
  }

  switch (currentState) {
    case GameState.TITLE:
      updateTitle(dt);
      break;
    case GameState.PLAYING:
      updatePlaying(dt);
      break;
    case GameState.GAME_OVER:
      updateGameOver(dt);
      break;
    case GameState.LEVEL_COMPLETE:
      updateLevelComplete(dt);
      break;
  }

  input.clearFrameState();
  touchControls.update(dt, currentState);
}

function updateTitle(dt) {
  const result = titleScreen.update(dt, input);
  if (result === 'start') {
    audio.init();
    audio.playBackgroundMusic();
    startGame(titleScreen.selectedCharacter);
  }
}

function updatePlaying(dt) {
  // Handle death pause
  if (deathPauseTimer > 0) {
    deathPauseTimer -= dt;
    if (player.deathAnimating) {
      player.update(dt, { left: false, right: false, jump: false }, []);
    }
    if (deathPauseTimer <= 0) {
      if (player.lives <= 0) {
        audio.stopBackgroundMusic();
        gameOverScreen = new GameOverScreen();
        gameOverScreen.finalScore = player.score;
        gameOverScreen.bullsCollected = player.totalBullsCollected;
        currentState = GameState.GAME_OVER;
        triggerLeaderboard(player.score, player.totalBullsCollected, levelTime, player.characterType);
      } else {
        player.respawn();
        camera.x = Math.max(0, player.x - CONFIG.VIRTUAL_WIDTH / 2);
        marginCallShown = false;
      }
    }
    particles.update(dt);
    floatingText.update(dt);
    return;
  }

  levelTime += dt;

  // Update flash crash timer (death effect)
  if (flashCrashTimer > 0) {
    flashCrashTimer -= dt;
  }

  // Periodic stock ticker refresh
  lastStockFetchTime += dt;
  if (lastStockFetchTime >= STOCK_FETCH_INTERVAL) {
    lastStockFetchTime = 0;
    fetchLiveStockData().then(stocks => {
      if (stocks && level && hud) {
        const oldStocks = level.tickerStocks;
        for (const newStock of stocks) {
          const old = oldStocks.find(s => s.symbol === newStock.symbol);
          if (old && old.price !== newStock.price) {
            newStock._flash = newStock.price > old.price ? 'green' : 'red';
            newStock._flashTimer = 2.0;
          }
        }
        level.tickerStocks = stocks;
        hud.tickerStocks = stocks;
      }
    });
  }

  // Update player
  player.update(dt, input, level.solids);

  // Grizzly stomp combo: reset if player touches ground
  if (grizzlyComboTarget && player.onGround) {
    if (grizzlyComboTarget.alive) {
      grizzlyComboTarget.stunned = false;
      floatingText.spawn(grizzlyComboTarget.x + grizzlyComboTarget.width / 2,
        grizzlyComboTarget.y - 20, 'UNSTUNNED!', '#FF8800', 16);
    }
    grizzlyComboTarget = null;
  }

  // Jump sounds
  if (player.superJumpedThisFrame) {
    audio.playSuperJump();
  } else if (player.jumpedThisFrame) {
    audio.playJump();
  }

  // Update question blocks
  for (const block of level.questionBlocks) {
    block.update(dt);
  }

  // Update enemies
  for (let i = level.enemies.length - 1; i >= 0; i--) {
    const enemy = level.enemies[i];
    const keepAlive = enemy instanceof GrizzlyBear
      ? enemy.update(dt, level.solids, player.x)
      : enemy.update(dt, level.solids);
    if (!keepAlive) {
      level.enemies.splice(i, 1);
    }
  }

  // Player vs enemies collision
  if (!player.deathAnimating) {
    for (const enemy of level.enemies) {
      if (!enemy.alive) continue;
      if (!aabbOverlap(player, enemy)) continue;

      // Check if Diamond Hands invincible - kill ALL enemies on contact
      if (player.invincible && player.diamondHands) {
        enemy.hp = 0;
        enemy.alive = false;
        particles.bearDeath(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
        floatingText.spawn(enemy.x + enemy.width / 2, enemy.y - 20, '+200', CONFIG.COLORS.BULL_GOLD);
        player.score += 200;
        gameIntegrity.logEvent('diamond_kill', 200);
        audio.playStomp();
        continue;
      }

      // Determine stomp vs side hit
      const playerBottom = player.y + player.height;
      const enemyTop = enemy.y;
      const playerFalling = player.vy > 0;

      if (playerFalling && (playerBottom - enemyTop) < enemy.height * 0.45) {
        if (enemy instanceof GrizzlyBear) {
          // Grizzly: requires 2 stomps without touching ground
          const killed = enemy.stomp();
          if (killed) {
            // Second stomp — grizzly defeated!
            player.vy = CONFIG.PLAYER_STOMP_BOUNCE;
            grizzlyComboTarget = null;
            particles.bearDeath(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
            floatingText.spawn(enemy.x + enemy.width / 2, enemy.y - 20, '+500', CONFIG.COLORS.BULL_GOLD, 22);
            player.score += 500;
            gameIntegrity.logEvent('stomp_grizzly_kill', 500);
            audio.playStomp();
          } else {
            // First stomp — high bounce, must land again without touching ground
            player.vy = -500; // Higher bounce for combo opportunity
            grizzlyComboTarget = enemy;
            enemy.stunned = true;
            floatingText.spawn(enemy.x + enemy.width / 2, enemy.y - 20, 'STOMP AGAIN!', '#FF8800', 18);
            player.score += 50;
            gameIntegrity.logEvent('stomp_grizzly', 50);
            audio.playGrizzlyStomp();
          }
        } else {
          // STOMP baby bears
          const killed = enemy.stomp();
          player.vy = CONFIG.PLAYER_STOMP_BOUNCE;
          audio.playStomp();

          if (killed) {
            particles.bearDeath(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
            floatingText.spawn(enemy.x + enemy.width / 2, enemy.y - 20, '+200', CONFIG.COLORS.BULL_GOLD);
            player.score += 200;
            gameIntegrity.logEvent('stomp_baby_kill', 200);
          } else {
            floatingText.spawn(enemy.x + enemy.width / 2, enemy.y - 20, 'HIT!', CONFIG.COLORS.TICKER_RED, 18);
            player.score += 50;
            gameIntegrity.logEvent('stomp_baby', 50);
          }
        }
      } else {
        // Side hit - player takes damage
        const died = player.takeDamage();
        if (died) {
          playerDeath('enemy');
        } else {
          audio.playDamage();
          floatingText.spawn(player.x + player.width / 2, player.y - 20, 'OUCH!', CONFIG.COLORS.TICKER_RED, 20);
          // Knockback
          player.vx = (player.x < enemy.x) ? -200 : 200;
          player.vy = -200;
        }
      }
    }
  }

  // Player vs collectibles
  for (let i = level.collectibles.length - 1; i >= 0; i--) {
    const c = level.collectibles[i];
    if (c.collected) continue;
    if (!aabbOverlap(player, c)) continue;

    c.collected = true;

    if (c.type === 'bull') {
      const result = player.collectBull();
      gameIntegrity.logEvent('bull', CONFIG.BULL_SCORE);
      audio.playCollect();
      particles.bullCollect(c.x + c.width / 2, c.y + c.height / 2);
      floatingText.spawn(c.x + c.width / 2, c.y - 10, '+$100', CONFIG.COLORS.BULL_GOLD, 16);
      if (result === 'diamondHands') {
        audio.playDiamondHands();
        floatingText.spawn(player.x + player.width / 2, player.y - 40,
          'DIAMOND HANDS!', '#88DDFF', 28, 2.5);
        particles.powerUp(player.x + player.width / 2, player.y + player.height / 2, '#88DDFF');
      }
    } else if (c.type === 'hodlItem') {
      player.applyPowerUp('hodlItem');
      audio.playPowerUp();
      particles.powerUp(c.x + c.width / 2, c.y + c.height / 2, '#FF4444');
      floatingText.spawn(c.x + c.width / 2, c.y - 10, 'HODL!', '#FF4444', 22, 1.5);
    } else if (c.type === 'greenCandle') {
      player.applyPowerUp('greenCandle');
      audio.playPowerUp();
      particles.powerUp(c.x + c.width / 2, c.y + c.height / 2, CONFIG.COLORS.GREEN_CANDLE);
      floatingText.spawn(c.x + c.width / 2, c.y - 10, 'GREEN CANDLE!', CONFIG.COLORS.GREEN_CANDLE, 22, 1.5);
    } else if (c.type === 'dividend') {
      player.score += CONFIG.DIVIDEND_SCORE;
      gameIntegrity.logEvent('dividend', CONFIG.DIVIDEND_SCORE);
      audio.playDividend();
      particles.bullCollect(c.x + c.width / 2, c.y + c.height / 2);
      floatingText.spawn(c.x + c.width / 2, c.y - 10, '+$500 DIVIDEND!', '#00FF88', 24, 2.0);
    } else if (c.type === 'runningDiamond') {
      audio.playDiamondCollect();
      audio.playDiamondHands();
      player.activateDiamondHands();
      particles.powerUp(player.x + player.width / 2, player.y + player.height / 2, '#88DDFF');
      floatingText.spawn(player.x + player.width / 2, player.y - 40,
        'DIAMOND HANDS!', '#88DDFF', 28, 2.5);
    }
  }

  // Remove collected items
  level.collectibles = level.collectibles.filter(c => !c.collected);

  // Short Squeeze pads
  for (const pad of level.shortSqueezePads) {
    pad.update(dt);
    if (!player.deathAnimating && pad.tryLaunch(player)) {
      audio.playSuperJump();
      floatingText.spawn(pad.x + pad.width / 2, pad.y - 20, 'SHORT SQUEEZE!', '#00FF88', 20, 1.5);
      particles.powerUp(pad.x + pad.width / 2, pad.y, '#00FF88');
    }
  }

  // Update moving platforms
  if (level.movingPlatforms) {
    for (const mp of level.movingPlatforms) {
      const oldX = mp.x;
      const oldY = mp.y;
      mp.update(dt);
      // Carry player if standing on this platform
      if (player.onGround && !player.deathAnimating) {
        const onPlatform = player.y + player.height >= mp.y - 2 &&
                           player.y + player.height <= mp.y + 4 &&
                           player.x + player.width > mp.x &&
                           player.x < mp.x + mp.width;
        if (onPlatform) {
          player.x += (mp.x - oldX);
          player.y += (mp.y - oldY);
          // Transfer platform velocity to player for better jump behavior off moving platforms
          player._platformVx = mp.vx;
          player._platformVy = mp.vy;
        }
      }
    }
  }

  // Market crash events
  if (level.marketCrashZones && !marketCrashActive) {
    for (const zone of level.marketCrashZones) {
      if (!zone.triggered && Math.abs(player.x - zone.x) < 50) {
        zone.triggered = true;
        marketCrashActive = true;
        marketCrashTimer = 5.0; // 5 seconds
        audio.playMarketCrash();
        floatingText.spawn(player.x + player.width / 2, player.y - 60,
          'MARKET CRASH!', CONFIG.COLORS.TICKER_RED, 36, 3.0);
      }
    }
  }
  if (marketCrashActive) {
    marketCrashTimer -= dt;
    // Fade shake intensity as crash nears end
    const crashIntensity = Math.min(1, marketCrashTimer / 1.0); // Fade in last second
    marketCrashShakeOffset.x = (Math.random() - 0.5) * 6 * crashIntensity;
    marketCrashShakeOffset.y = (Math.random() - 0.5) * 4 * crashIntensity;
    // Speed up all enemies during crash (applied every frame to catch newly alive enemies)
    for (const enemy of level.enemies) {
      if (enemy.alive) enemy.crashSpeedMult = 1.5;
    }
    if (marketCrashTimer <= 0) {
      marketCrashActive = false;
      marketCrashShakeOffset = { x: 0, y: 0 };
      // Reset ALL enemies' speed multiplier (including any that were spawned during crash)
      for (const enemy of level.enemies) {
        enemy.crashSpeedMult = 1.0;
      }
    }
  } else {
    // Safety: ensure no lingering crash speed multiplier on enemies when crash is inactive
    // This handles edge cases where enemies could retain the multiplier
  }

  // Red Candle falling hazards
  level.redCandleTimer = (level.redCandleTimer || 0) + dt;
  if (level.redCandleTimer >= 2.0) {
    level.redCandleTimer = 0;
    for (const zone of level.redCandleZones) {
      // Only spawn if player is within range of the zone
      if (Math.abs(player.x - zone.x - zone.width / 2) < CONFIG.VIRTUAL_WIDTH) {
        const rx = zone.x + Math.random() * zone.width;
        level.collectibles.push(new RedCandle(rx, player.y - CONFIG.VIRTUAL_HEIGHT / 2 - 50));
      }
    }
  }

  // Player vs red candles
  for (let i = level.collectibles.length - 1; i >= 0; i--) {
    const c = level.collectibles[i];
    if (c.type !== 'redCandle' || c.collected) continue;
    if (!player.deathAnimating && aabbOverlap(player, c)) {
      c.collected = true;
      const died = player.takeDamage();
      if (died) {
        playerDeath('enemy');
      } else {
        audio.playDamage();
        floatingText.spawn(player.x + player.width / 2, player.y - 20, 'RED CANDLE!', '#FF4444', 20);
        player.vx = (player.x < c.x) ? -150 : 150;
        player.vy = -150;
      }
    }
  }

  // Spawn running diamond every 35-55 seconds
  diamondSpawnTimer += dt;
  if (diamondSpawnTimer >= 35 + Math.random() * 20) {
    diamondSpawnTimer = 0;
    // Spawn from right side of screen, bouncing left toward player
    const spawnX = player.x + CONFIG.VIRTUAL_WIDTH + 40;
    const spawnY = 380;
    level.collectibles.push(new RunningDiamond(spawnX, spawnY, -1));
    floatingText.spawn(player.x + CONFIG.VIRTUAL_WIDTH / 2, player.y - 20,
      '\u25C6 DIAMOND!', '#88DDFF', 20, 1.5);
  }

  // Diamond Hands accelerating tick sound
  if (player.diamondHands && player.invincibleTimer > 0) {
    const remaining = player.invincibleTimer;
    const total = CONFIG.DIAMOND_HANDS_DURATION;
    const ratio = remaining / total;
    // Tick interval decreases as time runs out
    let interval;
    if (remaining > 7) interval = 0.7;
    else if (remaining > 5) interval = 0.45;
    else if (remaining > 3) interval = 0.25;
    else if (remaining > 1.5) interval = 0.12;
    else interval = 0.06;
    dhTickTimer += dt;
    if (dhTickTimer >= interval) {
      dhTickTimer = 0;
      audio.playDiamondHandsTick(ratio);
    }
  } else {
    dhTickTimer = 0;
  }

  // Boss update and collision
  if (level.boss) {
    const boss = level.boss;
    if (boss.alive) {
      boss.update(dt, level.solids, player.x);

      // Player vs boss collision
      if (!player.deathAnimating && aabbOverlap(player, boss)) {
        if (player.invincible && player.diamondHands) {
          // Diamond hands deals 1 damage
          const killed = boss.stomp();
          player.vy = CONFIG.PLAYER_STOMP_BOUNCE;
          audio.playStomp();
          if (killed) {
            audio.playBossDeath();
            floatingText.spawn(boss.x + boss.width / 2, boss.y - 30, '+2000 WHALE DOWN!', CONFIG.COLORS.BULL_GOLD, 28, 3.0);
            player.score += 2000;
            gameIntegrity.logEvent('boss_kill', 2000);
          }
        } else {
          const playerBottom = player.y + player.height;
          const bossTop = boss.y;
          const playerFalling = player.vy > 0;

          if (playerFalling && (playerBottom - bossTop) < boss.height * 0.35) {
            // Stomp the boss
            const killed = boss.stomp();
            player.vy = -500; // High bounce
            audio.playGrizzlyStomp();
            if (killed) {
              audio.playBossDeath();
              floatingText.spawn(boss.x + boss.width / 2, boss.y - 30, '+2000 WHALE DOWN!', CONFIG.COLORS.BULL_GOLD, 28, 3.0);
              player.score += 2000;
              gameIntegrity.logEvent('boss_kill', 2000);
            } else {
              floatingText.spawn(boss.x + boss.width / 2, boss.y - 20, 'HIT! ' + boss.hp + '/' + boss.maxHp, '#FF8800', 20);
              player.score += 100;
              gameIntegrity.logEvent('boss_hit', 100);
              if (boss.phase === 2 && boss.hp === 6) {
                audio.playBossRoar();
                floatingText.spawn(boss.x + boss.width / 2, boss.y - 50, 'PHASE 2!', '#FF4444', 24, 2.0);
              } else if (boss.phase === 3 && boss.hp === 3) {
                audio.playBossRoar();
                floatingText.spawn(boss.x + boss.width / 2, boss.y - 50, 'FINAL PHASE!', '#FF0000', 28, 2.0);
              }
            }
          } else if (!boss.stunned) {
            // Side hit — player takes damage
            const died = player.takeDamage();
            if (died) {
              playerDeath('enemy');
            } else {
              audio.playDamage();
              floatingText.spawn(player.x + player.width / 2, player.y - 20, 'OUCH!', CONFIG.COLORS.TICKER_RED, 20);
              player.vx = (player.x < boss.x) ? -250 : 250;
              player.vy = -250;
            }
          }
        }
      }

      // Player vs boss shockwaves
      if (!player.deathAnimating) {
        for (const sw of boss.shockwaves) {
          const dist = Math.abs(player.x + player.width / 2 - sw.x);
          const playerOnGround = player.y + player.height >= 430; // Ground is at y=432, use 430 for 2px tolerance
          if (playerOnGround && dist < sw.radius + 20 && dist > sw.radius - 20) {
            const died = player.takeDamage();
            if (died) {
              playerDeath('enemy');
            } else {
              audio.playBossShockwave();
              player.vy = -300;
              player.vx = (player.x < sw.x) ? -200 : 200;
              floatingText.spawn(player.x + player.width / 2, player.y - 20, 'SHOCKWAVE!', '#FFAA00', 18);
            }
            break;
          }
        }
      }

      // Player vs boss projectiles
      if (!player.deathAnimating) {
        for (let i = boss.projectiles.length - 1; i >= 0; i--) {
          const p = boss.projectiles[i];
          if (aabbOverlap(player, p)) {
            boss.projectiles.splice(i, 1);
            const died = player.takeDamage();
            if (died) {
              playerDeath('enemy');
            } else {
              audio.playDamage();
              floatingText.spawn(player.x + player.width / 2, player.y - 20, 'RED CANDLE!', '#FF4444', 20);
              player.vy = -150;
            }
            break;
          }
        }
      }

      // Boss arena walls — confine player
      if (level.bossArena && boss.activated && !player.deathAnimating) {
        if (player.x < level.bossArena.wallLeft) {
          player.x = level.bossArena.wallLeft;
          player.vx = 0;
        }
        if (player.x + player.width > level.bossArena.wallRight) {
          player.x = level.bossArena.wallRight - player.width;
          player.vx = 0;
        }
      }
    }
  }

  // Clamp player to level boundaries (left and right edges)
  if (player.x < 0) {
    player.x = 0;
    player.vx = 0;
  }
  if (player.x + player.width > level.width) {
    player.x = level.width - player.width;
    player.vx = 0;
  }

  // Pit death
  if (!player.deathAnimating && player.y > CONFIG.VIRTUAL_HEIGHT + 50) {
    playerDeath('pit');
  }

  // Goal check
  const goal = level.goalPosition;
  if (!player.deathAnimating &&
      Math.abs(player.x + player.width / 2 - goal.x - 24) < 50 &&
      Math.abs(player.y + player.height / 2 - goal.y - 20) < 50) {
    audio.playLevelComplete();
    // Calculate time bonus: faster = more points
    const timeBonus = Math.max(0, Math.round(5000 - levelTime * 50));
    player.score += timeBonus;
    if (timeBonus > 0) gameIntegrity.logEvent('time_bonus', timeBonus);
    levelCompleteScreen = new LevelCompleteScreen();
    levelCompleteScreen.finalScore = player.score;
    levelCompleteScreen.bullsCollected = player.totalBullsCollected;
    levelCompleteScreen.timeTaken = levelTime;
    levelCompleteScreen.timeBonus = timeBonus;
    levelCompleteScreen.leaderboardStatus = 'skipped';
    currentState = GameState.LEVEL_COMPLETE;
  }

  // Update camera
  if (!player.deathAnimating) {
    camera.follow(player, dt);
  }

  // Update collectibles animation
  for (const c of level.collectibles) {
    if (c.type === 'runningDiamond') {
      c.update(dt, level.solids);
    } else if (c.fromBlock && !c.settled) {
      c.update(dt, level.solids);
    } else {
      c.update(dt);
    }
  }

  // Update particles
  particles.update(dt);
  floatingText.update(dt);

  // Update HUD
  hud.update(dt);
}

function playerDeath(cause) {
  flashCrashTimer = 0.3;
  if (cause === 'pit' && !marginCallShown) {
    marginCallShown = true;
    audio.playMarginCall();
    floatingText.spawn(player.x + player.width / 2, CONFIG.VIRTUAL_HEIGHT - 80 + camera.y,
      'MARGIN CALL!', CONFIG.COLORS.TICKER_RED, 36, 2.0);
  } else if (cause === 'enemy') {
    audio.playDeath();
  }
  player.die();
  deathPauseTimer = cause === 'pit' ? 1.5 : 2.0;
}

function triggerLeaderboard(score, bulls, time, character) {
  if (!leaderboard.isAvailable() || leaderboard.submittedThisSession) return;

  const screen = currentState === GameState.LEVEL_COMPLETE ? levelCompleteScreen : gameOverScreen;
  screen.leaderboardStatus = 'pending';
  leaderboardPending = true;

  // Build integrity payload from tracked game events
  const integrityPayload = gameIntegrity.getPayload(
    leaderboard.playerName || 'pending',
    time,
    character
  );

  const doSubmit = () => {
    screen.leaderboardStatus = 'submitting';
    // Pass integrity payload so the server can validate the score
    integrityPayload.player_name = leaderboard.playerName;
    leaderboard.submitScore(score, bulls, time, character, integrityPayload).then(result => {
      leaderboardPending = false;
      if (result) {
        screen.leaderboardData = result.leaderboard;
        screen.playerRank = result.rank;
        screen.playerTotal = result.total;
        screen.leaderboardStatus = 'done';
      } else {
        screen.leaderboardStatus = 'error';
      }
    });
  };

  if (leaderboard.hasPlayerName()) {
    doSubmit();
  } else {
    leaderboard.showNameInput(
      (name) => { doSubmit(); },
      () => { leaderboardPending = false; screen.leaderboardStatus = 'skipped'; }
    );
  }
}

function updateGameOver(dt) {
  gameOverScreen.update(dt);
  if (leaderboardPending) return;
  if (input.wasPressed('Enter') || input.wasPressed('Space')) {
    currentLevelIndex = 0;
    titleScreen = new TitleScreen();
    currentState = GameState.TITLE;
  }
}

function updateLevelComplete(dt) {
  levelCompleteScreen.update(dt);
  if (leaderboardPending) return;
  if ((input.wasPressed('Enter') || input.wasPressed('Space')) && levelCompleteScreen.animTime > 2.5) {
    currentLevelIndex++;
    const LEVELS = [LEVEL_1, LEVEL_2, LEVEL_3];
    if (currentLevelIndex < LEVELS.length) {
      // Advance to next level — keep score, lives, totalBulls
      const levelData = LEVELS[currentLevelIndex];
      level = loadLevel(levelData);
      player.x = levelData.playerStart.x;
      player.y = levelData.playerStart.y;
      player.spawnX = levelData.playerStart.x;
      player.spawnY = levelData.playerStart.y;
      player.vx = 0;
      player.vy = 0;
      player.onGround = false;
      player.bullsCollected = 0;
      // Reset all power-up and dimension state
      player.powered = false;
      player.width = CONFIG.PLAYER_WIDTH;
      player.height = CONFIG.PLAYER_HEIGHT;
      player.hasHeadband = false;
      player.diamondHands = false;
      player.invincible = false;
      player.invincibleTimer = 0;
      player.damageInvTimer = 0;
      player.deathAnimating = false;
      player.deathAnimTimer = 0;
      player.crouching = false;
      player.crouchTimer = 0;
      player.superJumpReady = false;
      diamondSpawnTimer = 0;
      dhTickTimer = 0;
      camera = new Camera(CONFIG.VIRTUAL_WIDTH, CONFIG.VIRTUAL_HEIGHT);
      camera.levelWidth = level.width;
      camera.levelHeight = level.height;
      background = new BackgroundRenderer(levelData.theme || 'nightCity');
      hud = new HUD(level.tickerStocks);
      levelTime = 0;
      grizzlyComboTarget = null;
      marketCrashActive = false;
      marketCrashTimer = 0;
      marketCrashShakeOffset = { x: 0, y: 0 };
      leaderboardPending = false;
      // Wire up question block callbacks
      for (const block of level.questionBlocks) {
        block.setHitCallback((contents, x, y) => {
          spawnFromBlock(contents, x, y);
          audio.playBlockHit();
        });
      }
      currentState = GameState.PLAYING;
    } else {
      // All levels complete! Submit final score to leaderboard before returning to title
      if (!leaderboard.submittedThisSession) {
        triggerLeaderboard(player.score, player.totalBullsCollected, levelTime, player.characterType);
        // Stay on level complete screen until leaderboard resolves
        if (leaderboardPending) return;
      }
      titleScreen = new TitleScreen();
      currentState = GameState.TITLE;
    }
  }
}

// ==========================================
//  Main Render
// ==========================================
function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const scale = getScale();
  const offsetX = (canvas.width - CONFIG.VIRTUAL_WIDTH * scale) / 2;
  const offsetY = (canvas.height - CONFIG.VIRTUAL_HEIGHT * scale) / 2;

  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);

  // Clip to virtual viewport
  ctx.beginPath();
  ctx.rect(0, 0, CONFIG.VIRTUAL_WIDTH, CONFIG.VIRTUAL_HEIGHT);
  ctx.clip();

  switch (currentState) {
    case GameState.TITLE:
      titleScreen.render(ctx, CONFIG.VIRTUAL_WIDTH, CONFIG.VIRTUAL_HEIGHT);
      break;

    case GameState.PLAYING:
      renderPlaying();
      break;

    case GameState.GAME_OVER:
      renderPlaying();
      gameOverScreen.render(ctx, CONFIG.VIRTUAL_WIDTH, CONFIG.VIRTUAL_HEIGHT);
      break;

    case GameState.LEVEL_COMPLETE:
      renderPlaying();
      levelCompleteScreen.render(ctx, CONFIG.VIRTUAL_WIDTH, CONFIG.VIRTUAL_HEIGHT);
      break;
  }

  ctx.restore();

  // Touch controls overlay (drawn in screen-space, outside game viewport transform)
  touchControls.render(ctx, canvas.width, canvas.height, currentState);
}

function renderPlaying() {
  if (marketCrashActive) {
    ctx.save();
    ctx.translate(marketCrashShakeOffset.x, marketCrashShakeOffset.y);
  }

  // Background (parallax)
  background.render(ctx, camera, CONFIG.VIRTUAL_WIDTH, CONFIG.VIRTUAL_HEIGHT, gameTime);

  // Pit voids (draw dark areas where there's no ground)
  ctx.fillStyle = CONFIG.COLORS.PIT_VOID;
  ctx.fillRect(0, 432 - camera.y, CONFIG.VIRTUAL_WIDTH, CONFIG.VIRTUAL_HEIGHT);

  // Level geometry - only render visible solids
  const viewLeft = camera.x - 100;
  const viewRight = camera.x + CONFIG.VIRTUAL_WIDTH + 100;
  for (const solid of level.solids) {
    if (solid.x + solid.width > viewLeft && solid.x < viewRight) {
      solid.render(ctx, camera);
    }
  }

  // Moving platforms
  if (level.movingPlatforms) {
    for (const mp of level.movingPlatforms) {
      mp.render(ctx, camera);
    }
  }

  // Golden Briefcase (goal)
  renderGoldenBriefcase(ctx, camera, level.goalPosition, gameTime);

  // Short Squeeze pads
  for (const pad of level.shortSqueezePads) {
    pad.render(ctx, camera);
  }

  // Collectibles
  for (const c of level.collectibles) {
    c.render(ctx, camera);
  }

  // Enemies
  for (const e of level.enemies) {
    e.render(ctx, camera);
  }

  // Boss
  if (level.boss) {
    level.boss.render(ctx, camera);
  }

  // Player
  player.render(ctx, camera);

  // Particles and floating text
  particles.render(ctx, camera);
  floatingText.render(ctx, camera);

  // Flash Crash death effect
  if (flashCrashTimer > 0) {
    ctx.globalAlpha = Math.min(flashCrashTimer * 2, 0.5);
    ctx.fillStyle = '#FF0000';
    ctx.fillRect(0, 0, CONFIG.VIRTUAL_WIDTH, CONFIG.VIRTUAL_HEIGHT);
    ctx.globalAlpha = Math.min(flashCrashTimer * 3, 1);
    ctx.fillStyle = '#FFFFFF';
    ctx.font = 'bold 48px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('FLASH CRASH', CONFIG.VIRTUAL_WIDTH / 2, CONFIG.VIRTUAL_HEIGHT / 2);
    ctx.globalAlpha = 1;
  }

  if (marketCrashActive) {
    ctx.restore();
    // Red tint overlay
    ctx.globalAlpha = 0.15 + Math.sin(marketCrashTimer * 6) * 0.05;
    ctx.fillStyle = '#FF0000';
    ctx.fillRect(0, 0, CONFIG.VIRTUAL_WIDTH, CONFIG.VIRTUAL_HEIGHT);
    ctx.globalAlpha = 1;
  }

  // HUD (screen space)
  hud.render(ctx, player, CONFIG.VIRTUAL_WIDTH);

  // Boss health bar
  if (level.boss && level.boss.activated) {
    hud.renderBossHealth(ctx, CONFIG.VIRTUAL_WIDTH, level.boss);
  }

  // Debug overlay
  if (debugMode) {
    renderDebug();
  }
}

function renderDebug() {
  // Collision boxes
  ctx.strokeStyle = 'lime';
  ctx.lineWidth = 1;

  const viewLeft = camera.x - 100;
  const viewRight = camera.x + CONFIG.VIRTUAL_WIDTH + 100;

  for (const solid of level.solids) {
    if (solid.x + solid.width > viewLeft && solid.x < viewRight) {
      ctx.strokeRect(solid.x - camera.x, solid.y - camera.y, solid.width, solid.height);
    }
  }

  // Player hitbox
  ctx.strokeStyle = 'cyan';
  ctx.lineWidth = 2;
  ctx.strokeRect(player.x - camera.x, player.y - camera.y, player.width, player.height);

  // Enemy hitboxes
  ctx.strokeStyle = 'red';
  ctx.lineWidth = 1;
  for (const e of level.enemies) {
    if (e.alive) {
      ctx.strokeRect(e.x - camera.x, e.y - camera.y, e.width, e.height);
    }
  }

  // Collectible hitboxes
  ctx.strokeStyle = 'yellow';
  for (const c of level.collectibles) {
    ctx.strokeRect(c.x - camera.x, c.y - camera.y, c.width, c.height);
  }

  // Goal hitbox
  ctx.strokeStyle = 'magenta';
  ctx.lineWidth = 2;
  ctx.strokeRect(level.goalPosition.x - camera.x, level.goalPosition.y - camera.y, 48, 48);

  // Info
  ctx.fillStyle = 'lime';
  ctx.font = '12px monospace';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText('Player: ' + Math.round(player.x) + ', ' + Math.round(player.y) +
    ' | vx: ' + Math.round(player.vx) + ' vy: ' + Math.round(player.vy) +
    ' | ground: ' + player.onGround, 10, CONFIG.VIRTUAL_HEIGHT - 30);
  ctx.fillText('Camera: ' + Math.round(camera.x) + ', ' + Math.round(camera.y) +
    ' | Enemies: ' + level.enemies.length +
    ' | Bulls: ' + level.collectibles.length, 10, CONFIG.VIRTUAL_HEIGHT - 16);
}

// ==========================================
//  Live Stock Ticker (Dow 30)
// ==========================================
async function fetchLiveStockData() {
  const DOW30 = ['AAPL','MSFT','AMGN','AXP','BA','CAT','CRM','CSCO','CVX','DIS',
    'GS','HD','HON','IBM','JNJ','JPM','KO','MCD','MMM','MRK',
    'NKE','PG','TRV','UNH','V','VZ','WBA','WMT','DOW','INTC'];

  try {
    // Try Yahoo Finance via CORS proxy
    const symbols = DOW30.join(',');
    const url = 'https://api.allorigins.win/get?url=' +
      encodeURIComponent('https://query1.finance.yahoo.com/v7/finance/quote?symbols=' + symbols + '&fields=symbol,regularMarketPrice,regularMarketChangePercent');

    const resp = await fetch(url, { signal: AbortSignal.timeout(5000) });
    const json = await resp.json();
    const data = JSON.parse(json.contents);

    if (data.quoteResponse && data.quoteResponse.result) {
      const stocks = data.quoteResponse.result.map(q => ({
        symbol: q.symbol,
        price: q.regularMarketPrice || 0,
        change: q.regularMarketChangePercent || 0
      }));
      if (stocks.length > 10) {
        return stocks;
      }
    }
  } catch (e) {
    console.warn('Live stock data unavailable, using fallback:', e.message);
  }
  return null; // Use fallback data from level
}

// Try to load live data on page load
fetchLiveStockData().then(stocks => {
  if (stocks && level) {
    level.tickerStocks = stocks;
    if (hud) hud.tickerStocks = stocks;
  }
});

// ==========================================
//  Game Loop
// ==========================================
const FIXED_DT = 1 / 60;
let accumulator = 0;
let lastTime = 0;

function gameLoop(timestamp) {
  if (lastTime === 0) lastTime = timestamp;

  let dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;

  // Cap delta to prevent spiral of death
  if (dt > 0.1) dt = 0.1;

  accumulator += dt;

  // Fixed timestep physics updates
  while (accumulator >= FIXED_DT) {
    update(FIXED_DT);
    accumulator -= FIXED_DT;
  }

  render();
  requestAnimationFrame(gameLoop);
}

// ==========================================
//  Start!
// ==========================================
requestAnimationFrame(gameLoop);
  </script>
  <script>
// ============================================================
//  HUMAN GAMEPLAY RECORDER
//  Automatically records human play sessions and saves to
//  the replay library. The bot can then learn from these.
// ============================================================

(function () {
  'use strict';

  if (!window.ReplayLib) {
    console.warn('[HUMAN REC] ReplayLib not loaded');
    return;
  }

  let isRecording = false;
  let lastState = null;

  const poll = setInterval(() => {
    if (typeof currentState === 'undefined' || typeof player === 'undefined' ||
        typeof input === 'undefined' || typeof level === 'undefined') return;

    clearInterval(poll);

    console.log('%c[HUMAN REC] Recording human gameplay for bot learning',
      'color:#FF69B4;font-weight:bold');

    // Hook into the game loop
    const _origUpdate = window.update;
    window.update = function (dt) {
      _origUpdate.call(this, dt);
      afterTick();
    };

    function afterTick() {
      const state = currentState;

      // Start recording when gameplay begins
      if (state === GameState.PLAYING && !isRecording) {
        ReplayLib.startRecording('human');
        isRecording = true;
      }

      // Record frame during gameplay
      if (state === GameState.PLAYING && isRecording && player && level) {
        const px = player.x;
        const py = player.y;
        const idx = typeof currentLevelIndex !== 'undefined' ? currentLevelIndex : 0;

        // Compute extras for state encoding
        const extras = {
          onGround: player.onGround,
          nearEnemy: false,
          nearItem: false,
          nearPit: false,
        };

        // Check nearby enemies
        if (level.enemies) {
          for (const e of level.enemies) {
            if (!e.alive) continue;
            const d = Math.abs(e.x - px);
            if (d < 200) { extras.nearEnemy = true; break; }
          }
        }

        // Check nearby collectibles
        if (level.collectibles) {
          for (const c of level.collectibles) {
            if (c.collected || c.type === 'redCandle') continue;
            const d = Math.abs(c.x - px);
            if (d < 150) { extras.nearItem = true; break; }
          }
        }

        // Check nearby pits (simple ground check)
        if (typeof LEVELS_DATA !== 'undefined' || true) {
          // Use the level's solids to detect if there's a gap ahead
          // Simple: check if player is near a pit by checking ground segments
          // We'll keep it simple — just check if player is currently over ground
          extras.nearPit = !player.onGround && player.vy > 0;
        }

        // Get current actions from input
        const actionLeft  = !!(input.keys && (input.keys['ArrowLeft'] || input.keys['a']));
        const actionRight = !!(input.keys && (input.keys['ArrowRight'] || input.keys['d']));
        const actionJump  = !!(input.keys && (input.keys['Space'] || input.keys['ArrowUp'] || input.keys['w']));
        const actionDown  = !!(input.keys && (input.keys['ArrowDown'] || input.keys['s']));

        ReplayLib.recordFrame(px, py, idx, extras, actionLeft, actionRight, actionJump, actionDown);
      }

      // Finish recording on level complete or game over
      if ((state === GameState.LEVEL_COMPLETE || state === GameState.GAME_OVER ||
           state === GameState.TITLE) && isRecording) {
        const finalScore = player ? (player.score || 0) : 0;
        const completed = (lastState === GameState.LEVEL_COMPLETE);
        ReplayLib.finishRecording(finalScore, completed);
        isRecording = false;
      }

      lastState = state;
    }

    // Show stats badge
    const stats = ReplayLib.getStats();
    if (stats.replayCount > 0) {
      console.log('%c[HUMAN REC] Replay library: ' + stats.replayCount +
        ' replays, ' + stats.totalFrames + ' frames, best: $' + stats.bestScore,
        'color:#FF69B4');
    }
  }, 100);
})();
  </script>
</body>
</html>
